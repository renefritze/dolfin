# - Try to find PETSc
# Once done this will define
#
#  PETSC_FOUND           - system has PETSc
#  PETSC_INCLUDE_DIRS    - the PETSc include directories
#  PETSC_LIBRARY_DIRS    -
#  PETSC_LIBRARIES       - Link these to use PETSc
#  PETSC_COMPILER        - Compiler used by PETSc, helpful to find a compatible MPI
#  PETSC_DEFINITIONS     - Compiler switches for using PETSc
#  PETSC_MPIEXEC         - Executable for running MPI programs
#  PETSC_VERSION_STRING  - Version string (MAJOR.MINOR.SUBMINOR)
#
#  Hack: PETSC_VERSION currently decides on the version based on the
#  layout.  Otherwise we need to run C code to determine the version.
#
# Setting these changes the behavior of the search
#  PETSC_DIR - directory in which PETSc resides
#  PETSC_ARCH - build architecture
#
# Redistribution and use is allowed according to the terms of the BSD license.
# For details see the accompanying COPYING-CMAKE-SCRIPTS file.

message(STATUS "Checking for package 'PETSc'")

# Set debian_arches (PETSC_ARCH for Debian-style installations)
foreach (debian_arches linux kfreebsd)
  if ("${CMAKE_BUILD_TYPE}" STREQUAL "Debug")
    set (DEBIAN_FLAVORS ${debian_arches}-gnu-c-debug ${debian_arches}-gnu-c-opt ${DEBIAN_FLAVORS})
  else ()
    set (DEBIAN_FLAVORS ${debian_arches}-gnu-c-opt ${debian_arches}-gnu-c-debug ${DEBIAN_FLAVORS})
  endif ()
endforeach ()

# Try to figure out PETSC_DIR
find_path (PETSC_DIR include/petsc.h
  HINTS ENV PETSC_DIR
  PATHS
  /usr/lib/petscdir/3.1 /usr/lib/petscdir/3.0.0 /usr/lib/petscdir/2.3.3 /usr/lib/petscdir/2.3.2 # Debian
  $ENV{HOME}/petsc
  DOC "PETSc Directory")

# Report result of search for PETSC_DIR
if (DEFINED PETSC_DIR)
  set(PETSC_ROOT_DIR ${PETSC_DIR})
  message (STATUS "PETSC_DIR is ${PETSC_DIR}")
else()
  message (STATUS "PETSC_DIR is empty")
endif ()

# Try to figure out PETSC_ARCH
if (PETSC_DIR AND NOT PETSC_ARCH)
  set (_petsc_arches
    $ENV{PETSC_ARCH}   # If set, use environment variable first
    ${DEBIAN_FLAVORS}  # Debian defaults
    x86_64-unknown-linux-gnu i386-unknown-linux-gnu)
  set (petscconf "NOTFOUND" CACHE FILEPATH "Cleared" FORCE)
  foreach (arch ${_petsc_arches})
    if (NOT PETSC_ARCH)
      find_path (petscconf petscconf.h
      HINTS ${PETSC_DIR}
      PATH_SUFFIXES ${arch}/include bmake/${arch}
      NO_DEFAULT_PATH)
      if (petscconf)
        set (PETSC_ARCH "${arch}" CACHE STRING "PETSc build architecture")
      endif ()
    endif ()
  endforeach ()
  set (petscconf "NOTFOUND" CACHE INTERNAL "Scratch variable" FORCE)
endif ()

# Report result of search for PETSC_ARCH
if (DEFINED PETSC_ARCH)
  message (STATUS "PETSC_ARCH is ${PETSC_ARCH}")
else ()
  message (STATUS "PETSC_ARCH is empty")
endif ()

# Look for petscconf.h
if (EXISTS ${PETSC_DIR}/${PETSC_ARCH}/include/petscconf.h)
  message (STATUS "Found petscconf.h")
  set (FOUND_PETSC_CONF 1)
else ()
  message (STATUS "Unable to find petscconf.h")
endif ()

# Get variables from PETSc configuration
if (FOUND_PETSC_CONF)

  # Create a temporary Makefile to probe the PETSc configuration
  set (petsc_config_makefile ${PROJECT_BINARY_DIR}/Makefile.petsc)
  file (WRITE ${petsc_config_makefile}
"# This file was autogenerated by FindPETSc.dolfin.cmake
PETSC_DIR  = ${PETSC_DIR}
PETSC_ARCH = ${PETSC_ARCH}
include ${PETSC_DIR}/conf/rules
include ${PETSC_DIR}/conf/variables
show :
	-@echo -n \${\${VARIABLE}}
")

  # Define macro for getting PETSc variables from Makefile
  macro (PETSC_GET_VARIABLE name var)
    set (${var} "NOTFOUND" CACHE INTERNAL "Cleared" FORCE)
    execute_process (COMMAND ${CMAKE_MAKE_PROGRAM} -f ${petsc_config_makefile} show VARIABLE=${name}
      OUTPUT_VARIABLE ${var}
      RESULT_VARIABLE petsc_return)
  endmacro ()

  # Call macro to get the PETSc variables
  #petsc_get_variable(PETSC_LIB_DIR             petsc_lib_dir)
  #petsc_get_variable(PETSC_LIB_BASIC           petsc_libs_basic)
  #petsc_get_variable(PETSC_EXTERNAL_LIB_BASIC  petsc_libs_external)
  petsc_get_variable(PETSC_LIB                 PETSC_LIBRARIES)
  #petsc_get_variable(PETSC_CCPPFLAGS           petsc_cpp_line)
  petsc_get_variable(PETSC_INCLUDE             PETSC_INCLUDE_DIRS)
  #petsc_get_variable (PCC                      petsc_cc)
  #petsc_get_variable (MPIEXEC                  petsc_mpiexec)

  # Remove temporary Makefile
  file (REMOVE ${petsc_config_makefile})

  # Turn PETSC_INCLUDE_DIRS into a semi-colon separated list
  string(REPLACE "-I" "" PETSC_INCLUDE_DIRS "${PETSC_INCLUDE_DIRS}")
  separate_arguments(PETSC_INCLUDE_DIRS)
  message(STATUS "YYYYYY: ${PETSC_INCLUDE_DIRS}")

endif ()

# Build PETSc test program
if (FOUND_PETSC_CONF)

  # Set flags for building test program
  set(CMAKE_REQUIRED_INCLUDES ${PETSC_INCLUDE_DIRS})
  set(CMAKE_REQUIRED_LIBRARIES ${PETSC_LIBRARIES})

  # Run PETSc test program
  include(CheckCXXSourceRuns)
  check_cxx_source_runs("
#include \"petscts.h\"
#include \"petsc.h\"
int main()
{
  PetscErrorCode ierr;
  TS ts;
  ierr = PetscInitializeNoArguments();CHKERRQ(ierr);
  ierr = TSCreate(PETSC_COMM_WORLD,&ts);CHKERRQ(ierr);
  ierr = TSSetFromOptions(ts);CHKERRQ(ierr);
  ierr = TSDestroy(ts);CHKERRQ(ierr);
  ierr = PetscFinalize();CHKERRQ(ierr);
  return 0;
}
" PETSC_TEST_RUNS)

  if (PETSC_TEST_RUNS)
    message(STATUS "PETSc test runs")
  else ()
    message(STATUS "PETSc test failed")
  endif ()

endif ()

# Stanard package handling
include (FindPackageHandleStandardArgs)
find_package_handle_standard_args(PETSc "PETSc could not be found.  Be sure to set PETSC_DIR and PETSC_ARCH."
                                  PETSC_ROOT_DIR PETSC_INCLUDE_DIRS PETSC_LIBRARIES )
