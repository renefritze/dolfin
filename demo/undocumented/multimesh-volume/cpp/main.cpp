#include <cmath>
#include <fstream>
#include <dolfin.h>

#include <dolfin/geometry/dolfin_simplex_tools.h>

using namespace dolfin;

//------------------------------------------------------------------------------
std::vector<std::shared_ptr<const Mesh>> random_meshes(std::size_t Nx,
						       std::size_t num_parts)
{


  // Generated by script /home/august/dev/fenics-dev/multimesh-2015/src/sandbox/mesh_generator at 02-Jun-2016 14:46:28

  const double h = 1. / Nx;

  std::vector<std::vector<Point>> points =
    {
      { Point(0.747427, 0.186781), Point(0.849659, 0.417130) },
      { Point(0.152716, 0.471681), Point(0.455943, 0.741585) },
      { Point(0.464473, 0.251876), Point(0.585051, 0.533569) },
      { Point(0.230112, 0.511897), Point(0.646974, 0.892193) },
      { Point(0.080362, 0.422675), Point(0.580151, 0.454286) },
      { Point(0.054755, 0.534186), Point(0.444096, 0.743028) },
      { Point(0.246347, 0.643033), Point(0.611211, 0.644119) },
      { Point(0.205060, 0.610043), Point(0.873978, 0.716453) },
      { Point(0.315601, 0.609597), Point(0.660068, 0.889642) },
      { Point(0.510442, 0.227960), Point(0.547733, 0.681651) },
      { Point(0.631782, 0.625248), Point(0.939937, 0.734633) },
      { Point(0.630514, 0.130426), Point(0.789759, 0.605254) },
      { Point(0.366874, 0.077819), Point(0.799717, 0.247002) },
      { Point(0.634452, 0.166130), Point(0.720499, 0.957903) },
      { Point(0.310176, 0.376406), Point(0.733204, 0.559494) },
      { Point(0.457794, 0.195561), Point(0.669801, 0.814364) },
      { Point(0.507921, 0.543829), Point(0.604354, 0.637256) },
      { Point(0.042519, 0.138396), Point(0.289660, 0.698498) },
      { Point(0.531146, 0.112000), Point(0.786345, 0.496440) },
      { Point(0.755547, 0.804976), Point(0.783852, 0.905749) },
      { Point(0.135990, 0.421423), Point(0.721689, 0.598717) },
      { Point(0.294942, 0.314007), Point(0.823500, 0.606792) },
      { Point(0.384000, 0.479182), Point(0.974647, 0.613010) },
      { Point(0.356791, 0.728380), Point(0.770159, 0.802342) },
      { Point(0.371233, 0.542066), Point(0.978624, 0.648035) },
      { Point(0.719941, 0.326586), Point(0.878289, 0.517651) },
      { Point(0.810330, 0.554044), Point(0.865130, 0.586726) },
      { Point(0.715135, 0.517116), Point(0.773488, 0.867894) },
      { Point(0.063054, 0.556346), Point(0.385853, 0.739599) },
      { Point(0.416569, 0.045984), Point(0.691243, 0.529570) },
      { Point(0.415423, 0.634109), Point(0.566714, 0.768729) },
      { Point(0.765750, 0.205375), Point(0.933004, 0.430380) },
      { Point(0.584073, 0.423089), Point(0.598574, 0.677415) },
      { Point(0.202824, 0.350436), Point(0.602496, 0.350622) },
      { Point(0.166122, 0.147433), Point(0.584457, 0.873023) },
      { Point(0.276331, 0.306927), Point(0.756209, 0.962107) },
      { Point(0.148461, 0.046180), Point(0.490417, 0.947779) },
      { Point(0.072863, 0.633958), Point(0.289068, 0.825418) },
      { Point(0.782015, 0.454994), Point(0.912484, 0.721990) },
      { Point(0.305546, 0.449086), Point(0.838901, 0.454008) },
      { Point(0.375838, 0.409314), Point(0.645968, 0.761390) },
      { Point(0.169756, 0.500825), Point(0.550513, 0.613456) },
      { Point(0.217436, 0.170923), Point(0.408271, 0.211427) },
      { Point(0.393828, 0.373691), Point(0.472135, 0.735436) },
      { Point(0.523821, 0.426144), Point(0.902130, 0.426845) },
      { Point(0.273991, 0.113629), Point(0.635717, 0.519508) },
      { Point(0.524145, 0.159222), Point(0.876302, 0.369831) },
      { Point(0.535785, 0.284029), Point(0.864152, 0.895106) },
      { Point(0.464676, 0.083968), Point(0.671590, 0.211442) },
      { Point(0.594766, 0.011844), Point(0.707712, 0.265403) }
    };

  std::vector<double> angles =
    {{ 88.339755, 94.547259, 144.366564, 172.579922, 95.439692, 106.697958, 175.788281, 172.468177, 40.363410, 103.866765, 143.106588, 98.869318, 20.516877, 35.108539, 137.423965, 90.249864, 34.446790, 4.621397, 72.857255, 159.991224, 178.510861, 55.788859, 28.163059, 132.222868, 29.606199, 174.993928, 148.036367, 19.177764, 168.827333, 168.008844, 94.710245, 46.129366, 111.622092, 13.585448, 150.515846, 6.340156, 13.178734, 159.027957, 64.313903, 77.979669, 138.651353, 18.916756, 39.967938, 71.345030, 76.804783, 167.944421, 18.516992, 17.648271, 104.164880, 30.083616}};

  dolfin_assert(num_parts <= angles.size());
  std::vector<std::shared_ptr<Mesh>> meshes(num_parts+1);

  meshes[0] = std::make_shared<UnitSquareMesh>(std::round(1./h), std::round(1./h));

  for (std::size_t i = 0; i < num_parts; ++i)
  {
    meshes[i+1] = std::make_shared<RectangleMesh>
      (points[i][0], points[i][1],
       std::max<std::size_t>(std::round(std::abs(points[i][0].x()-points[i][1].x()) / h), 1),
       std::max<std::size_t>(std::round(std::abs(points[i][0].y()-points[i][1].y()) / h), 1));
    meshes[i+1]->rotate(angles[i]);
  }

  std::vector<std::shared_ptr<const Mesh>> copy_meshes(num_parts);
  for (std::size_t i = 0; i < num_parts; ++i)
    copy_meshes[i] = meshes[i];

  return copy_meshes;


}


int main(int argc, char* argv[])
{
  const std::size_t N = 1;
  auto mesh_0 = std::make_shared<UnitSquareMesh>(N, N);

  // double exact_area = 0;
  // const double L1 = 0.4;
  // auto mesh_1 = std::make_shared<RectangleMesh>(Point(0.05, 0.95-L1), Point(0.05+L1, 0.95), N, N);
  // exact_area += 4*L1;
  // const double L2 = 0.1;
  // auto mesh_2 = std::make_shared<RectangleMesh>(Point(0.1, 0.9-L2), Point(0.1+L2, 0.9), N, N);


  // double exact_area = 0;
  // const Point p0(0.1, 0.2);
  // const double L1 = 0.4;
  // auto mesh_1 = std::make_shared<RectangleMesh>(p0, p0 + Point(L1,L1), N, N);
  // exact_area += 4*L1;
  // const Point p1(0.2, 0.4);
  // const double L2 = L1;
  // auto mesh_2 = std::make_shared<RectangleMesh>(p1, p1 + Point(L2,L2), N, N);
  // exact_area += 4*L2 - 0.5*L1 - 0.75*L1;


  // double exact_area = 0;
  // auto mesh_1 = std::make_shared<RectangleMesh>(Point(0.1, 0.1), Point(0.9, 0.9), N, N);
  // mesh_1->translate(Point(-0.05, 0.05));
  // exact_area += 4*0.8;
  // auto mesh_2 = std::make_shared<RectangleMesh>(Point(0.2, 0.2), Point(0.8, 0.8), N, N);
  // mesh_2->translate(Point(-0.025, 0.025));
  // exact_area += 4*0.6;
  // auto mesh_3 = std::make_shared<RectangleMesh>(Point(0.3, 0.3), Point(0.7, 0.7), N, N);
  // mesh_3->translate(Point(-0.0125, 0.0125));
  // exact_area += 4*0.4;
  // auto mesh_4 = std::make_shared<RectangleMesh>(Point(0.4, 0.4), Point(0.6, 0.6), N, N);
  // mesh_4->translate(Point(-0.0125/2, 0.0125/2));
  // exact_area += 4*0.2;

  // tools::dolfin_write_medit_triangles("mesh0",*mesh_0);
  // tools::dolfin_write_medit_triangles("mesh1",*mesh_1);
  // tools::dolfin_write_medit_triangles("mesh2",*mesh_2);

  const double exact_volume = 1.;

  // // Build multimesh
  // auto multimesh = std::make_shared<MultiMesh>();
  // multimesh->add(mesh_0);
  // multimesh->add(mesh_1);
  // multimesh->add(mesh_2);
  // multimesh->add(mesh_3);
  // multimesh->build(1);
  // tools::dolfin_write_medit_triangles("multimesh",*multimesh);

  auto multimesh = std::make_shared<MultiMesh>();
  const std::size_t num_parts = argc > 1 ? atoi(argv[1]) : 1;
  const std::size_t Nx = std::pow(2, 1);
  auto meshes = random_meshes(Nx, num_parts);
  for (std::size_t i = 0; i < num_parts; ++i)
    multimesh->add(meshes[i]);
  multimesh->build(1);
  tools::dolfin_write_medit_triangles("multimesh",*multimesh);

  const double volume = tools::compute_volume(*multimesh);
  std::cout << "volume " << volume << ' ' << exact_volume <<" error="<< std::abs(volume-exact_volume) << std::endl;

  // const double area = tools::compute_interface_area(*multimesh);
  // std::cout << "area " << area << ' ' << exact_area << " error="<<std::abs(area-exact_area) << std::endl;

  // const double volume_overlap = tools::compute_volume_overlap(*multimesh);
  // std::cout << "volume_overlap = " << volume_overlap << std::endl;
}
