# Copyright (c) 2009 Mirko Maraldi and Garth N. Wells.
# Licensed under the GNU LGPL Version 2.1
#
# First added:  2009-01-22
# Last changed: 2009-01-27
#
# The bilinear form and linear form for linear elastodynamics
# using the generalised-alpha method
#
# Compile this form with FFC: ffc -l dolfin ElastoDynamics.form.

element   = VectorElement("Lagrange", "triangle", 1)
vconstant = VectorElement("Discontinuous Lagrange", "triangle", 0)
constant  = FiniteElement("Discontinuous Lagrange", "triangle", 0)

# Test and trial functions
r = TestFunction (element)
u = TrialFunction(element)

# Fields from previous time step
u0      = Function(element)   # displacement
v0      = Function(element)   # velocity
a0      = Function(element)   # acceleration
p0      = Function(element)   # external load

# External forces
f       = Function(vconstant) # body forces
p       = Function(element)   # externally applied loads

# Material parameters
rho     = Function(constant)  # mass density
eta     = Function(constant)  # damping coefficient
lmbda   = Function(constant)  # Lame coefficient
mu      = Function(constant)  # Lame coefficient

# Time stepping parameters
alpha_m = Function(constant)
alpha_f = Function(constant)
beta    = Function(constant)
gamma   = Function(constant)
dt      = Function(constant)



factor_m1  = rho*(1.0-alpha_m)/(beta*dt*dt)
factor_m2  = rho*(1.0-alpha_m)/(beta*dt)
factor_m3  = rho*(1.0-alpha_m-2.0*beta)/(2.0*beta)

factor_d1  = eta*(1.0-alpha_f)*gamma/(beta*dt)
factor_d2  = eta*((1.0-alpha_f)*gamma-beta)/beta
factor_d3  = eta*(gamma-2.0*beta)*(1.0-alpha_f)*dt/(2.0*beta)

# Strain tensor
def eps(r):
    return 0.5*(grad(r) + grad(r).T)

# Stress tensor
def sigma(r):
    return 2.0*mu*eps(r) + lmbda*tr(eps(r))*Identity(r.cell().d)

# Forms
a = factor_m1*inner(r, u)*dx  \
   +factor_d1*inner(r, u)*dx \
   +(1.0-alpha_f)*inner(grad(r), sigma(u))*dx

L =  factor_m1*inner(r, u0)*dx + factor_m2*inner(r, v0)*dx + factor_m3*inner(r, a0)*dx  \
   + factor_d1*inner(r, u0)*dx + factor_d2*inner(r, v0)*dx + factor_d3*inner(r, a0)*dx  \
   - alpha_f*inner(grad(r), sigma(u0))*dx \
   + inner(r, f)*dx + (1.0-alpha_f)*inner(r, p)*ds(3) + alpha_f*inner(r, p0)*ds(3)

