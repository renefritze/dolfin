<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.10: http://docutils.sourceforge.net/" />
<title>Singular</title>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7514 2012-09-14 14:27:12Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="singular">
<h1 class="title">Singular</h1>

<p>This demo is implemented in a single Python file,
_:download:<cite>demo_singular.py</cite>, which contains both the variational forms
and the solver.</p>
<p>This demo illustrates how to:</p>
<ul class="simple">
<li>Solve a linear partial differential equation</li>
<li>Apply non-zero Neumann boundary conditions</li>
<li>Define Expressions</li>
<li>Define a FunctionSpace</li>
<li>Use the Krylov solver</li>
</ul>
<p>The solution for <span class="math">\(u\)</span>
 in this demo will look as follows:</p>
<img alt="../singular_u.png" src="../singular_u.png" style="width: 450.0px; height: 300.0px;" />
<div class="section" id="equation-and-problem-definition">
<h1>Equation and problem definition</h1>
<p>The Poisson equation is the canonical elliptic partial differential equation.  For a domain <span class="math">\(\Omega \in \mathbb{R}^n\)</span>
  with boundary <span class="math">\(\Gamma = \partial \Omega\)</span>
, the Poisson equation with pure Neumann boundary conditions reads:</p>
<div class="math">
\begin{align*}
-\nabla^{2} u &amp;= f \quad {\rm in} \ \Omega \\
\nabla u \cdot n &amp;= g \quad {\rm on} \ \Gamma \\
\end{align*}
</div>
<p>Since only Neumann conditions are applied, <span class="math">\(u\)</span>
 is only determined up to
a constant by the above equations. An addition constraint is thus
required, for instance</p>
<div class="math">
\begin{equation*}
\int u \, {\rm d} x = 0
\end{equation*}
</div>
<p>The most standard variational form of Poisson equation reads: find <span class="math">\(u \in V\)</span>
 such that</p>
<div class="math">
\begin{equation*}
a(u, v) = L(v) \quad \forall \ v \in V,
\end{equation*}
</div>
<p>where <span class="math">\(V\)</span>
 is a suitable function space and</p>
<div class="math">
\begin{align*}
a(u, v) &amp;= \int_{\Omega} \nabla u \cdot \nabla v \, {\rm d} x, \\
L(v)    &amp;= \int_{\Omega} f v \, {\rm d} x
         + \int_{\Gamma} g v \, {\rm d} s.
\end{align*}
</div>
<p>The expression <span class="math">\(a(u, v)\)</span>
 is the bilinear form and <span class="math">\(L(v)\)</span>

is the linear form.</p>
<p>If we make the Ansatz that <span class="math">\(u\)</span>
 can be expressed as a linear combination of the basis functions <span class="math">\(V\)</span>
, and we discretize the equation we can write our problem as a linear system:</p>
<div class="math">
\begin{equation*}
AU = b
\end{equation*}
</div>
<p>where <span class="math">\(U\)</span>
 gives the coefficient for the basis functions expressing <span class="math">\(u\)</span>
.</p>
<p>Since we have pure Neumann boundary conditions the matrix <span class="math">\(A\)</span>
 is singular, and it therefore exist a vector <span class="math">\(e\)</span>
 such that</p>
<div class="math">
\begin{equation*}
Ae=0
\end{equation*}
</div>
<p>span <span class="math">\(\{ e \}\)</span>
 is the null space of A, and by removing the components of b that lies in the null space we make the system solvable.</p>
<p>In this demo, we shall consider the following definitions of the input
functions, the domain, and the boundaries:</p>
<ul class="simple">
<li><span class="math">\(\Omega = [0,1] \times [0,1]\)</span>
 (a unit square)</li>
<li><span class="math">\(\Gamma = \partial \Omega\)</span>
 (boundary)</li>
<li><span class="math">\(g = -\sin(5x)\)</span>
 (normal derivative)</li>
<li><span class="math">\(f = 10\exp(-((x - 0.5)^2 + (y - 0.5)^2) / 0.02)\)</span>
 (source term)</li>
</ul>
</div>
<div class="section" id="implementation">
<h1>Implementation</h1>
<p>This description goes through the implementation (in
_:download:<cite>demo_singular.py</cite>) of a solver for the above described Poisson
equation step-by-step.</p>
<p>First, the _:py:mod:<cite>dolfin</cite> module is imported:</p>
<pre class="code python literal-block">
<span class="keyword namespace">from</span> <span class="name namespace">dolfin</span> <span class="keyword namespace">import</span> <span class="operator">*</span>
</pre>
<p>Then, we check that dolfin is configured with the backend called PETSc, since it provides us with a wide range of methods used by KrylovSolver. We set PETSc as our backend for linear algebra.</p>
<pre class="code python literal-block">
<span class="comment"># Test for PETSc</span>
<span class="keyword">if</span> <span class="operator word">not</span> <span class="name">has_linear_algebra_backend</span><span class="punctuation">(</span><span class="literal string">&quot;PETSc&quot;</span><span class="punctuation">):</span>
    <span class="name">info</span><span class="punctuation">(</span><span class="literal string">&quot;DOLFIN has not been configured with PETSc. Exiting.&quot;</span><span class="punctuation">)</span>
    <span class="name builtin">exit</span><span class="punctuation">()</span>

<span class="name">parameters</span><span class="punctuation">[</span><span class="literal string">&quot;linear_algebra_backend&quot;</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="literal string">&quot;PETSc&quot;</span>
</pre>
<p>We begin by defining a mesh of the domain and a finite element function space <span class="math">\(V\)</span>
 relative to this mesh. As the unit square is a very standard domain, we can use a built-in mesh provided by the class _:py:class:<cite>UnitSquareMesh &lt;dolfin.cpp.UnitSquareMesh&gt;</cite>. In order to create a mesh consisting of <span class="math">\(64 \times 64\)</span>
 squares with each square divided into two triangles,  we do as follows</p>
<pre class="code python literal-block">
<span class="comment"># Create mesh and define function space</span>
<span class="name">mesh</span> <span class="operator">=</span> <span class="name">UnitSquareMesh</span><span class="punctuation">(</span><span class="literal number integer">64</span><span class="punctuation">,</span> <span class="literal number integer">64</span><span class="punctuation">)</span>
<span class="name">V</span> <span class="operator">=</span> <span class="name">FunctionSpace</span><span class="punctuation">(</span><span class="name">mesh</span><span class="punctuation">,</span> <span class="literal string">&quot;CG&quot;</span><span class="punctuation">,</span> <span class="literal number integer">1</span><span class="punctuation">)</span>
</pre>
<p>Now, we need to specify the trial functions (the unknowns) and the test functions on the space <span class="math">\(V\)</span>
. This can be done using TrialFunctions and TestFunctions as follows</p>
<pre class="code python literal-block">
<span class="name">u</span> <span class="operator">=</span> <span class="name">TrialFunction</span><span class="punctuation">(</span><span class="name">V</span><span class="punctuation">)</span>
<span class="name">v</span> <span class="operator">=</span> <span class="name">TestFunction</span><span class="punctuation">(</span><span class="name">V</span><span class="punctuation">)</span>
</pre>
<p>Further, the source <span class="math">\(f\)</span>
 and the boundary normal derivative <span class="math">\(g\)</span>
 are involved in the variational forms, and hence we must specify these. Both <span class="math">\(f\)</span>
 and <span class="math">\(g\)</span>
 are given by simple mathematical formulas, and can be easily declared using the Expression class. Note that the strings defining f and g use C++ syntax since, for efficiency, DOLFIN will generate and compile C++ code for these expressions at run-time.</p>
<pre class="code python literal-block">
<span class="name">f</span> <span class="operator">=</span> <span class="name">Expression</span><span class="punctuation">(</span><span class="literal string">&quot;10*exp(-(pow(x[0] - 0.5, 2) + pow(x[1] - 0.5, 2)) / 0.02)&quot;</span><span class="punctuation">)</span>
<span class="name">g</span> <span class="operator">=</span> <span class="name">Expression</span><span class="punctuation">(</span><span class="literal string">&quot;-sin(5*x[0])&quot;</span><span class="punctuation">)</span>
</pre>
<p>With <span class="math">\(u,v,f\)</span>
 and <span class="math">\(g\)</span>
, we can write down the bilinear form <span class="math">\(a\)</span>
 and the linear form <span class="math">\(L\)</span>
 (using UFL operators).</p>
<pre class="code python literal-block">
<span class="name">a</span> <span class="operator">=</span> <span class="name">inner</span><span class="punctuation">(</span><span class="name">grad</span><span class="punctuation">(</span><span class="name">u</span><span class="punctuation">),</span> <span class="name">grad</span><span class="punctuation">(</span><span class="name">v</span><span class="punctuation">))</span><span class="operator">*</span><span class="name">dx</span>
<span class="name">L</span> <span class="operator">=</span> <span class="name">f</span><span class="operator">*</span><span class="name">v</span><span class="operator">*</span><span class="name">dx</span> <span class="operator">+</span> <span class="name">g</span><span class="operator">*</span><span class="name">v</span><span class="operator">*</span><span class="name">ds</span>
</pre>
<p>In order to transform our variational problem into a linear system we need to assemble the coefficient matrix A and the right-side vector b. We do this using the function assemble:</p>
<pre class="code python literal-block">
<span class="comment"># Assemble system</span>
<span class="name">A</span> <span class="operator">=</span> <span class="name">assemble</span><span class="punctuation">(</span><span class="name">a</span><span class="punctuation">)</span>
<span class="name">b</span> <span class="operator">=</span> <span class="name">assemble</span><span class="punctuation">(</span><span class="name">L</span><span class="punctuation">)</span>
</pre>
<p>We specify a Vector for storing the result by defining a Function.</p>
<pre class="code python literal-block">
<span class="comment"># Solution Function</span>
<span class="name">u</span> <span class="operator">=</span> <span class="name">Function</span><span class="punctuation">(</span><span class="name">V</span><span class="punctuation">)</span>
</pre>
<p>Next, we specify the iterative solver we want to use, in this case a KrylovSolver. The first argument is the left-hand side matrix, and the second argument specifies the method used. In this case we use the Generalized Minimum Residual (GMRES) method.</p>
<pre class="code python literal-block">
<span class="comment"># Create Krylov solver</span>
<span class="name">solver</span> <span class="operator">=</span> <span class="name">KrylovSolver</span><span class="punctuation">(</span><span class="name">A</span><span class="punctuation">,</span> <span class="literal string">&quot;gmres&quot;</span><span class="punctuation">)</span>
</pre>
<p>We impose our additional constraint by removing the null space component from the solution vector. In order to do this we need a basis for the null space. This is done by creating a vector that spans the null space, and then define a basis from it. The basis is then attached to the Krylor Solver as its null space.</p>
<pre class="code python literal-block">
<span class="comment"># Create vector that spans the null space</span>
<span class="name">null_vec</span> <span class="operator">=</span> <span class="name">Vector</span><span class="punctuation">(</span><span class="name">u</span><span class="operator">.</span><span class="name">vector</span><span class="punctuation">())</span>
<span class="name">V</span><span class="operator">.</span><span class="name">dofmap</span><span class="punctuation">()</span><span class="operator">.</span><span class="name">set</span><span class="punctuation">(</span><span class="name">null_vec</span><span class="punctuation">,</span> <span class="literal number float">1.0</span><span class="punctuation">)</span>
<span class="name">null_vec</span> <span class="operator">*=</span> <span class="literal number float">1.0</span><span class="operator">/</span><span class="name">null_vec</span><span class="operator">.</span><span class="name">norm</span><span class="punctuation">(</span><span class="literal string">&quot;l2&quot;</span><span class="punctuation">)</span>

<span class="comment"># Create null space basis object and attach to Krylov solver</span>
<span class="name">null_space</span> <span class="operator">=</span> <span class="name">VectorSpaceBasis</span><span class="punctuation">([</span><span class="name">null_vec</span><span class="punctuation">])</span>
<span class="name">solver</span><span class="operator">.</span><span class="name">set_nullspace</span><span class="punctuation">(</span><span class="name">null_space</span><span class="punctuation">)</span>
</pre>
<p>Orthogonalize b with respect to the null space makes sure that it doesn't contain any component in the null space.</p>
<pre class="code python literal-block">
<span class="name">null_space</span><span class="operator">.</span><span class="name">orthogonalize</span><span class="punctuation">(</span><span class="name">b</span><span class="punctuation">);</span>
</pre>
<p>Finally we are able to solve our linear system</p>
<pre class="code python literal-block">
<span class="name">solver</span><span class="operator">.</span><span class="name">solve</span><span class="punctuation">(</span><span class="name">u</span><span class="operator">.</span><span class="name">vector</span><span class="punctuation">(),</span> <span class="name">b</span><span class="punctuation">)</span>
</pre>
<p>and plot the solution</p>
<pre class="code python literal-block">
<span class="name">plot</span><span class="punctuation">(</span><span class="name">u</span><span class="punctuation">,</span> <span class="name">interactive</span><span class="operator">=</span><span class="name builtin pseudo">True</span><span class="punctuation">)</span>
</pre>
</div>
</div>
</body>
</html>
