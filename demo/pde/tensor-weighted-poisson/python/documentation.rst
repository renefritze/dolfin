.. Documentation for the tensor weighted Poisson demo from DOLFIN.

.. _demo_pde_tensor-weighted-poisson_python_documentation:

Tensor Weighted Poisson 
=======================

This demo is implemented in two files; one file, :download:`demo_tensor-weighted-poisson.py` ,  :download:`generate_data.py` , for generating data, and one file, :download:`demo_tensor-weighted-poisson.py` , which contains both the vaiational form and the solver. :download:`generate_data.py`

.. include:: ../common.txt

Implementation
--------------

This description goes through the implementation (in :download:`demo_tensor-weighted-poisson.py` and :download:`generate_data.py`) of a solver for the above described Poisson equation step-by-step.

Implementation of generate_data.py
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Implementation of tensor-weighted-poisson.py
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

First, the :py:mod:`dolfin` module is imported:

.. code-block:: python

	from dolfin import *

We proceed by defining a mesh of the domain and a finite element function space :math:`V` relative to this mesh. We read the mesh file generated by :download:`generate_data.py` and create function space in the following way

.. code-block:: python
	
	# Read mesh from file and create function space
	mesh = Mesh("mesh.xml.gz")
	V = FunctionSpace(mesh, "Lagrange", 1)

The second argument to :py:class:`FunctionSpace <dolfin.cpp.function.FunctionSpace>` is the finite element family, while the third argument specifies the polynomial degree. Thus, in this case, our space :math:`V` consists of first-order, continuous Lagrange finite element functions (or in order words, continuous piecewise linear polynomials).

Next, we want to consider the Dirichlet boundary condition. A simple Python function, returning a boolean, can be used to define the subdomain for the Dirichlet boundary condition (:math:`\Gamma_D`). The function should return True for those points inside the subdomain and False for the points outside. In our case, we want to say that the points :math:`(x, y)` such that :math:`x = 0` or :math:`x = 1` are inside on the inside of :math:`\Gamma_D`. (Note that because of rounding-off errors, it is often wise to instead specify :math:`x < \epsilon` or :math:`x > 1 - \epsilon` where :math:`\epsilon` is a small number (such as machine precision).)

.. code-block:: python
	
	# Define Dirichlet boundary (x = 0 or x = 1)
	def boundary(x):
    	return x[0] < DOLFIN_EPS or x[0] > 1.0 - DOLFIN_EPS

Now, the Dirichlet boundary condition can be created using the class :py:class:`DirichletBC <dolfin.cpp.fem.DirichletBC>`. A :py:class:`DirichletBC <dolfin.cpp.fem.DirichletBC>` takes three arguments: the function space the boundary condition applies to, the value of the boundary condition, and the part of the boundary on which the condition applies. In our example, the function space is :math:`V`, the value of the boundary condition :math:`(0.0)` can represented using a :py:class:`Constant <dolfin.functions.constant.Constant>` and the Dirichlet boundary is defined immediately above. The definition of the Dirichlet boundary condition then looks as follows:

.. code-block:: python

	# Define boundary condition
	u0 = Constant(0.0)
	bc = DirichletBC(V, u0, boundary)

...Something about C++ expression ...

...something about definition of conductivity expression and matrix ...

Next, we want to express the variational problem. First, we need to specify the trial function :math:`u` and the test function :math:`v`, both living in the function space :math:`V`. We do this by defining a :py:func:`TrialFunction <dolfin.functions.function.TrialFunction>` and a :py:func:`TestFunction <dolfin.functions.function.TestFunction>` on the previously defined :py:class:`FunctionSpace <dolfin.cpp.function.FunctionSpace>` :math:`V`.

Further, the source :math:`f` is involved in the variational form, and hence it must be must specified. Since :math:`f` is given by a simple mathematical formula, it can easily be declared using the :py:class:`Expression <dolfin.cpp.function.Expression>` class. Note that the string defining :math:`f` uses C++ syntax since, for efficiency, DOLFIN will generate and compile C++ code for these expressions at run-time.

With these ingredients, we can write down the bilinear form :math:`a` and the linear form :math:`L` (using UFL operators). In summary, this reads

.. code-block::
	
	# Define variational problem
	u = TrialFunction(V)
	v = TestFunction(V)
	f = Expression("10*exp(-(pow(x[0] - 0.5, 2) + pow(x[1] - 0.5, 2)) / 0.02)")
	a = inner(C*grad(u), grad(v))*dx
	L = f*v*dx

Now, we have specified the bilinear and linear forms and can consider the solution of the variational problem. First, we need to define a :py:class:`Function <dolfin.cpp.function.Function>` :math:`u` to represent the solution. (Upon initialization, it is simply set to the zero function.) A :py:class:`Function <dolfin.cpp.function.Function>` represents a function living in a finite element function space. Next, we can call the :py:meth:`solve <dolfin.cpp.fem.GenericAdaptiveVariationalSolver.solve>` function with the arguments :math:`a == L`, :math:`u` and :math:`bc` as follows:

.. code-block:: python

	# Compute solution
	u = Function(V)
	solve(a == L, u, bc)

The function :math:`u` will be modified during the call to solve. The default settings for solving a variational problem have been used. However, the solution process can be controlled in much more detail if desired.

A :py:class:`Function <dolfin.cpp.function.Function>` can be manipulated in various ways, in particular, it can be plotted and saved to file. Here, we output the solution to a VTK file (using the suffix .pvd) for later visualization and also plot it using the :py:meth:`plot <dolfin.cpp.io.VTKPlotter.plot>` command:

.. code-block:: python

	# Save solution in VTK format
	file = File("poisson.pvd")
	file << u

	# Plot solution
	plot(u, interactive=True)

	

Complete code
-------------

.. literalinclude:: demo_tensor-weighted-poisson.py
   :start-after: # Begin demo
