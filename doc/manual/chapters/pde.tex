\chapter{Partial differential equations}
\label{sec:pde}
\index{partial differential equations}

\section{Boundary value problems}

As a prototype of a boundary value problem in $\Bbb{R}^d$ we consider the 
scalar Poisson equation with homogeneous Dirichlet boundary conditions 
\begin{eqnarray}
-\Delta u(x)&=&f(x) \quad x\in \Omega \subset \Bbb{R}^d \label{pde:poisson:strong} \\
u(x)&=&0 \quad x\in \partial \Omega. \nonumber  
\end{eqnarray}

\section{Variational formulation}

A variational formulation of (\ref{pde:poisson:strong}) take the form: 
find $u\in V$ such that  
\begin{equation}\label{pde:poisson:weak}
a(u,v)=L(v) \quad \forall v\in V, 
\end{equation}
where $a(\cdot,\cdot):V\times V\rightarrow \Bbb{R}$ is a bilinear form 
on $V$ defined by 
\begin{equation}
a(u,v)=\int_{\Omega} \nabla u \cdot \nabla v ~dx 
=\int_{\Omega} \frac{\partial u}{\partial x_i} \frac{\partial v}{\partial x_i} ~ dx,  
\end{equation}
where we employ tensor notation so that the double index $i$ means summation from $i=1,...,d$, 
and $L(\cdot):V\rightarrow \Bbb{R}$ is a linear form on $V$ defined by 
\begin{equation}
L(v)=\int_{\Omega} f v ~dx.  
\end{equation}
$V=H^1_0(\Omega)$ is the standard Sobolev space of square integrable 
functions with also their first derivatives square integrable (in the Lebesgue sense), 
with the functions being zero on the boundary (in the sense of traces).   

The Finite Element Method FEM for (\ref{pde:poisson:weak}) is now: 
find $U\in V_h$ such that  
\begin{equation}\label{pde:poisson:fem}
a(U,v)=L(v) \quad \forall v\in V_h, 
\end{equation}
where $V_h\subset V$ is a finite dimensional subspace of dimension $N$. 
The finite element space $V_h$ is characterized by the set of basis 
functions $\{\varphi_i\}_{i=1}^N$, and thus the FEM method 
(\ref{pde:poisson:fem}) is specified by the variational form and 
the basis functions of $V_h$. 

\section{Compiling the variational form with FFC}

In \dolfin{} a PDE is defined in variational form using tensor notation 
in a \texttt{.form} file, which is compiled using FFC. 

At \texttt{/dolfin/src/demo/solvers/poisson/dolfin/} the following 
\texttt{poisson.form} file for (\ref{pde:poisson:fem}) can be found  
\begin{code}
# Copyright (C) 2005 Johan Hoffman and Anders Logg.
# Licensed under the GNU GPL Version 2.
#
# First added:  2005-04-04
# Last changed: 2005
#
# The bilinear form a(u,v) and linear form L(v) for
# Poisson's equation.
#
# Compile this form with FFC: ffc poisson.form.

element = FiniteElement("Lagrange", "tetrahedron", 1)

v = BasisFunction(element)
u = BasisFunction(element)
f = Function(element)

a = v.dx(i)*u.dx(i)*dx
L = v*f*dx
\end{code}

Compiling the file with 
\begin{code}
# ffc Poisson.form
\end{code}
generate a file \texttt{Poisson.h} containing the classes 
\texttt{BilinearForm} and \texttt{LinearForm}, and 
classes for the finite element used in the forms. 

\section{The FEM class}

The FEM class automates the assembly algorithm, constructing a linear 
system of equations from a given partial differential equation, 
specified as a variational problem (\ref{pde:poisson:weak}), 
by a bilinear form $a(\cdot,\cdot)$ and a linear form $L(\cdot)$, 
according to 
\begin{code}
/// Assemble bilinear and linear forms
static void assemble(BilinearForm& a, LinearForm& L, 
		     Matrix& A, Vector& b, Mesh& mesh);
\end{code}

The assemble function is called in the following way 
\begin{code}
FEM::assemble(a,L,A,b,mesh);
\end{code}
where $A$ and $b$ is a matrix and vector respectively. 

\section{The BilinearForm class}

BilinearForm represents a bilinear form $a(u,v)$ with arguments v
and u basis functions of the finite element space defined by a
pair of finite elements (test and trial).

This class is automatically generated by FFC when compiling the 
variational form. 

The function used in the assembly algorithm is an eval function 
\begin{code}
/// Compute element matrix (interior contribution)
virtual void eval(real block[], const AffineMap& map) const;
\end{code}    
where the element matrix is returned in  
\texttt{block[]}, and \texttt{map} is describes the affine map used 
for mapping the reference element to the actual element. 

\section{The LinearForm class}

LinearForm represents a linear form L(v) with argument v (the
test function) a basis function of the finite element space
defined by a finite element.

This class is automatically generated by FFC when compiling the 
variational form. 

The function used in the assembly algorithm is an eval function 
\begin{code}
/// Compute element vector (interior contribution)
virtual void eval(real block[], const AffineMap& map) const;
\end{code}    
where the element vector is returned in  
\texttt{block[]}, and \texttt{map} is describes the affine map used 
for mapping the reference element to the actual element. 

\section{The AffineMap class}

This class represents the affine map from the reference element to
the current element.

The 2D reference element is given by (0,0)-(1,0)-(0,1).
The 3D reference element is given by (0,0,0)-(1,0,0)-(0,1,0)-(0,0,1).

The dimension d of the map is automatically determined from the
arguments used when calling the map.

The map is initialized by the function 
\begin{code}
/// Update map for current element
void update(const Cell& cell);
\end{code}

When \texttt{update} is called the following local variables in the 
class are computed for the current cell 
\begin{code}
// Determinant of Jacobian of map
real det;

// Jacobian of map
real f00, f01, f02, f10, f11, f12, f20, f21, f22;

// Inverse of Jacobian of map
real g00, g01, g02, g10, g11, g12, g20, g21, g22;
\end{code}

\section{The FiniteElement class}

This is the base class for finite elements automatically
generated by FFC.

\begin{code}
/// Return dimension of the finite element space
virtual unsigned int spacedim() const = 0;

/// Return dimension of the underlying shape
virtual unsigned int shapedim() const = 0;

/// Return vector dimension of the finite element space
virtual unsigned int tensordim(unsigned int i) const = 0;

/// Return vector dimension of the finite element space
virtual unsigned int rank() const = 0;
    
/// Compute map from local to global degrees of freedom
virtual void dofmap(int dofs[], const Cell& cell, 
                    const Mesh& mesh) const = 0;

/// Compute map from local to global coordinates
virtual void pointmap(Point points[], uint components[], 
                      const AffineMap& map) const = 0;
\end{code}

\section{The PDE class}

A PDE represents a (linearized) partial differential equation,
given by a bilinear form $a$ and a linear form $L$. 

\begin{code}
/// Constructor
PDE(BilinearForm& a, LinearForm& L);
\end{code}

\section{Computation of Element matrices and vectors} 

divide element matrix into geometry tensor and integration 
over reference element FErari

precomputation of integrals, quadrature, tensorrepresentation factored out, FFC 

\section{Boundary conditions}

\section{Finite elements}

Finite Element by Ciarlet, FIAT 

\section{Initial value problems}

semidiscretization, space-time FEM, 

% Insert note that constants are passed into forms as references
