\chapter{Partial differential equations}
\label{sec:pde}
\index{partial differential equations}

\section{Boundary value problems}

As a prototype of a boundary value problem in $\Bbb{R}^d$ we consider the 
scalar Poisson equation with homogeneous Dirichlet boundary conditions 
\begin{eqnarray}
-\Delta u(x)&=&f(x) \quad x\in \Omega \subset \Bbb{R}^d \label{pde:poisson:strong} \\
u(x)&=&0 \quad x\in \partial \Omega. \nonumber  
\end{eqnarray}

\section{Variational formulation}

A variational formulation of (\ref{pde:poisson:strong}) take the form: 
find $u\in V$ such that  
\begin{equation}\label{pde:poisson:weak}
a(v,u)=L(v) \quad \forall v\in \hat V, 
\end{equation}
where $a(\cdot,\cdot):\hat V\times V\rightarrow \Bbb{R}$ is a bilinear form 
acting on $\hat V \times V$, with $\hat V$ and $V$ the {\em test space} and {\em trial space} 
respectively, defined by 
\begin{equation}
a(v,u)=\int_{\Omega} \nabla v \cdot \nabla u ~dx 
=\int_{\Omega} \frac{\partial v}{\partial x_i} \frac{\partial u}{\partial x_i} ~ dx,  
\end{equation}
where we employ tensor notation so that the double index $i$ means summation from $i=1,...,d$, 
and $L(\cdot):\hat V\rightarrow \Bbb{R}$ is a linear form acting on the test space $\hat V$,  
defined by 
\begin{equation}
L(v)=\int_{\Omega} f v ~dx.  
\end{equation}
For this problem we typically use $V=\hat V=H^1_0(\Omega)$, with $H^1_0(\Omega)$ 
the standard Sobolev space of square integrable functions with also their first 
derivatives square integrable (in the Lebesgue sense), 
with the functions being zero on the boundary (in the sense of traces).   

The Finite Element Method FEM for (\ref{pde:poisson:weak}) is now: 
find $U\in V_h$ such that  
\begin{equation}\label{pde:poisson:fem}
a(v,U)=L(v) \quad \forall v\in \hat V_h, 
\end{equation}
where $V_h\subset V$ and $\hat V_h\subset \hat V$ are finite dimensional 
subspaces of dimension $N$. 
The finite element spaces $V_h,\hat V_h$ are characterized by their sets of basis 
functions $\{\varphi_i\}_{i=1}^N,\{\hat \varphi_i\}_{i=1}^N$, 
and thus the FEM method (\ref{pde:poisson:fem}) is specified by the 
variational form and the basis functions of $V_h$ and $\hat V_h$. 

\section{Finite elements and \fiat{}}

Finite element basis functions in \dolfin{} are defined using \fiat{}, 
which supports the generation of arbitrary order Lagrange finite 
elements on lines, triangles, and tetrahedra. 
Upcoming versions of \fiat{} will also support Hermite and nonconforming 
elements as well as H(div) and H(curl) elements such as Raviart-Thomas and Nedelec.

\section{Compiling the variational form with \ffc{}}

In \dolfin{} a PDE is defined in variational form using tensor notation 
in a \texttt{.form} file, which is compiled using the {\em FEniCS Form Compiler} \ffc{}. 

In the language of \ffc{}, with $V_h=\hat V_h$ the space of piecewise linear Lagrange 
finite elements on a tetrahedral mesh, (\ref{pde:poisson:fem}) is defined as:  
\begin{code}
element = FiniteElement("Lagrange", "tetrahedron", 1)

v = BasisFunction(element)
u = BasisFunction(element)
f = Function(element)

a = v.dx(i)*u.dx(i)*dx
L = v*f*dx
\end{code}
where \texttt{*dx} signifies integration over the domain $\Omega$, and 
the finite element space is constructed using \fiat{}. 
\dolfin{} is not communicating directly with \fiat{}, but only through 
\ffc{} in the definition of the variational form in the \texttt{.form} file.  

Compiling the file with 
\begin{code}
# ffc Poisson.form
\end{code}
generates a file \texttt{Poisson.h}, containing classes for 
the bilinear form $a(\cdot,\cdot)$ and the linear form $L(\cdot)$, 
and classes for the finite element spaces $V_h$ and $\hat V_h$. 

\section{Assemble matrices and vectors}

The class \texttt{FEM} automates the assembly algorithm, constructing a linear 
system of equations from a given PDE, 
given in the form of a variational problem (\ref{pde:poisson:weak}), 
with a bilinear form $a(\cdot,\cdot)$ and a linear form $L(\cdot)$. 

The classes \texttt{BilinearForm} and \texttt{LinearForm} are automatically 
generated by \ffc{}, and to assemble the corresponding matrix and vector for 
the Poisson problem (\ref{pde:poisson:weak}) with source term $f$, we write:  
\begin{code}
Poisson::BilinearForm a;
Poisson::LinearForm L(f);

Mesh mesh; 
Mat A;
Vec b;

FEM::assemble(a,L,A,b,mesh);
\end{code}

In the \texttt{assemble()} function the element matrices and vectors are 
computed by calling the function \texttt{eval()} in the classes 
\texttt{Bilinearform} and \texttt{Linearform}. 
The \texttt{eval()} functions at a certain element in the assembly algorithm 
take as argument an \texttt{AffineMap} object, 
describing the mapping from the reference element to the actual element, 
by computing the jacobian $J$ of the mapping (also $J^{-1}$ and $det(J)$ 
are computed).  

\section{Specifying boundary conditions and data}

The boundary conditions are specified by defining a new subclass 
of the class \texttt{BoundaryCondition}, 
which we here will name \texttt{MyBC}: 
\begin{code}
  class MyBC : public BoundaryCondition
  \{
    const BoundaryValue operator() (const Point& p)
    \{
      BoundaryValue value;
      if ( std::abs(p.x - 0.0) < DOLFIN_EPS ) value = 0.0;
      if ( std::abs(p.x - 1.0) < DOLFIN_EPS ) value = 0.0;
      if ( std::abs(p.y - 0.0) < DOLFIN_EPS ) value = 0.0;
      if ( std::abs(p.y - 1.0) < DOLFIN_EPS ) value = 0.0;
      if ( std::abs(p.z - 0.0) < DOLFIN_EPS ) value = 0.0;
      if ( std::abs(p.z - 1.0) < DOLFIN_EPS ) value = 0.0;
        return value;
    \}
  \};
\end{code}
where we have assumed homogeneous Dirichlet boundary conditions for the 
unit cube. 
We only need to specify the boundary condition explicitly on the
Dirichlet boundary. On the remaining part of the boundary, \dolfin{}
assumes homogeneous Neumann boundary conditions by default.

The boundary condition is then imposed as an argument for 
the \texttt{assemble()} function. 
\begin{code}
MyBC bc; 
FEM::assemble(a,L,A,b,mesh,bc);
\end{code}

There is currently no easy way to impose non-homogeneous
Neumann boundary conditions or other combinations of boundary
conditions. This will be added to a future release of \dolfin{}.

The right-hand side $f$ of (\ref{pde:poisson:strong}) is similarly 
specified by defining a new subclass of \texttt{Function}, which we
here will name \texttt{MyFunction}, and overloading the evaluation
operator: 
\begin{code}
  class MyFunction : public Function
  \{
    real operator() (const Point& p) const
    \{
      return p.x*p.z*sin(p.y);
    \}
  \};
\end{code}
with the source $f(x, y, z) = x z \sin(y)$. 

\section{Computation of Element matrices and vectors} 

divide element matrix into geometry tensor and integration 
over reference element FErari

precomputation of integrals, quadrature, tensorrepresentation factored out, \ffc{} 

\section{Initial value problems}

semidiscretization, space-time FEM, 

% Insert note that constants are passed into forms as references
