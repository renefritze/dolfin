\chapter{Partial differential equations}


\section{Boundary value problems}

As a prototype of a boundary value problem in $\Bbb{R}^d$ we consider the 
scalar Poisson equation with homogeneous Dirichlet boundary conditions 
\begin{eqnarray}
-\Delta u(x)&=&f(x) \quad x\in \Omega \subset \Bbb{R}^d \label{pde:poisson:strong} \\
u(x)&=&0 \quad x\in \partial \Omega. \nonumber  
\end{eqnarray}

\section{Variational formulation}

A variational formulation of (\ref{pde:poisson:strong}) take the form: 
find $u\in V$ such that  
\begin{equation}\label{pde:poisson:weak}
a(u,v)=L(v) \quad \forall v\in V, 
\end{equation}
where $a(\cdot,\cdot):V\times V\rightarrow \Bbb{R}$ is a bilinear form 
on $V$ defined by 
\begin{equation}
a(u,v)=\int_{\Omega} \nabla u \cdot \nabla v ~dx 
=\int_{\Omega} \frac{\partial u}{\partial x_i} \frac{\partial v}{\partial x_i} ~ dx,  
\end{equation}
where we employ tensor notation so that the double index $i$ means summation from $i=1,...,d$, 
and $L(\cdot):V\rightarrow \Bbb{R}$ is a linear form on $V$ defined by 
\begin{equation}
L(v)=\int_{\Omega} f v ~dx.  
\end{equation}
$V=H^1_0(\Omega)$ is the standard Sobolev space of square integrable 
functions with also their first derivatives square integrable (in the Lebesgue sense), 
with the functions being zero on the boundary (in the sense of traces).   

The Finite Element Method FEM for (\ref{pde:poisson:weak}) is now: 
find $U\in V_h$ such that  
\begin{equation}\label{pde:poisson:fem}
a(U,v)=L(v) \quad \forall v\in V_h, 
\end{equation}
where $V_h\subset V$ is a finite dimensional subspace of dimension $N$. 
The finite element space $V_h$ is characterized by the set of basis 
functions $\{\varphi_i\}_{i=1}^N$, and thus the FEM method 
(\ref{pde:poisson:fem}) is specified by the variational form and 
the basis functions of $V_h$. 

\section{Compiling the variational form with FFC}

In \dolfin{} a PDE is defined in variational form using tensor notation 
in a \texttt{.form} file, which is compiled using FFC. 

At \texttt{/dolfin/src/demo/solvers/poisson/dolfin/} the following 
\texttt{poisson.form} file for (\ref{pde:poisson:fem}) can be found  
\begin{code}
# Copyright (C) 2005 Johan Hoffman and Anders Logg.
# Licensed under the GNU GPL Version 2.
#
# First added:  2005-04-04
# Last changed: 2005
#
# The bilinear form a(u,v) and linear form L(v) for
# Poisson's equation.
#
# Compile this form with FFC: ffc poisson.form.

element = FiniteElement("Lagrange", "tetrahedron", 1)

v = BasisFunction(element)
u = BasisFunction(element)
f = Function(element)

a = v.dx(i)*u.dx(i)*dx
L = v*f*dx
\end{code}

Compiling the file with 
\begin{code}
# ffc Poisson.form
\end{code}
generate a file \texttt{Poisson.h} containing the classes 
\texttt{BilinearForm} and \texttt{LinearForm}, and 
classes for the finite element used in the forms. 





Bilinear form, linear form, FFC

\section{The FEM class}

Automated assembly of a linear system from a given partial differential
equation, specified as a variational problem: Find u in V such that

    a(v, u) = L(v) for all v in V,

where a(.,.) is a given bilinear form and L(.) is a given linear form.

    /// Assemble bilinear form
    static void assemble(BilinearForm& a, Matrix& A, Mesh& mesh);

    /// Assemble linear form
    static void assemble(LinearForm& L, Vector& b, Mesh& mesh);

    /// Assemble bilinear and linear forms
    static void assemble(BilinearForm& a, LinearForm& L, 
			 Matrix& A, Vector& b, Mesh& mesh);
    
    /// Assemble bilinear and linear forms (including Dirichlet boundary conditions)
    static void assemble(BilinearForm& a, LinearForm& L, 
			 Matrix& A, Vector& b, Mesh& mesh,
			 BoundaryCondition& bc);
    
    /// Apply boundary conditions to matrix and vector 
    static void applyBC(Matrix& A, Vector& b, Mesh& mesh,
			const FiniteElement& element, BoundaryCondition& bc);
    
    /// Lump matrix
    static void lump(const Matrix& M, Vector& m);

    // Count the degrees of freedom
    static uint size(const Mesh& mesh, const FiniteElement& element);

    /// Display assembly data (useful for debugging)
    static void disp(const Mesh& mesh, const FiniteElement& element);
    
  private:

    // Apply boundary conditions on triangular mesh
    static void applyBC_2D(Matrix& A, Vector& b, Mesh& mesh,
			   const FiniteElement& element, BoundaryCondition& bc);

    // Apply boundary conditions on tetrahedral mesh
    static void applyBC_3D(Matrix& A, Vector& b, Mesh& mesh,
			   const FiniteElement& element, BoundaryCondition& bc);

    // Estimate the maximum number of nonzeros in each row
    static uint nzsize(const Mesh& mesh, const FiniteElement& element);

    // Check that dimension of the mesh matches the form
    static void checkdims(const BilinearForm& a, const Mesh& mesh);

    // Check that dimension of the mesh matches the form
    static void checkdims(const LinearForm& L, const Mesh& mesh);

    // Check number of nonzeros in each row
    static void checknz(const Matrix& A, uint nz);

\section{The FiniteElement class}


  /// This is the base class for finite elements automatically
  /// generated by the FEniCS Form Compiler FFC.

   /// Constructor
    FiniteElement();

    /// Destructor
    virtual ~FiniteElement();
    
    /// Return dimension of the finite element space
    virtual unsigned int spacedim() const = 0;

    /// Return dimension of the underlying shape
    virtual unsigned int shapedim() const = 0;

    /// Return vector dimension of the finite element space
    virtual unsigned int tensordim(unsigned int i) const = 0;

    /// Return vector dimension of the finite element space
    virtual unsigned int rank() const = 0;
    
    /// Compute map from local to global degrees of freedom
    virtual void dofmap(int dofs[], const Cell& cell, const Mesh& mesh) const = 0;

    /// Compute map from local to global coordinates
    virtual void pointmap(Point points[], uint components[], const AffineMap& map) const = 0;

    // FIXME: Make this abstract when working

    /// Compute map from (vertex, component) to function value
    virtual void vertexeval(real values[], unsigned int vertex, const Vector& x, const Mesh& mesh) const {}

    /// Display finite element data
    void disp() const;

\section{The PDE class}

A PDE represents a (linearized) partial differential equation,
given by a variation problem of the form: Find u in V such that

    a(u,v) = L(v) for all v in V,

where a(.,.) is a given bilinear form and L(.) is a given linear form.

    /// Constructor
    PDE();

    /// Constructor
    PDE(BilinearForm& a, LinearForm& L);

    /// Destructor
    ~PDE();

    /// Return the bilinear form a(.,.)
    BilinearForm& a();

    /// Return the linear form L(.,.)
    LinearForm& L();

  protected:

    BilinearForm* bilinear;
    LinearForm* linear;



\section{The Form class}

    /// Constructor
    Form(uint num_functions);

    /// Destructor
    virtual ~Form();

    /// Update map to current cell
    void update(const AffineMap& map);

    /// Friends
    friend class FEM;

  protected:

    // Update coefficients
    void updateCoefficients(const AffineMap& map);

    // Add function
    void add(Function& function, const FiniteElement* element);

    // List of finite elements for functions (coefficients)
    Array<const FiniteElement*> elements;

    // List of functions (coefficients)
    Array<Function*> functions;
    
    // Coefficients of functions projected to current element
    real** c;

    // Number of functions
    uint num_functions;



\section{The BilinearForm class}

BilinearForm represents a bilinear form a(v, u) with arguments v
and u basis functions of the finite element space defined by a
pair of finite elements (test and trial).

    /// Constructor
    BilinearForm(uint num_functions = 0);
    
    /// Destructor
    virtual ~BilinearForm();
    
    /// Compute element matrix (interior contribution)
    virtual void eval(real block[], const AffineMap& map) const;
    
    /// Compute element matrix (boundary contribution)
    virtual void eval(real block[], const AffineMap& map, uint segment) const;

    /// Return finite element defining the test space
    const FiniteElement& test() const;

    /// Return finite element defining the trial space
    const FiniteElement& trial() const;

  protected:

    // Finite element defining the test space
    FiniteElement* _test;

    // Finite element defining the trial space
    FiniteElement* _trial;
  

\section{The LinearForm class}

LinearForm represents a linear form L(v) with argument v (the
test function) a basis function of the finite element space
defined by a finite element.

    /// Constructor
    LinearForm(uint num_functions = 0);
    
    /// Destructor
    virtual ~LinearForm();

    /// Compute element vector (interior contribution)
    virtual void eval(real block[], const AffineMap& map) const;

    /// Compute element vector (boundary contribution)
    virtual void eval(real block[], const AffineMap& map, uint segment) const;

    /// Return finite element defining the test space
    const FiniteElement& test() const;

  protected:

    // Finite element defining the test space
    FiniteElement* _test;

\section{Element matrices and vectors} 

divide element matrix into geometry tensor and integration 
over reference element FErari

precomputation of integrals, quadrature, tensorrepresentation factored out, FFC 





\section{Boundary conditions}

\section{Finite elements}

Finite Element by Ciarlet, FIAT 

\section{Assembly}

dofs, vector dofs, 

\section{Functionals}

postprocess FFC 


\section{Initial value problems}

semidiscretization, space-time FEM, 


\fixme{Variational formulation, examplify with Poisson, FFC, finite elements, FIAT, assembly, functionals}

\dolfin{}

% Insert note that constants are passed into forms as references
