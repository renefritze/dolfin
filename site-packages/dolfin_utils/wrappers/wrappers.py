"Templates for generating DOLFIN wrappers"

__author__ = "Martin Alnes (martinal@simula.no) and Anders Logg (logg@simula.no)"
__date__ = "2008-11-06 -- 2008-12-12"
__copyright__ = "Copyright (C) 2008 Martin Alnes"
__license__  = "GNU GPL version 3 or any later version"

import sys, re
import ufl

from functionspace import generate_functionspace_class
from coefficient import generate_coefficient_class
from form import generate_form_class

def strip_chars(s):
    r = re.compile("([(),. -\"']+)")
    s = r.subn("_", s)
    s = s[0].strip("_")
    return s

stl_includes = """
// Standard library includes
#include <string>
"""

dolfin_includes = """
// DOLFIN includes
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/fem/Form.h>
#include <dolfin/function/FunctionSpace.h>
#include <dolfin/function/Function.h>
#include <dolfin/function/Coefficient.h>
"""

class UFCFormNames:
    "Encapsulation of the names related to a generated UFC form."
    def __init__(self, name, coefficient_names, ufc_form_classname, ufc_finite_element_classnames, ufc_dof_map_classnames):
        """Arguments:
        
        @param name:
            Name of form (e.g. 'a', 'L', 'M').
        @param coefficient_names:
            List of names of form coefficients (e.g. 'f', 'g').
        @param ufc_form_classname:
            Name of ufc::form subclass.
        @param ufc_finite_element_classnames:
            List of names of ufc::finite_element subclasses (length rank + num_coefficients).
        @param ufc_dof_map_classnames:
            List of names of ufc::dof_map subclasses (length rank + num_coefficients).
        """
        assert len(coefficient_names) <= len(ufc_dof_map_classnames)
        assert len(ufc_finite_element_classnames) == len(ufc_dof_map_classnames)
        self.num_coefficients = len(coefficient_names)
        self.rank = len(ufc_finite_element_classnames) - self.num_coefficients
        self.name                          = name
        self.coefficient_names             = coefficient_names
        self.ufc_form_classname            = ufc_form_classname
        self.ufc_finite_element_classnames = ufc_finite_element_classnames
        self.ufc_dof_map_classnames        = ufc_dof_map_classnames

    def __str__(self):
        s = "UFCFormNames instance:\n"
        s += "rank:                      %d\n" % self.rank
        s += "num_coefficients:          %d\n" % self.num_coefficients
        s += "name:                      %s\n" % self.name
        s += "coefficient_names:         %s\n" % str(self.coefficient_names)
        s += "ufc_form_classname:        %s\n" % str(self.ufc_form_classname)
        s += "finite_element_classnames: %s\n" % str(self.ufc_finite_element_classnames)
        s += "ufc_dof_map_classnames:    %s\n" % str(self.ufc_dof_map_classnames)
        return s
        

def generate_dolfin_classes(prefix, formnames):
    """Generate code for all dolfin wrapper classes.
    
    @param prefix:
        String, prefix for all form names.
    @param formnames:
        List of UFCFormNames instances for each form to wrap.
    """
    # Collection of code blocks
    blocks = []
    
    # Check if naming forms by rank (BilinearForm etc) makes sense
    name_forms_by_rank = True
    ranks = [fd.rank for fd in formnames]
    for r in range(min(ranks), max(ranks)+1):
        if ranks.count(r) > 1:
            name_forms_by_rank = False
    
    class_typedefs = []
    
    # Handle each form
    for fd in formnames:
        
        # Form class name
        classname = "%sForm_%s" % (prefix, fd.name)
        if name_forms_by_rank:
            suffix = {0: "Functional", 1: "LinearForm", 2:"BilinearForm", 3:"TrilinearForm"}[fd.rank]
            class_typedefs.append((classname, "%s%s" % (prefix, suffix)))
        
        # Class names of generated classes, named by form and numbering
        functionspace_classnames    = ["%s_FunctionSpace%d"    % (classname, i) for i in range(fd.rank + fd.num_coefficients)]
        coefficient_classnames      = ["%s_Coefficient%d"      % (classname, i) for i in range(fd.num_coefficients)]
        
        # Class names for typedefs in class namespace
        coefficientspace_classnames = ["CoefficientSpace_%s" % n for n in fd.coefficient_names]
        basespace_classnames        = ["FunctionSpace%d"     % i for i in range(fd.rank)]
        if fd.rank == 1:
            basespace_classnames[0] = "TestSpace"
        if fd.rank == 2:
            basespace_classnames[0] = "TestSpace"
            basespace_classnames[1] = "TrialSpace"
        
        # Generate FunctionSpace subclasses
        for i in range(fd.rank + fd.num_coefficients):
            code = generate_functionspace_class(functionspace_classnames[i], fd.ufc_finite_element_classnames[i], fd.ufc_dof_map_classnames[i])
            blocks.append(code)
        
        # Generate Coefficient subclasses
        for i in range(fd.num_coefficients):
            code = generate_coefficient_class(coefficient_classnames[i], coefficientspace_classnames[i], i, fd.coefficient_names[i])
            blocks.append(code)
        
        # Generate Form subclass
        formclass = generate_form_class(classname, fd.ufc_form_classname,
            functionspace_classnames, basespace_classnames, coefficientspace_classnames,
            coefficient_classnames, fd.coefficient_names)
        blocks.append(formclass)
    
    # Add class typedefs for optional FooBilinearForm naming
    if class_typedefs:
        code = "// Class typedefs\n"
        code += "\n".join("typedef %s %s;" % (a,b) for (a,b) in class_typedefs)
        blocks.append(code)
    
    # Join blocks together
    code = "\n\n".join(blocks)
    return code

def generate_dolfin_code(prefix, header, formnames):
    """Generate complete dolfin wrapper code with given generated names.

    @param prefix:
        String, prefix for all form names.
    @param header:
        Code that will be inserted at the top of the file.
    @param formnames:
        List of UFCFormNames instances for each form to wrap.
    """
    guardname = ("%s_h" % prefix).upper()
    preguard = "#ifndef %s\n#define %s\n" % (guardname, guardname)
    postguard = "#endif\n"
    dolfin_classes = generate_dolfin_classes(prefix, formnames)
    code = "\n".join((preguard, header, stl_includes, dolfin_includes, "\nnamespace dolfin\n{\n", dolfin_classes, "\n} // namespace dolfin", postguard))
    return code

# ------------------------------------------------------ Test code below this line

# TODO: We can add typedefs in SFC to avoid this remapping of names, or better FFC can start reusing elements to reduce its code size.

# TODO: This code should be in SFC
def _generate_dolfin_code_sfc_way(formdatas, header, prefix, fcprefix):
    "Example dolfin code wrapper code generation."
    
    # Define generated element classnames, unique for each unique element
    _unique_elements = sorted(set(e for fd in formdatas for e in fd.unique_elements))
    unique_ufc_finite_element_classnames = dict((e, "%s_finite_element_%s" % (fcprefix, strip_chars(repr(e)))) for e in _unique_elements)
    unique_ufc_dof_map_classnames        = dict((e, "%s_dof_map_%s"        % (fcprefix, strip_chars(repr(e)))) for e in _unique_elements)
    
    # Build UFCFormNames instances
    formnames = []
    for fd in formdatas:
        # Define generated form classname
        ufc_form_classname = "%s_%s_form_%s" % (fcprefix, prefix, fd.name)
        
        # Create ordered lists of element classnames
        ufc_finite_element_classnames = [unique_ufc_finite_element_classnames[e] for e in fd.elements]
        ufc_dof_map_classnames        = [unique_ufc_dof_map_classnames[e]        for e in fd.elements]
        
        formnames.append(UFCFormNames(fd.name, fd.coefficient_names, ufc_form_classname, ufc_finite_element_classnames, ufc_dof_map_classnames))
    
    return generate_dolfin_code(prefix, header, formnames)

# TODO: This code should be in FFC
def _generate_dolfin_code_ffc_way(formdatas, header, prefix, fcprefix):
    "Example dolfin code wrapper code generation."
    # NB! This code was written assuming UFL FormData instances

    # Build UFCFormNames instances
    formnames = []
    for fd in formdatas:
        # Define generated form classnames
        ufc_form_classname = "%s_%s_form_%s" % (fcprefix, prefix, fd.name)
        
        # Create ordered lists of element classnames
        ufc_finite_element_classnames = ["%s_ufc_finite_element_%d" % (ufc_form_classname, i) for i in range(fd.rank + fd.num_coefficients)]
        ufc_dof_map_classnames        = ["%s_ufc_dof_map_%d"        % (ufc_form_classname, i) for i in range(fd.rank + fd.num_coefficients)]
        
        formnames.append(UFCFormNames(fd.name, fd.coefficient_names, ufc_form_classname, ufc_finite_element_classnames, ufc_dof_map_classnames))
    
    return generate_dolfin_code(prefix, header, formnames)

def _copen(filename):
    "Open a file or the console for writing."
    return open(filename, "w") if filename else sys.stdout

def _write_dolfin_code(uflfilename, hfilename, prefix, fcprefix):
    "Example code using dolfin code wrapper generators on forms from a UFL form file."
    # Load UFL forms
    formdatas = ufl.algorithms.load_forms(uflfilename)
    
    header = "// Example of generated dolfin wrappers"
    
    # Generate dolfin wrapper code
    code = _generate_dolfin_code_sfc_way(formdatas, header, prefix, fcprefix)
    code = _generate_dolfin_code_ffc_way(formdatas, header, prefix, fcprefix)
    
    # Write to file or console
    f = _copen(hfilename)
    f.write(code)
    f.write("\n")
    if hfilename: f.close()

if __name__ == "__main__":
    uflfilename = "hyperelasticity1D.ufl"
    hfilename = None #"Hyperelasticity1D.h"
    prefix = "HypEl1D"
    fcprefix = "sfc"
    _write_dolfin_code(uflfilename, hfilename, prefix, fcprefix)

