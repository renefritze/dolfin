#!/usr/bin/env python
"Template for generating a CoefficientSet class. Not yet functional."

__author__ = "Martin Alnes (martinal@simula.no)"
__date__ = "2009-03-16 -- 2009-03-16"
__copyright__ = "Copyright (C) 2009 Martin Alnes"
__license__  = "GNU GPL version 3 or any later version"

# Template code for coefficient reference class # TODO: This can probably be moved into DOLFIN, along with a base class for CoefficientSet
coefficient_reference_code = """class CoefficientReference
{
public:
  
  CoefficientReference(const std::string & name):
    _name(name)
  {}
  
  ~CoefficientReference()
  {}

  CoefficientReference& operator=(dolfin::Function & f)
  {
    _function_pointer = dolfin::reference_to_no_delete_pointer(f);
    return *this;
  }
  
  CoefficientReference& operator=(const boost::shared_ptr<dolfin::Function> f)
  {
    _function_pointer = f;
    return *this;
  }

  std::string name() const
  {
    return _name;
  }

  dolfin::Function & function() const
  {
    return *_function_pointer;
  }

  boost::shared_ptr<dolfin::Function> function_pointer() const
  {
    return _function_pointer;
  }

private:

  boost::shared_ptr<dolfin::Function> _function_pointer;
  std::string _name;

};"""


# Template code for coefficient reference class # TODO: Remove when sure we don't need this, fixed class CoefficientReference should be enough
coefficient_reference_template = """class %(classname)s
{
public:
  %(classname)s()
  {}
  
  ~%(classname)s()
  {}

  %(classname)s& operator=(dolfin::Function & f)
  {
    _function_pointer = dolfin::reference_to_no_delete_pointer(f);
    return *this;
  }
  
  %(classname)s& operator=(const boost::shared_ptr<dolfin::Function> f)
  {
    _function_pointer = f;
    return *this;
  }

  std::string name() const
  {
    return "%(name)s";
  }

  dolfin::Function & function() const
  {
    return *_function_pointer;
  }

  boost::shared_ptr<dolfin::Function> function_pointer() const
  {
    return _function_pointer;
  }

private:

  boost::shared_ptr<dolfin::Function> _function_pointer;

};"""

def generate_coefficient_reference_class(classname, name):
    print "WARNING: generate_coefficient_reference_class is deprecated."
    args = { "classname": classname,
             "name": name }
    return coefficient_reference_template % args 

# Template code for coefficient set class
coefficient_set_template = """class %(classname)s
{
public:
  %(classname)s()%(initializerlist)s
  {}
  
  ~%(classname)s()
  {}

  dolfin::uint num_coefficients() const
  {
    return %(num_coefficients)d;
  }

  std::string name(dolfin::uint i) const
  {
    switch(i)
    {
%(name_cases)s
    default:
        throw std::runtime_error("Invalid coefficient number.");
    }
  }

  void disp() const
  {
    for(dolfin::uint i=0; i<num_coefficients(); ++i)
    {
        dolfin::cout << "Coefficient " << i << ": \\t" << name(i) << dolfin::endl;
    }
  }

%(body)s
};"""

def generate_coefficient_set_class(classname, coefficient_names):
    num_coefficients = len(coefficient_names)
    name_cases = "\n".join('    case %d: return "%s";' % (i, name) for (i, name) in enumerate(coefficient_names))
    body = "\n".join('  CoefficientReference %s;' % name for name in coefficient_names)
    if num_coefficients:
        initializerlist = ":\n    " + ", ".join('%s("%s")' % (name, name) for name in coefficient_names)
    else:
        initializerlist = ""

    args = { "classname": classname,
             "initializerlist": initializerlist,
             "num_coefficients": num_coefficients,
             "name_cases": name_cases,
             "body": body }
    return coefficient_set_template % args 

if __name__ == "__main__":
    coefficient_names = ["f", "g"]
    for name in coefficient_names:
        coefficient_reference_classname = "CoefficientReference_%s" % name
        print generate_coefficient_reference_class(coefficient_reference_classname, name)

    coefficient_set_classname = "MyCoefficientSet"
    print generate_coefficient_set_class(coefficient_set_classname, coefficient_names)

