"""Module for converting the  Abaqus mesh format."""

# Copyright (C) 2012 Arve Knudsen
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.

import re

def convert(ifilename, handler):
    """ Convert from Abaqus.

    The Abaqus format first defines a node block, then there should be a number
    of elements containing these nodes.
    """
    params = False
    ifile = file(ifilename, "rb")
    handler.set_mesh_type("tetrahedron", 3)

    # Dictionary of nodes
    nodes = {}

    # Dictionary of elements
    elems = {}

    # ???
    eid2elset = {}

    # ???
    material2elsetids = {}

    # ???
    materials = []

    # Prepare some regular expressions for matching
    re_sect  = re.compile(r"\*([^,]+)(?:,(.*))?")
    re_node  = re.compile(r"(\d+),\s*(.+),\s*(.+),\s*(.+)")
    re_tetra = re.compile(r"(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+)")

    # ???
    section = None

    # Loop over lines of file
    for lineno, l in enumerate(ifile):

        # Strip white space and make lower case
        l = l.strip().lower()

        # Get section heading (if any)
        m = re_sect.match(l)

        # Have a section
        if m is not None:

            # Split section name and section parameters
            section, parameters_str = m.groups()

            # Create list of section parameters
            params_spec = ([s.strip() for s in parameters_str.split(",")] if parameters_str else [])

            if section == "element":
                pnames = ("type", "elset")
                parameters = _read_params(params_spec, pnames, lineno, handler)
                if "type" not in parameters:
                   handler.error("Element on line %d doesn't declare TYPE" %
                            (lineno,))
                tp, elset = parameters["type"], parameters.get("elset")
                if tp not in ("c3d4", "dc3d4"):
                    handler.warn("Unsupported element type '%s' on line %d" % (tp, lineno))
                    supported_elem = False
                else:
                    supported_elem = True
            elif section == "solid section":
                pnames = ("material", "elset")
                parameters = _read_params(params_spec, pnames, lineno, handler)
                for pname in pnames:
                    if pname not in parameters:
                        handler.error("Solid section on line %d doesn't declare %s" % (lineno, pname.upper()))
                matname = parameters["material"]
                material2elsetids.setdefault(matname, []).append(parameters["elset"])
            elif section == "material":
                name = _read_params(params_spec, ["name"], lineno, handler)["name"]
                materials.append(name)

            # We've read the section's heading, continue to next line
            continue

        # Read nodes
        if section == "node":

            # Read node definition
            m = re_node.match(l)
            if m is None:
                handler.warn("Node on line %d is on unsupported format" % (lineno,))
                continue

            # Read node id and coordinates
            idx, c0, c1, c2 = m.groups()

            # Convert coords into floats
            try: coords = [float(c) for c in (c0, c1, c2)]
            except ValueError:
                handler.warn("Node on line %d contains non-numeric coordinates" % (lineno,))
                continue

            # Add node to dictionary
            nodes[int(idx) - 1] = coords

        elif section == "element":
            if not supported_elem:
                continue
            m = re_tetra.match(l)
            if m is None:
                handler.error("Node on line %d badly specified (expected 3 "
                              "coordinates)" % (lineno,))
            idx, n0, n1, n2, n3 = [int(x) for x in m.groups()]
            elems[idx - 1] = (tp, n0 - 1, n1 - 1, n2 - 1, n3 - 1)
            eid2elset.setdefault(elset, set()).add(idx)

    ifile.close()

    # Note that vertices/cells must be consecutively numbered, which
    # isn't necessarily the case in Abaqus. Therefore we enumerate and
    # translate original IDs to sequence indexes if gaps are present.

    # Check for gaps in vertex numbering
    node_ids = nodes.keys()
    if len(node_ids) > 0:
        vertex_gap = (min(node_ids) != 0 or max(node_ids) != len(node_ids) - 1)
    else:
        vertex_gap = True

    # Check for gaps in cell numbering
    elemids = elems.keys()
    if len(elemids) > 0:
        cell_gap = (min(elemids) != 0 or max(elemids) != len(elemids) - 1)
    else:
        cell_gap = True

    # Write vertices to XML file
    handler.start_vertices(len(nodes))
    if not vertex_gap:

        for v_id, v_coords in nodes.items():
            handler.add_vertex(v_id, v_coords)

    else:

        for idx, (v_id, v_coords) in enumerate(nodes.items()):
            handler.add_vertex(idx, v_coords)

    handler.end_vertices()

    # Write cells to XML file
    handler.start_cells(len(elems))
    if not vertex_gap and not cell_gap:

        for c_index, c_data in elems.items():
            for v_id in c_data[1:]:
                if not (0 <= v_id < len(nodes)):
                    handler.error("Element %s references non-existent node %s" % (c_index, v_id))
            handler.add_cell(c_index, c_data[1:])

    elif not vertex_gap and cell_gap:

        for idx, (c_index, c_data) in enumerate(elems.items()):
            for v_id in c_data[1:]:
                if not (0 <= v_id < len(nodes)):
                    handler.error("Element %s references non-existent node %s" % (c_index, v_id))
            handler.add_cell(idx, c_data[1:])

    else:

        for idx, (c_id, c_data) in enumerate(elems.items()):
            c_nodes = []
            for v_id in c_data[1:]:
                print "--", v_id
                try: c_nodes.append(node_ids.index(v_id))
                except ValueError:
                    handler.error("Element %s references non-existent node %s" % (c_id, v_id))
            handler.add_cell(idx, c_nodes)

    handler.end_cells()

    # Define the material function for the cells
    num_entities = 0
    for material_name, elsetids in material2elsetids.items():
        if material_name not in materials:
            handler.error("Unknown material %s referred to for element sets %s" %
                    (material_name, ", ".join(elsetids)))
        num_entities += len(elsetids)
    handler.start_meshfunction("material", 3, num_entities)

    # Each material is associated with a number of element sets
    for i, material_name in enumerate(materials):
        try: elsetids = material2elsetids[material_name]
        except KeyError:
            # No elements for this material
            continue
        # For each element set associated with this material
        elsets = []
        for eid in elsetids:
            try:
                elsets.append(eid2elset[eid])
            except KeyError:
                handler.error("Material '%s' is assigned to undefined element "
                        "set '%s'" % (material_name, eid))
        for elset in elsets:
            for elemid in elset:
                handler.add_entity_meshfunction(elemids.index(elemid) - 1, i)

    handler.end_meshfunction()


def _read_params(params_spec, pnames, lineno, handler):
    params = {}
    for p in params_spec:
        m = re.match(r"(.+)=(.+)", p)
        if m is not None:
            pname, val = m.groups()
        else:
            handler.warn("Invalid parameter syntax on line %d: %s" % (lineno, p))
            continue
        for pn in pnames:
            if pn == pname:
                params[pn] = val
                break

    return params
