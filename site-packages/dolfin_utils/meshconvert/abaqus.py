"""Module for converting the  Abaqus mesh format."""

# Copyright (C) 2012 Arve Knudsen
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.

import re

def convert(ifilename, handler):
    """ Convert from Abaqus.

    The Abaqus format first defines a node block, then there should be a number
    of elements containing these nodes.
    """
    params = False
    ifile = file(ifilename, "rb")
    handler.set_mesh_type("tetrahedron", 3)

    # Dictionary of nodes
    nodes = {}

    # Dictionary of elements
    elems = {}

    # ???
    eid2elset = {}

    # ???
    material2elsetids = {}

    # ???
    materials = []

    # Prepare some regular expressions for matching
    re_sect  = re.compile(r"\*([^,]+)(?:,(.*))?")
    re_node  = re.compile(r"(\d+),\s*(.+),\s*(.+),\s*(.+)")
    re_tetra = re.compile(r"(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+)")

    # ???
    section = None

    # Loop over lines of file
    for lineno, l in enumerate(ifile):

        # Strip white space and make lower case
        l = l.strip().lower()

        # Get section heading (if any)
        m = re_sect.match(l)

        # Have a section
        if m is not None:

            # Split section name and section parameters
            section, parameters_str = m.groups()

            # Create list of section parameters
            params_spec = ([s.strip() for s in parameters_str.split(",")] if parameters_str else [])

            if section == "element":
                pnames = ("type", "elset")
                parameters = _read_params(params_spec, pnames, lineno)
                if "type" not in parameters:
                   handler.error("Element on line %d doesn't declare TYPE" %
                            (lineno,))
                tp, elset = parameters["type"], parameters.get("elset")
                if tp not in ("c3d4", "dc3d4"):
                    handler.warn("Unsupported element type '%s' on line %d" % (tp, lineno))
                    supported_elem = False
                else:
                    supported_elem = True
            elif section == "solid section":
                pnames = ("material", "elset")
                parameters = _read_params(params_spec, pnames, lineno)
                for pname in pnames:
                    if pname not in parameters:
                       handler.error("Solid section on line %d doesn't "
                                "declare %s" % (lineno, pname.upper()))
                matname = parameters["material"]
                material2elsetids.setdefault(matname, []).append(params["elset"])
            elif section == "material":
                name = _read_params(params_spec, ["name"], lineno)["name"]
                materials.append(name)

            # We've read the section's heading, continue to next line
            continue

        # Read nodes
        if section == "node":

            # Read node definition
            m = re_node.match(l)
            if m is None:
                handler.warn("Node on line %d is on unsupported format" % (lineno,))
                continue

            # Read node id and coordinates
            idx, c0, c1, c2 = m.groups()

            # Convert coords into floats
            try: coords = [float(c) for c in (c0, c1, c2)]
            except ValueError:
                handler.warn("Node on line %d contains non-numeric coordinates" % (lineno,))
                continue

            # Add node to dictionary
            nodes[int(idx) - 1] = coords

        elif section == "element":
            if not supported_elem:
                continue
            m = re_tetra.match(l)
            if m is None:
                handler.error("Node on line %d badly specified (expected 3 "
                              "coordinates)" % (lineno,))
            idx, n0, n1, n2, n3 = [int(x) for x in m.groups()]
            elems[idx - 1] = (tp, n0 - 1, n1 - 1, n2 - 1, n3 - 1)
            eid2elset.setdefault(elset, set()).add(idx)

    ifile.close()

    # Note that vertices/cells must be consecutively numbered, which
    # isn't necessarily the case in Abaqus. Therefore we enumerate and
    # translate original IDs to sequence indexes.

    # Check for gaps in vertex numbers
    node_ids = nodes.keys()
    vertex_gap = (min(node_ids) != 0 or max(node_ids) != len(node_ids) - 1)

    # Check for gaps in cell numbers
    elemids = elems.keys()
    cell_gap = (min(elemids) != 0 or max(elemids) != len(elemids) - 1)

    # Write vertices to XML file
    handler.start_vertices(len(nodes))
    for idx, (nid, node_coords) in enumerate(nodes.items()):
        handler.add_vertex(idx, node_coords)

    handler.end_vertices()

    # Write cells to XML file
    handler.start_cells(len(elems))
    if not vertex_gap:
        # Loop of cells and write vertex indices to file
        for idx, (cell_index, cell_data) in enumerate(elems.items()):
            handler.add_cell(idx, cell_data[1:])
    else:
        # Loop over cells and re-map vertex numbers
        for idx, (eid, elem) in enumerate(elems.items()):
            tp = elem[0]
            elemnodes = []
            for nid in elem[1:]:
                try: elemnodes.append(node_ids.index(nid))
                except ValueError:
                    handler.error("Element %s references non-existent node %s" % (eid, nid))
            handler.add_cell(idx, elemnodes)

    handler.end_cells()

    # Define the material function for the cells
    num_entities = 0
    for matname, elsetids in material2elsetids.items():
        if matname not in materials:
            handler.error("Unknown material %s referred to for element sets %s" %
                    (matname, ", ".join(elsetids)))
        num_entities += len(elsetids)
    handler.start_meshfunction("material", 3, num_entities)

    # Each material is associated with a number of element sets
    for i, matname in enumerate(materials):
        try: elsetids = material2elsetids[matname]
        except KeyError:
            # No elements for this material
            continue
        # For each element set associated with this material
        elsets = []
        for eid in elsetids:
            try: elsets.append(eid2elset[eid])
            except KeyError:
                handler.error("Material '%s' is assigned to undefined element "
                        "set '%s'" % (matname, eid))
        for elset in elsets:
            for elemid in elset:
                handler.add_entity_meshfunction(elemids.index(elemid), i)

    handler.end_meshfunction()


def _read_params(params_spec, pnames, lineno):
    params = {}
    for p in params_spec:
        m = re.match(r"(.+)=(.+)", p)
        if m is not None:
            pname, val = m.groups()
        else:
            handler.warn("Invalid parameter syntax on line %d: %s" % (lineno, p))
            continue
        for pn in pnames:
            if pn == pname:
                params[pn] = val
                break

    return params
