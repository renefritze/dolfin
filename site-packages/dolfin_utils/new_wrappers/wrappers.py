__author__ = "Marie E. Rognes (meg@simula.no)"
__copyright__ = "Copyright (C) 2011 Marie Rognes"
__license__  = "GNU LGPL version 3 or any later version"

# Based on original implementation by Martin Alnes and Anders Logg

# Last changed: 2011-01-19

import includes as incl
from functionspace import *
from form import generate_form

parameters = {"use_common_coefficient_names": True}

def generate_dolfin_code(prefix, header, forms,
                         common_function_space=False, add_guards=False):
    """Generate complete dolfin wrapper code with given generated names.

    @param prefix:
        String, prefix for all form names.
    @param header:
        Code that will be inserted at the top of the file.
    @param form_names:
        List of UFCFormNames instances for each form to wrap.
    @param common_function_space:
        True if common function space, otherwise None.
    @param add_guards:
        True iff guards (ifdefs) should be added
    """

    # Generate dolfin namespace
    namespace = generate_dolfin_namespace(prefix, forms, common_function_space)

    # Collect pieces of code
    code = [incl.dolfin_tag, header, incl.stl_includes, incl.dolfin_includes,
            namespace]

    # Add ifdefs/endifs if specified
    if add_guards:
        guard_name = ("%s_h" % prefix).upper()
        preguard = "#ifndef %s\n#define %s\n" % (guard_name, guard_name)
        postguard = "\n#endif\n\n"
        code = [preguard] + code + [postguard]

    # Return code
    return "\n".join(code)

def generate_dolfin_namespace(prefix, forms, common_function_space):

    # Extract (common) coefficient spaces
    assert(parameters["use_common_coefficient_names"])
    spaces = extract_coefficient_spaces(forms)

    # Generate code for common coefficient spaces
    code = [generate_functionspace_class(*space) for space in spaces]

    # Generate code for forms
    code += [generate_form(form) for form in forms]

    # Generate namespace typedefs (Bilinear/Linear & Test/TrialFunctionSpace)
    code += [generate_namespace_typedefs(forms, common_function_space)]

    # Wrap code in namespace block
    code = "\nnamespace %s\n{\n\n%s\n}" % (prefix, "\n".join(code))

    # Return code
    return code

def generate_namespace_typedefs(forms, common_function_space):

    # Generate typedefs as (to, fro) pairs of strings
    pairs = []

    # Add typedef for BilinearForm is there is only one present
    bilinears = [form for form in forms if form.rank == 2]
    if len(bilinears) == 1:
        pairs += [("Form_%d" % bilinears[0].name, "BilinearForm")]

    # Add typedef for LinearForm is there is only one present
    linears = [form for form in forms if form.rank == 1]
    if len(linears) == 1:
        pairs += [("Form_%d" % linears[0].name, "LinearForm")]

    # Add typedef for FunctionSpace if term applies
    if common_function_space and any(form.rank for form in forms):
        pairs += [("Form_0::TestSpace", "FunctionSpace")]

    # Combine data to typedef code
    code = "\n".join("typedef %s %s;" % (to, fro) for (to, fro) in pairs)
    return "// Class typedefs\n" + code
