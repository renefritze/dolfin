__author__ = "Marie E. Rognes (meg@simula.no)"
__copyright__ = "Copyright (C) 2011 Marie Rognes"
__license__  = "GNU LGPL version 3 or any later version"

# Based on original implementation by Martin Alnes and Anders Logg

# Last changed: 2011-01-20

from includes import table
from functionspace import *

__all__ = ["generate_form"]

#-------------------------------------------------------------------------------
def generate_form(form, classname=None):

    # Allow not specifying classname, defaulting to Form_q. Muhaha.
    if classname is None:
        classname = "Form_%s" % form.name

    # Generate code for Form_x_FunctionSpace_y subclasses
    make = generate_functionspace_class
    blocks = [make("%s_FunctionSpace_%d" % (classname, i),
                   form.ufc_finite_element_classnames[i],
                   form.ufc_dof_map_classnames[i]) for i in range(form.rank)]

    # Add typedefs CoefficientSpace_z -> Form_x_FunctionSpace_y
    blocks += ["typedef CoefficientSpace_%s %s_FunctionSpace_%d;\n"
               % (form.coefficient_names[i], classname, form.rank + i)
               for i in range(form.num_coefficients)]

    # Generate Form subclass
    blocks += [generate_form_base(form, classname)]

    # Return code
    return "\n".join(blocks)
#-------------------------------------------------------------------------------
def generate_form_base(form, classname):

    # Generate constructors
    constructors = generate_form_constructors(form, classname)

    # Generate coefficient assignments
    (number, name) = generate_coefficient_mappers(form)

    # Generate typedefs for FunctionSpace subclasses for Coefficients
    typedefs = ["  // Typedefs", generate_typedefs(form, classname), ""]

    # Member variables for coefficients
    members = ["  dolfin::CoefficientAssigner %s;" % coefficient
               for coefficient in form.coefficient_names]

    # Group typedefs and members together for inserting into template
    additionals = "\n".join(typedefs + ["  // Coefficients"] + members)

    # Wrap functions in class body
    code = generate_form_class(classname, constructors, number, name,
                               additionals)

    # Return code
    return code
#-------------------------------------------------------------------------------
def generate_coefficient_mappers(form):

    # Write error if no coefficients
    if form.num_coefficients == 0:
        message = 'dolfin::error("No coefficients.");'
        num  = "\n    %s\n    return 0;" % message
        name = '\n    %s\n    return "unnamed";' % message
        return (num, name)

    # Otherwise create switch
    ifstr = "if "
    num = ""
    name = '    switch (i)\n    {\n'
    for i, coeff in enumerate(form.coefficient_names):
        num += '    %s(name == "%s")\n      return %d;\n' % (ifstr, coeff, i)
        name += '    case %d:\n      return "%s";\n' % (i, coeff)
        ifstr = 'else if '

    # Create final return
    message = 'dolfin::error("Invalid coefficient.");'
    num +=  "\n    %s\n    return 0;" % message
    name += '    }\n\n    %s\n    return "unnamed";' % message

    return (num, name)
#-------------------------------------------------------------------------------
def generate_form_constructors(form, classname):

    coeffs = ("referenced_coefficient", "shared_ptr_coefficient")
    spaces = ("referenced_space", "shared_ptr_space")

    # Treat functionals a little special
    if form.rank == 0:
        spaces = ("referenced_mesh", "shared_ptr_mesh")

    # Generate permutations of constructors
    constructors = []
    for space in spaces:
        constructors += [generate_constructor(form, classname, space)]
        if form.num_coefficients > 0:
            constructors += [generate_constructor(form, classname, space, coeff)
                             for coeff in coeffs]

    # Return joint constructor code
    return "\n\n".join(constructors)

#-------------------------------------------------------------------------------
def generate_constructor(form, classname, space_type, coefficient_type=None):

    # Extract correct declarations etc.
    (argument, assign) = table[space_type]

    # Construct list of arguments and function space assignments
    name = "V%d"
    if form.rank > 0:
        arguments = [argument % (name % i) for i in range(form.rank)]
        assignments = [assign % (i, name % i) for i in range(form.rank)]
    else:
        arguments = [argument]
        assignments = [assign]

    # Add coefficients to argument/assignment lists if type given
    if coefficient_type is not None:
        (argument, assign) = table[coefficient_type]
        arguments += [argument % name for name in form.coefficient_names]
        if form.rank > 0:
            assignments += [""] # FIXME: To match old generated code only
        assignments += [assign %(name, name) for name in form.coefficient_names]

    # Assign _ufc_form
    msg = "\n    _ufc_form = boost::shared_ptr<const ufc::form>(new %s());"
    # FIXME: To match old generated code only
    if form.rank == 0 and coefficient_type is None:
        msg = "    _ufc_form = boost::shared_ptr<const ufc::form>(new %s());"
    assignments += [msg % form.ufc_form_classname]

    # Initialize Coefficient objects with a reference to this Form
    initializers = ["%s(*this, %d)" % (name, number)
                    for (number, name) in enumerate(form.coefficient_names)]

    # Join lists together
    arguments = ", ".join(arguments)
    initializers = ", " + ", ".join(initializers) if initializers else ""
    body = "\n".join(assignments)

    # Wrap code into template
    args = {"classname": classname,
            "rank": form.rank,
            "num_coefficients": form.num_coefficients,
            "arguments": arguments,
            "initializers": initializers,
            "body": body}
    code = form_constructor_template % args
    return code
#-------------------------------------------------------------------------------
form_class_template = """\
class %(classname)s: public dolfin::Form
{
public:

%(constructors)s

  // Destructor
  ~%(classname)s()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
%(coefficient_number)s
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
%(coefficient_name)s
  }

%(members)s
};
"""
#-------------------------------------------------------------------------------
# Template code for Form constructor
form_constructor_template = """\
  // Constructor
  %(classname)s(%(arguments)s):
    dolfin::Form(%(rank)d, %(num_coefficients)d)%(initializers)s
  {
%(body)s
  }"""
#-------------------------------------------------------------------------------
def generate_form_class(classname, constructors, number, name, members):
    args = {"classname": classname,
            "constructors": constructors,
            "coefficient_number": number,
            "coefficient_name": name,
            "members": members}
    return form_class_template % args
#-------------------------------------------------------------------------------
