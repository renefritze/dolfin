"""Script to extract documentation from docstrings in *.h files in the DOLFIN
source tree."""

__author__ = "Anders Logg <logg@simula.no>"
__date__ = "2010-08-26"
__copyright__ = "Copyright (C) 2010 " + __author__
__license__  = "GNU GPL version 3 or any later version"

# Modified by Kristian B. Oelgaard, 2010.

# Last changed: 2010-09-14

import os

def extract_documentation(dolfin_dir, header, module):
    "Extract documentation for given header in given module"

    print "Extracting documentation for %s..." % header

    # List of classes with documentation
    classnames = []
    documentation = []

    # Class name and parent class name
    classname = None
    parent = None

    # Comment and signature
    comment = None
    signature = None

    # Indentation of signatures
    indent = 0

    # Iterate over each line
    f = open(os.path.join(dolfin_dir, "dolfin", module, header))
    for line in f:

        # Check for comment
        if "///" in line:

            # We may have either "///" and "/// "
            if "/// " in line:
                c = line.split("/// ")[1].rstrip()
            else:
                c = line.split("///")[1].rstrip()

            # Found start of new comment
            if comment is None:
                comment = c

            # Continuing comment on next line
            else:
                comment += "\n" + c

        # Check for class
        elif " class " in line and not ";" in line and not "//" in line:

            # Get class name and parent
            classname = line.split(" class ")[1].split(":")[0].strip()
            # TODO: KBO: multiple inheritance not handled!
            if "public" in line:
                # Look for '<' to handle template classes ('<T>')
                parent = line.split("public")[1].split("<")[0].strip()
            else:
                parent = None

            # Store documentation
            # TODO: KBO: we don't check if a given classname is in the dolfin
            # namepace.
            classnames.append(classname)
            documentation.append((classname, parent, comment, []))
            classname = None
            parent = None
            comment = None

        # Check for function signature
        elif comment is not None:
            s = line.strip()

            # Found start of new signature
            if signature is None:
                signature = s
                #indent = (len(s.split("(")[0]) + 1)*" "

            # Continuing signature on next line
            else:
                #signature += "\n" + indent + s
                signature += " " + s

            # Signature ends when we find ";" or "{"
            if ";" in s or "{" in s:

                # Strip out last part
                signature = signature.split(";")[0]
                signature = signature.split("{")[0]
                signature = signature.strip()

                # Remove stuff Spinx can't handle
                signature = signature.replace("virtual ", "")
                signature = signature.replace("inline ", "")

                # Remove ": stuff" for constructors
                if " : " in signature:
                    signature = signature.split(" : ")[0]

                # Skip destructors (not handled by Sphinx)
                destructor = "~" in signature

                # Get function name
                #function = signature.split("(")[0].split(" ")[-1]

                # Store documentation
                if len(documentation) > 0 and not destructor:
                    documentation[-1][-1].append((signature, comment))
                elif not destructor:
                    documentation = [(None, None, None, [(signature, comment)])]

                # Reset comment and signature
                comment = None
                signature = None

    # Close file
    f.close()

    # Sort documentation alphabetically within each class
#    for (classname, parent, comment, function_documentation) in documentation:
#        function_documentation.sort()

    return documentation, classnames

def extract_doc_representation():
    # Set top DOLFIN directory.
    dolfin_dir = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)),\
                                              os.pardir, os.pardir, os.pardir))
    # Extract modules from dolfin.h
    modules = []
    f = open(os.path.join(dolfin_dir, "dolfin", "dolfin.h"))
    for line in f:
        if line.startswith("#include <dolfin/"):
            module = line.split("/")[1]
            modules += [module]
    f.close()

    # Iterate over modules
    documentation = {}
    classnames = []
    for module in modules:
#        if not module == "mesh":
#            continue
        # Extract header files from dolfin_foo.h
        f = open(os.path.join(dolfin_dir, "dolfin", module, "dolfin_%s.h" % module))
        documentation[module] = []
        for line in f:

            # Generate documentation for header file
            if line.startswith("#include <dolfin/"):
                header = line.split("/")[2].split(">")[0]
#                if not header == "Vertex.h":
#                    continue
                doc, cls = extract_documentation(dolfin_dir, header, module)
                documentation[module].append((header, doc))
                classnames += cls

    return documentation, classnames

if __name__ == "__main__":
    docs, classes = extract_doc_representation()
#    for c in classes:
#        print c
#    for key, doc in docs.items():
#        for header, cont in doc:
#            print cont



