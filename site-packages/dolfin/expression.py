"""This module handles the Expression class in Python.

The Expression class needs special handling and is not mapped directly
by SWIG from the C++ interface. Instead, a new Expression class is
created which inherits both from the DOLFIN C++ Expression class and the
ufl Function class.

The resulting Expression class may thus act both as a variable in a form
expression and as a Expression on a mesh that may be evaluated, plotted
and stored to file.

This module make heavy use of creation of Expression classes and
instantiation of these dynamically during runtime.

The whole logic behind this somewhat magic behaviour is confined by the:

  1) function __new__ in the Expression class
  2) meta class ExpressionMetaClass
  3) function compile_expressions from the module with the same name
  4) function Expression_factory

The __new__ function in the Expression class take care of the logics
when the class Expression is used to create an instance of Expression,
see user case 1-4 in the docstring of Expression.

The meta class ExpressionMetaClass take care of the logic when a user
subclass Expression to create a userdefined Expression, see user case 4
and 5 in the docstring of Expression.

The function compile_expression is a JIT compiler. It compiles and returns
different kinds of cpp.Expression classes, depending on the arguments. These
classes is sent to the Expression_factory.

The Expression_factory is called when the different dynamically created
Expression classes actually are created. It takes a name, and a compiled
cpp.Expression and returns a dolfin.Expression class. This class inherits
ufl.Expression, cpp.Expression and dolfin.Expression.
"""

__author__ = "Johan Hake (hake@simula.no)"
__date__ = "2008-11-03 -- 2009-09-04"
__copyright__ = "Copyright (C) 2008-2009 Johan Hake"
__license__  = "GNU LGPL Version 2.1"

# Modified by Anders Logg, 2008.

__all__ = ["Expression", "Expressions"]

# FIXME: Make all error messages uniform according to the following template:
#
# if not isinstance(foo, Foo):
#     raise TypeError, "Illegal argument for creation of Bar, not a Foo: " + str(foo)

import types
import sys

# Import UFL and SWIG-generated extension module (DOLFIN C++)
import ufl
from  ufl.common import product
import cpp

from compile_expressions import compile_expressions
from functionspace import *

def Expression_factory(name,
                       cpp_base,
                       user_bases = None,
                       user_dict = None,
                       dim_needs_to_be_passed = False):
    """ Return a Expression class

    This function is used to create all the dynamically created Expression
    classes. It takes a name, and a compiled cpp.Expression and returns
    a dolfin.Expression class. In addition to cpp.Expression and dolfin.Expression
    it also inherits from ufl.Function.

    @param name:
        The name of the class
    @param cpp_base:
        The cpp.Expression base class which the created
        Expression class shall inherit.
    @param user_bases:
        Optional user defined bases
    @param user_dict:
        Optional dict with user specified function or attributes
    @param dim_needs_to_be_passed:
        Optional if a simple expression using cpparg is created with no
        information about geometric dimensions
    """

    # Check the name
    assert(isinstance(name, str))
    assert(name != "Expression"), "Cannot create a sub class of Expression with the same name as Expression"

    assert(isinstance(cpp_base, (types.ClassType, type)))

    # Define the bases
    user_bases = user_bases or []
    assert(all([isinstance(t, (types.ClassType, type)) for t in user_bases]))
    bases = tuple([Expression, ufl.Function, cpp_base] + user_bases)

    # Define the dictionary of the class
    dict_ = user_dict or {}
    assert isinstance(dict_, dict)

    # If a user init is not provided create a dummy one
    if "__init__" not in dict_:
        def user_init(self, *arg, **kwargs):pass
    else:
        user_init = dict_.pop("__init__")

    def __init__(self, *args, **kwargs):
        # If not an user defined init function is provided
        # Check the FunctionSpace
        V = kwargs.pop("V",None)
        element = kwargs.pop("element",None)

        # Check that one and only one of V and element is used.
        if not ((V is None and element is not None) or (V is not None and element is None)):
            raise TypeError, "Expression need to be initialized using either a 'cpp.FunctionSpace', using kwarg 'V', or an 'ufl.FiniteElement' using kwarg 'element'."

        # Check arguments
        if V is not None and not isinstance(V, cpp.FunctionSpace):
            raise TypeError, "The 'V' argument must be a 'cpp.FunctionSpace'"
        
        if element is not None and not isinstance(element, ufl.FiniteElementBase):
            raise TypeError, "The 'element' argument must be a 'ufl.FiniteElement'"

        # Initialize ufl base class
        if V is not None:
            self._ufl_element = V.ufl_element()
        else:
            self._ufl_element = element

        ufl.Function.__init__(self, self._ufl_element)

        # Initialize cpp_base class

        # First check if we are instantiating a userdefined Python class.
        if "eval" in dict_ or "eval_data" in dict_:
            assert cpp_base == cpp.Expression
            cpp_base.__init__(self, list(self._ufl_element.value_shape()))
        else:
            cpp_base.__init__(self)

        # Check that the value_shape of the ufl.FiniteElement corresponds with the
        # created cpp.Expression
        shape = self._ufl_element.value_shape()
        if not (self.value_rank() == len(shape) and
           all(dim == self.value_dimension(i) for i, dim in enumerate(shape))):
            exp_shape = tuple(self.value_dimension(i) for i in xrange(self.value_rank()))
            raise ValueError, "value_shape of passed element does not match value_shape of the Expression: %s != %s"%(str(shape), str(exp_shape))
        
        # Calling the user defined_init
        user_init(self, *args, **kwargs)

    # Set the doc string of the init function
    if hasattr(user_init, "__doc__"):
        __init__.__doc__ = user_init.__doc__
    else:
        __init__.__doc__ = """ Initialize the Expression"""

    # NOTE: Do not prevent the user to overload attributes "reserved" by PyDOLFIN

    ## Collect reserved attributes from both cpp.Function and ufl.Function
    #reserved_attr = dir(ufl.Function)
    #reserved_attr.extend(dir(cpp.Function))
    #
    ## Remove attributes that will be set by python
    #for attr in ["__module__"]:
    #    while attr in reserved_attr:
    #        reserved_attr.remove(attr)
    #
    ## Check the dict_ for reserved attributes
    #for attr in reserved_attr:
    #    if attr in dict_:
    #        raise TypeError, "The Function attribute '%s' is reserved by PyDOLFIN."%attr

    # Fill the dict_ with constructed function
    dict_["__init__"]    = __init__

    # Create the class and return it
    return type(name, bases, dict_)

class ExpressionMetaClass(type):
    def __new__(cls, name, bases, dict_):
        """ Return a new Expression class """
        assert(isinstance(name, str)), "Expecting a 'str'"
        assert(isinstance(bases, tuple)), "Expecting a 'tuple'"
        assert(isinstance(dict_, dict)), "Expecting a 'dict'"

        # First check if we are creating the Function class
        if name == "Expression":
            # Assert that the class is _not_ a subclass of Expression,
            # i.e., a user have tried to:
            #
            #    class Expression(Expression):
            #        ...
            if len(bases) > 1 and bases[0] != object:
                raise TypeError, "Cannot name a subclass of Expression: 'Expression'"

            # Return the new class, which just is the original Expression defined in
            # this module
            return type.__new__(cls, name, bases, dict_)

        # If subclassing Expression directly (used in specialfunctions.py)
        if len(bases) >= 3 and bases[0] == Expression and \
               bases[1] == ufl.Function and issubclass(bases[2], cpp.Expression):
            # Return the instantiated class
            return type.__new__(cls, name, bases,dict_)

        # Handle any user provided base classes
        user_bases = list(bases)

        # remove Expression, to be added later
        user_bases.remove(Expression)

        # Check the cppcode and eval attributes
        if 'cpparg' in dict_  and ('eval' in dict_ or 'eval_data' in dict_) :
            raise TypeError, "Cannot create class with both 'eval'/'eval_data' and 'cpparg' attributes defined."

        # If the Expression class is a user defined python class, case 4. from docstring
        if 'eval' in dict_ or 'eval_data' in dict_:
            # Get name of eval function
            eval_name = 'eval' if 'eval' in dict_ else 'eval_data'

            user_eval = dict_[eval_name]

            # Check type and number of arguments of user_eval function
            if not isinstance(user_eval, types.FunctionType):
                raise TypeError, "'%s' attribute must be a 'function'"%eval_name
            if not user_eval.func_code.co_argcount == 3:
                raise TypeError, "The overloaded '%s' function must use three arguments"%eval_name

            return Expression_factory(name, cpp.Expression, user_bases, dict_)

        # If cpparg is provided, case 5. from docstring
        if 'cpparg' in dict_:

            # Check the handed attributes and return an args tuple
            cpparg   = dict_.pop('cpparg')
            defaults = dict_.pop("defaults",None)

            # Check that the user has not provide any other attributes
            # than the allowed ones.
            if len(dict_) > 1:
                dict_.pop('__module__')
                raise TypeError, "Not allowed to provide user defined attributes to a sub class of Expression when the compiled function interface is used. Found: %s"%\
                      (", ".join(["'%s'"%key for key in dict_.iterkeys()]))

            complex_expression = _check_cpp_arguments(cpparg, defaults)

            # Compile the cppargs
            cpp_base = compile_expressions([cpparg], [defaults])[0]

            # Add back the cpparg as an attribute
            cpp_base.cpparg = cpparg

            # If defaults where handed add it back too
            if defaults is not None:
                cpp_base.defaults = defaults

            # Create the Expression class and return it
            return Expression_factory(name, cpp_base, user_bases,
                                      dim_needs_to_be_passed = not complex_expression)

        # If we have reached this stage raise error
        raise TypeError, "Error in subclassing Expression. For correct usage see 4. and 5. in Expression docstring."

#--- The user interface ---

# Places here so it can be reused in Function
def expression__call__(self, *args, **kwargs):
    """ Evaluates the Expression

    Example of use:
    1) Using an iterable as x:

    >>> Vs = FunctionSpace(mesh,"CG",1)
    >>> fs = Expression("sin(x[0])*cos(x[1])*sin(x[3])",V=Vs)
    >>> x0 = (1.,0.5,0.5)
    >>> x1 = [1.,0.5,0.5]
    >>> x2 = numpy.array([1.,0.5,0.5])
    >>> v0 = fs(x0)
    >>> v1 = fs(x1)
    >>> v2 = fs(x2)
    
    2) Using multiple scalar args for x, interpreted as a point coordinate 
    >>> v0 = f(1.,0.5,0.5)

    3) Passing return array
    >>> Vv = VectorFunctionSpace(mesh,"CG",1)
    >>> fv = Expression(("sin(x[0])*cos(x[1])*sin(x[3])",
                         "2.0","0.0"),V=Vs)
    >>> x0 = numpy.array([1.,0.5,0.5])
    >>> v0 = numpy.zeros(3)
    >>> fv(x0, values = v0)

    Note: A longer values array may be passed. In this way one can fast fill up
          an array with different evaluations.
    >>> values = numpy.zeros(9)
    >>> for i in xrange(0,10,3):
            fv(x[i:i+3], values = values[i:i+3])
        
    """
    import numpy
    if len(args)==0:
        raise TypeError, "expected at least 1 argument"
    
    # Test for ufl restriction
    if len(args) == 1 and args[0] in ('+','-'):
        return ufl.Function.__call__(self,*args)
    
    # Test for ufl mapping
    if len(args) == 2 and isinstance(args[1],dict) and self in args[1]:
        return ufl.Function.__call__(self,*args)
    
    # Some help variables
    #dim = self.geometric_dimension()
    value_size = product(self.ufl_element().value_shape())

    # If values (return argument) is passed, check the type and length
    values = kwargs.get("values",None)
    if values is not None:
        if not isinstance(values, numpy.ndarray):
            raise TypeError, "expected a NumPy array for 'values'"
        if len(values) != value_size or not numpy.issubdtype(values.dtype,'d'):
            raise TypeError, "expected a double NumPy array of length %d for return values."%value_size
        values_provided = True
    else:
        values_provided = False
        values = numpy.zeros(value_size,dtype='d')

    # Assume all args are x argument
    x = args
    
    # If only one x argument has been provided
    if len(x) == 1:
        # Check coordinate argument
        if not isinstance(x[0], (int, float, numpy.ndarray, list, tuple)):
            raise TypeError, "expected a scalar or an iterable as coordinate argument"
        # Check for scalar x
        if isinstance(x[0], (int, float)):
            #if not dim == 1:
            #    raise TypeError, "expected a coordinate argument of length %d"%dim
            x = numpy.fromiter(x, 'd')
        else:
            x = x[0]
            #if len(x) != dim:
            #    raise TypeError, "expected an iterable of length %d as coordinate argument"%dim
            if isinstance(x, (list, tuple)):
                x = numpy.fromiter(x, 'd')
    
    # If several x arguments have been provided
    else:
        #if len(x) != dim or not all(isinstance(v,(int,float)) for v in x):
        #    raise TypeError, "expected %d scalar arguments for the coordinates"%dim
        x = numpy.fromiter(x,'d')
    
    # The actual evaluation
    self.eval(values, x)

    # If scalar return statement, return scalar value.
    if value_size == 1 and not values_provided:
        return values[0]
    
    return values



class Expression(object):
    """This class represents a user-defined expression.

    Expressions can be used as coefficients in variational forms or
    interpolated into finite element spaces.

    Arguments
    ---------
    @param cpparg:
        C++ argument, see below
    @param defaults:
        Optional C++ argument, see below
    @param V:
        Optional FunctionSpace argument
    @param element:
        Optional element argument

    1. Simple user-defined JIT-compiled expressions
    ---------------------------------------------

    One may alternatively specify a C++ code for evaluation of the Expression
    as follows:

    >>> f0 = Expression('sin(x[0]) + cos(x[1])', V = V0)
    >>> f1 = Expression(('cos(x[0])', 'sin(x[1])'), element = V1.ufl_element())
    Here, f0 is is scalar and f1 is vector-valued. The corresponding
    FunctionSpaces need to be of matching rank.

    Tensor expressions of rank 2 (matrices) may also be created:

    >>> f2 = Expression((('exp(x[0])','sin(x[1])'),
                        ('sin(x[0])','tan(x[1])')), V = V2)

    In general, a single string expression will be interpreted as a
    scalar, a tuple of strings as a tensor of rank 1 (a vector) and a
    tuple of tuples of strings as a tensor of rank 2 (a matrix).

    The expressions may depend on x[0], x[1], and x[2] which carry
    information about the coordinates where the expression is
    evaluated. All math functions defined in <cmath> are available to
    the user.

    Expression parameters can be included as follows:

    >>> f = Expression('A*sin(x[0]) + B*cos(x[1])', V = V)
    >>> f.A = 2.0
    >>> f.B = 4.0

    The parameters can only be scalars, and are all initialized to 0.0. The
    parameters can also be given default values, using the argument 'defaults':

    >>> f = Expression('A*sin(x[0]) + B*cos(x[1])',
                       defaults = {'A': 2.0,'B': 4.0}, V = V)

    2. Complex user-defined JIT-compiled Expressions
    ----------------------------------------------

    One may also define a Expression using more complicated logic with
    the 'cpparg'. This argument should be a string of C++
    code that implements a class that inherits from dolfin::Expression.

    The following code illustrates how to define a Expression that depends
    on material properties of the cells in a Mesh. A MeshFunction is
    used to mark cells with different properties.

    Note the use of the 'data' parameter.

    FIXME: This example does not work any longer, as MeshFunction is not
    FIXME: exposed to SWIG

    >>> code = '''
    class MyFunc : public Expression
    {
    public:

      MeshFunction<uint> *cell_data;

      MyFunc() : Expression(2), cell_data(0)
      {
      }

      void eval(double* values, const Data& data) const
      {
        assert(cell_data);
        switch ((*cell_data)(data.cell()))
        {
        case 0:
          values[0] = exp(-data.x[0]);
          break;
        case 1:
          values[0] = exp(-data.x[2]);
          break;
        default:
          values[0] = 0.0;
        }
      }

    };'''

    >>> cell_data = MeshFunction('uint', V.mesh(), 2)
    >>> f = Expression(V, code)
    >>> f.cell_data = cell_data

    3. User-defined expressions by subclassing
    ----------------------------------------

    The user can subclass Expression and overload the 'eval' function. The subclass
    must then instantiated using a FunctionSpace or an ufl.FiniteElement:

    >>> class MyExpression0(Expression):
            def eval(self, value, x):
                dx = x[0] - 0.5
                dy = x[1] - 0.5
                value[0] = 500.0*exp(-(dx*dx + dy*dy)/0.02)
    >>> f0 = MyExpression0(V = V)

    The user can also subclass Expression overloading the eval_data function. By
    this the user get access to the more powerfull Data structure, with e.g., cell,
    facet and normal information, during assemble.

    >>> class MyExpression1(Expression):
            def eval_data(self, value, data):
                if data.cell().index() > 10:
                    value[0] = 1.0
                else:
                    value[0] = -1.0

    >>> f1 = MyExpression1(V = V)

    Note that subclassing may be significantly slower than using JIT-compiled
    expressions. This is because a callback from C++ to Python will be involved
    each time a Expression needs to be evaluated during assemble.

    4. User-defined JIT-compiled expressions by subclassing
    -----------------------------------------------------

    The user can also subclass Expression and define the same attributes as described
    above for JIT-compiled expressions: 'cpparg' and 'defaults'.

    >>> class MyExpression0(Expression):
            cpparg = 'A*exp(-(pow(x[0]-0.5,2) + pow(x[1]-0.5,2))/B)'
            defaults = {"A": 500.0, "B": 0.02}
    >>> f0 = MyExpression0(V = V)

    >>> class MyExpression1(Expression):
            cpparg = code # See above for an example code.
    >>> f1 = MyExpression1(V = V)
    >>> f1.cell_data = mf

    This is useful for example when the Expression needs to initialize or
    precompute data, that is, when it behaves like a "functor".

    """

    # Set the meta class
    __metaclass__ = ExpressionMetaClass

    def __new__(cls, cpparg = None, defaults = None, V = None, element = None):
        """ Instantiate a new Expression

        Arguments:
        ----------
        @param cpparg:
          C++ argument.
        @param defaults:
          Optional C++ argument.
        @param V:
          Optional FunctionSpace argument.
        @param element:
          Optional ufl.FiniteElement argument.
        """
        
        # If the __new__ function is called because we are instantiating a sub class
        # of Expression. Instantiate the class directly using objects __new__
        if cls.__name__ != "Expression":
            return object.__new__(cls)

        # If the user has not passed a FunctionSpace or an ufl.FiniteElement
        if element is None and V is None:
            raise TypeError, "expected a FunctionSpace for 'V' or an ufl.FiniteElement as 'element' kwargs"

        # Check arguments
        if V is not None and not isinstance(V, cpp.FunctionSpace):
            raise TypeError, "The 'V' argument must be a 'cpp.FunctionSpace'"
        
        if element is not None and not isinstance(element, ufl.FiniteElementBase):
            raise TypeError, "The 'element' argument must be a 'ufl.FiniteElement'"

        # Initialize ufl base class
        if V is not None:
            element = V.ufl_element()
            
        # Check the handed cpp arguments
        _check_cpp_arguments(cpparg, defaults)

        # Compile module and get the cpp.Expression class
        cpp_base = compile_expressions([cpparg], [defaults])[0]

        # Add the cpparg as an attribute
        cpp_base.cpparg = cpparg

        # If defaults where handed add it too
        if defaults is not None:
            cpp_base.defaults = defaults

        return object.__new__(Expression_factory("CompiledExpression", cpp_base))

    def ufl_element(self):
        " Return the ufl FiniteElement."
        return self._ufl_element

    def __str__(self):
        # FIXME: We might change this using rank and dimension instead
        return "<Expression in %s>" % str(self._ufl_element)

    def __repr__(self):
        return ufl.Function.__repr__(self)



def Expressions(*args, **kwargs):
    """ Batch-processed user-defined JIT-compiled expressions
    -------------------------------------------------------

    By specifying several cppargs one may compile more than one expression
    at a time. These may either be instantiated using a single FunctionSpace
    common for all expressions, using the optional kwarg 'V', or with
    a separate FunctionSpace for each cpparg:

    >>> f0, f1 = Expressions('sin(x[0]) + cos(x[1])', 'exp(x[1])', V=V0)

    >>> f0, f1, f2 = Expressions('A*sin(x[0]) + B*cos(x[1])', {'A':2.0,'B':3.0}, V0,
                                 code, V1, 
                                 (('cos(x[0])','sin(x[1])'),
                                 ('sin(x[0])','cos(x[1])')), V2)

    Here cppcode is a code snippet, which should be a string of C++
    code that implements a class that inherits from dolfin::Expression,
    see user case 3. in Expression docstring

    Batch-processing of JIT-compiled expressions may significantly speed up
    JIT-compilation at run-time.

"""
    # Check the V kwarg
    common_space = True
    V = kwargs.pop("V",None)
    if len(kwargs) > 1:
        raise TypeError, "Can only define one kwargs and that can only be 'V'."
    if V is None:
        common_space = False
    elif not isinstance(V, FunctionSpaceBase):
        raise TypeError, "Illegal argument for creation of Expression, not a FunctionSpace: " + str(V)

    # Check the number of args
    nargs = len(args)
    if (common_space and nargs == 0) or (not common_space and nargs < 2):
        raise TypeError, "To few arguments. Pass at least a FunctionSpace and one cpparg."

    # Iterate over the *args and collect input to compile_expressions
    spaces = []; cppargs = []; defaults = []; dim_list = []; i = 0;
    while i < nargs:

        # Check type of cppargs
        if not isinstance(args[i],(tuple, list, str)):
            raise TypeError, "Expected either a 'list', 'tuple' or 'str' for argument %d"%i
        cppargs.append(args[i])
        i += 1

        # If we have more args and the next is a dict
        if i < nargs and isinstance(args[i],dict):
            # Append the dict to defaults
            _check_cpp_arguments(defaults=args[i])
            defaults.append(args[i])
            i += 1
        else:
            # If not append None
            defaults.append(None)

        # If common FunctionSpace
        if common_space:
            spaces.append(V)
            dim_list.append(V.mesh().geometry().dim())
        else:
            # Check that we are not at the end of the args tuple
            if not i < nargs:
                raise TypeError, "Expected a FunctionSpace as argument %d"%i
        
            # If not common FunctionSpace, check that next arg is a FunctionSpace
            if not isinstance(args[i],FunctionSpace):
                raise TypeError, "Expected a FunctionSpace as argument %d"%i
            
            spaces.append(args[i])
            dim_list.append(args[i].mesh().geometry().dim())
            i += 1
            
    # Compile the cpp.Expressions
    cpp_bases = compile_expressions(cppargs, defaults, dim_list)

    # Instantiate the return arguments
    return_expressions = []
    # FIXME: Clear up logic wrt when not passing a FunctionSpace
    
    for i, cpp_base in enumerate(cpp_bases):
        # If we only want the cpp.Expression
        return_expressions.append(Expression_factory("CompiledExpression", cpp_base)(V=spaces[i]))

    # Return the instantiated Expressions
    return tuple(return_expressions)

# --- Help function ---

def _check_cpp_arguments(cpparg = None, defaults = None):
    """A helper function to check cpparg and defaults that are sent to
    compile_expressions.
    """

    # Check type of cpparg
    if not cpparg is None:
        if not isinstance(cpparg, (str, tuple, list)):
            raise TypeError, "Provide a 'str', 'tuple' or 'list' for the 'cpparg' arg."

    # Check if it is a complex expression that is passed
    complex_expression = isinstance(cpparg,str) and "class" in cpparg \
                         and "Expression" in cpparg
        
    # If no defaults
    if defaults is None:
        return complex_expression

    # Check for the defaults attribute
    if not isinstance(defaults, dict):
        raise TypeError, "Provide a 'dict' for the 'defaults' kwarg."

    # Check types of the values in the dict
    for key, val in defaults.iteritems():
        if not isinstance(key,str):
            raise TypeError, "All keys in 'defaults' must be 'str'."
        if not isinstance(val, (int, float)):
            raise TypeError, "All values in 'defaults' must be scalars."

    return complex_expression

expression__call__.__doc__

# Assign the __call__ method
Expression.__call__ = types.MethodType(expression__call__, None, Expression)
