__author__ = "Johan Hake (hake@simula.no)"
__date__ = "2008-11-03 -- 2008-11-19"
__copyright__ = "Copyright (C) 2008 Johan Hake"
__license__  = "GNU LGPL Version 2.1"

# Modified by Anders Logg, 2008.

__all__ = ["FunctionSpace"]

import ffc
import dolfin

class FunctionSpace(dolfin.cpp_FunctionSpace):
    """FunctionSpace represents a finite element function space.

    A FunctionSpace is defined by a mesh, a finite element, and a
    local-to-global mapping of the degrees of freedom (dofmap).
    """

    def __init__(self, mesh, arg0, arg1=None):
        """Create finite element function space.

        A FunctionSpace can be created in either one of two ways, either by
        specifying a Mesh and a FiniteElement, or by specifying the family
        and degree of the FiniteElement:

        1. V = FunctionSpace(mesh, element)
        
            mesh    : a Mesh
            element : a FiniteElement

        2. V = FunctionSpace(mesh, family, degree)

            mesh    : a Mesh
            family  : a string specifying the element family
            degree  : the degree of the element

        Which families and degrees that are supported is determined by the
        form compiler used to generate the element, but typical elements
        include

            Lagrange
            Discontinuous Lagrange
            Bubble
            Crouzeix-Raviart
            Brezzi-Douglas-Marini
            Brezzi-Douglas-Fortin-Marini
            Raviart-Thomas
            Nedelec 1st kind H(div)
            Nedelec 2nd kind H(div)
            Nedelec 1st kind H(curl)
            Nedelec 2nd kind H(curl)
            Quadrature
            Boundary Quadrature

        Note that if a mixed element is needed, one must first create the element,
        and then use the first constructor.
        """

        # Create the element
        assert(isinstance(mesh, dolfin.Mesh), "Invalid mesh type.")
        if arg1 is None:
            assert(isinstance(arg0, (ffc.FiniteElementBase)), "Invalid element type.")
            self.__ffc_element = arg0
        else:
            dim2domain = {1: "interval", 2: "triangle", 3: "tetrahedron"}
            family = arg0
            domain = dim2domain[mesh.topology().dim()]
            degree = arg1
            self.__ffc_element = ffc.FiniteElement(family, domain, degree)
        
        # JIT-compile element to get ufc_element and ufc_dofmap
        self.__ufc_element, self.__ufc_dofmap = ffc.jit(self.__ffc_element)

        # Instantiate DOLFIN FiniteElement and DofMap 
        self.__dolfin_element = dolfin.FiniteElement(self.__ufc_element)
        self.__dolfin_dofmap  = dolfin.DofMap(self.__ufc_dofmap, mesh)
        
        # Initialize the cpp_FunctionSpace
        dolfin.cpp_FunctionSpace.__init__(self, mesh,
                                          self.__dolfin_element,
                                          self.__dolfin_dofmap)
        
    def ffc_element(self):
        " Return the form compiler element"
        return self.__ffc_element
    
    def __str__(self):
        return "%s function space" % self._ffc_element.__class__.__name__
