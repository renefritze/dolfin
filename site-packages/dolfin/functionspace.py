__author__ = "Johan Hake (hake@simula.no)"
__date__ = "2008-11-03 -- 2008-12-03"
__copyright__ = "Copyright (C) 2008 Johan Hake"
__license__  = "GNU LGPL Version 2.1"

# Modified by Anders Logg, 2008.

__all__ = ["FunctionSpace", "MixedFunctionSpace", "VectorFunctionSpace", "FunctionSpaceBase"]

# Import FFC and SWIG-generated extension module (DOLFIN C++)
import ffc
import cpp

# Mapping from dimension to domain
dim2domain = {1: "interval", 2: "triangle", 3: "tetrahedron"}

class FunctionSpaceBase(cpp.FunctionSpace):
    "Base class for all function spaces."

    def __init__(self, mesh, element):
        "Create function space on given mesh for given finite element."

        # Check arguments
        if not isinstance(mesh, cpp.Mesh):
            cpp.error("Illegal mesh for creation of function space, not a mesh: " + str(mesh))
        if not isinstance(element, (ffc.FiniteElementBase)):
            cpp.error("Illegal finite element for creation of function space, not a finite element: " + str(element))

        # Store element
        self.__element = element
        
        # JIT-compile element to get ufc_element and ufc_dofmap
        self.__ufc_element, self.__ufc_dofmap = ffc.jit(self.__element)

        # Instantiate DOLFIN FiniteElement and DofMap 
        self.__dolfin_element = cpp.FiniteElement(self.__ufc_element)
        self.__dolfin_dofmap  = cpp.DofMap(self.__ufc_dofmap, mesh)
        
        # Initialize the cpp_FunctionSpace
        cpp.FunctionSpace.__init__(self, mesh,
                                   self.__dolfin_element,
                                   self.__dolfin_dofmap)
    def element(self):
        "Return the form compiler element."
        return self.__element

    def __add__(self, other):
        "Create mixed function space"
        return MixedFunctionSpace((self, other))
    
    def __str__(self):
        "Pretty-print."
        return "<Function space of dimension %d (%s)>" % (self.dofmap().global_dimension(), str(self.__element))

class FunctionSpace(FunctionSpaceBase):
    "FunctionSpace represents a finite element function space."

    def __init__(self, mesh, family, degree):
        """Create finite element function space. The function space
        may be created by
        
            V = FunctionSpace(mesh, family, degree)

            mesh    : a Mesh
            family  : a string specifying the element family
            degree  : the degree of the element

        Which families and degrees that are supported is determined by the
        form compiler used to generate the element, but typical families
        include

            Lagrange
            Discontinuous Lagrange
            Bubble
            Crouzeix-Raviart
            Brezzi-Douglas-Marini
            Brezzi-Douglas-Fortin-Marini
            Raviart-Thomas
            Nedelec 1st kind H(div)
            Nedelec 2nd kind H(div)
            Nedelec 1st kind H(curl)
            Nedelec 2nd kind H(curl)
            Quadrature
            Boundary Quadrature
        """

        # Check arguments
        if not isinstance(mesh, cpp.Mesh):
            cpp.error("Illegal mesh for creation of function space, not a mesh: " + str(mesh))
        if not isinstance(family, str):
            cpp.error("Illegal family for creation of function space, not a string: " + str(family))
        if not isinstance(degree, int):
            cpp.error("Illegal degree for creation of function space, not an integer: " + str(degree))
        dim = mesh.topology().dim()
        if not dim in dim2domain:
            cpp.error("Invalid mesh dimension: " + str(dim))

        # Create element
        domain = dim2domain[mesh.topology().dim()]
        element = ffc.FiniteElement(family, domain, degree)

        # Initialize base class
        FunctionSpaceBase.__init__(self, mesh, element)

class MixedFunctionSpace(FunctionSpaceBase):
    "MixedFunctionSpace represents a mixed finite element function space."

    def __init__(self, spaces):
        """Create mixed finite element function space. The function space
        may be created by
        
            V = MixedFunctionSpace(spaces)

        where spaces is a list (or tuple) of function spaces.
        """

        # Check arguments
        if not len(spaces) > 0:
            cpp.error("Mixed function space needs at least one subspace.")
        if not all([isinstance(V, FunctionSpaceBase) for V in spaces]):
            cpp.error("Invalid subspaces: " + str(spaces))
        #if not all([V.mesh() == spaces[0].mesh() for V in spaces]):
        #    cpp.error("Nonmatching meshes for mixed function space: " + str([V.mesh() for V in spaces]))

        # Store spaces
        self.spaces = spaces

        # Store any cpp.SubSpaces
        self._cpp_sub_spaces = {}
        
        # Create element
        element = ffc.MixedElement([V.element() for V in spaces])

        # Initialize base class
        FunctionSpaceBase.__init__(self, spaces[0].mesh(), element)

    def sub(self,i):
        " Return the i:th cpp.SubSpace"
        # Fixme: Should we have a more extensive check other than whats included in
        # the cpp code?
        if i not in self._cpp_sub_spaces.keys():
            # Store the created subspace to prevent swig garbage collection
            self._cpp_sub_spaces[i] = cpp.SubSpace(self,i)
        return self._cpp_sub_spaces[i]
    
    def num_sub_spaces(self):
        " Return the number of sub spaces"
        return self.__ufc_element.num_sub_elements()    

class VectorFunctionSpace(MixedFunctionSpace):
    "VectorFunctionSpace represents a vector-valued finite element function space."

    def __init__(self, mesh, family, degree, dim=None):
        """Create vector-valued finite element function space. The function space
        may be created by
        
            V = VectorFunctionSpace(mesh, family, domain, degree, dim=None)

            mesh    : a Mesh
            family  : a string specifying the element family
            degree  : the degree of the element
            dim     : an optional argument specifying the number of components

        If the dim argument is not provided, the dimension will be deduced from
        the dimension of the mesh.
        """

        # Create subspaces
        dim = dim or mesh.geometry().dim()        
        spaces = dim*[FunctionSpace(mesh, family, degree)]

        # Initialize base class
        MixedFunctionSpace.__init__(self, spaces)
