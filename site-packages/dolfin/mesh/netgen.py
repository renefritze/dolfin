"""This module provides simple Python bindings for building geometries
using constructive solid geometry (CSG) and exporting to NETGEN .geo
files."""

# Copyright (C) 2012 Anders Logg
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.
#
# First added:  2012-01-12
# Last changed: 2012-01-12

import numpy, sys, os

from dolfin import cpp
from dolfin_utils.commands import getstatusoutput

def has_netgen():
    "Check whether we have NETGEN"
    status, output = getstatusoutput("netgen -V -batchmode")
    return status == 1

def _rotate(x, x0, angle, axis):
    "Rotate point x given angle / degrees around given axis through the point x0"

    # Set up rotation matrix
    theta = angle / 180.0 * numpy.pi
    S = [numpy.cos(theta), -numpy.sin(theta),
         numpy.sin(theta), numpy.cos(theta)]
    R = numpy.eye(3)
    if axis == 0: # didn't figure out how to do this with slices...
        R[1, 1] = S[0]; R[1, 2] = S[1]; R[2, 1] = S[2]; R[2, 2] = S[3];
    elif axis == 1:
        R[0, 0] = S[0]; R[0, 2] = S[1]; R[2, 0] = S[2]; R[2, 2] = S[3];
    else:
        R[0, 0] = S[0]; R[0, 1] = S[1]; R[1, 0] = S[2]; R[1, 1] = S[3];

    # Rotate point
    x = numpy.array(x)
    x = x0 + numpy.dot(R, x - x0)

    return x

class Geometry:
    """A geometry is represented as union of intersections of
    primitives (which may be positive or negative)."""

    # This reminds a lot about the original FFC representation of
    # forms as sums of products of basis functions and their
    # derivatives... :-) The storage scheme is a tuple of tuples of
    # pairs, where each pair is (primitive, sign).

    def __init__(self, x=None):
        if isinstance(x, Geometry):
            self._intersections = x._intersections
        elif isinstance(x, tuple):
            self._intersections = x
        elif x is None:
            self._intersections = None
        else:
            self._intersections = (((x, 1),),)

    def __add__(self, other):
        "Addition operator (set union)"
        v = self
        w = Geometry(other)
        return Geometry(v._intersections + w._intersections)

    def __sub__(self, other):
        "Subtraction operator (set subtraction)"
        return self * (-other)

    def __mul__(self, other):
        "Multiplication operator (set intersection)"
        v = self
        w = Geometry(other)
        intersections = []
        for i in v._intersections:
            for j in w._intersections:
                intersections.append(tuple(set(i + j)))
        return Geometry(tuple(intersections))

    def __neg__(self):
        "Negation operator (set complement)"

        # Doing a bit of clever Boolean algebra here...
        assert(len(self._intersections) > 0)
        g = Geometry(tuple([((p, -n),) for (p, n) in self._intersections[0]]))
        for i in self._intersections[1:]:
            g = g * Geometry(tuple([((p, -n),) for (p, n) in i]))
        return g

    def __str__(self):
        "Pretty-print"
        s = "Geometry expressed as a union of %d intersections:" % \
            len(self._intersections)
        s += "\n" + len(s)*"-" + "\n"
        s += "g = " + self._expression("*", " + ", "-", False)
        s += "\n\n"
        ps = self.primitives()
        for (i, p) in enumerate(ps):
            s += ("p%d = " % i) + str(p) + "\n"
        return s

    def primitives(self):
        "Return list of primitives"
        ps = []
        for i in self._intersections:
            for (p, n) in i:
                if not p in ps:
                    ps.append(p)
        return ps

    def write_geometry(self, filename="mesh.geo"):
        "Write geometry to given filename (NETGEN .geo file)"
        cpp.info("Writing geometry to NETGEN file %s." % filename)
        ps = self.primitives()
        expression = self._expression(" and ", " or ", "not ", True)
        f = open(filename, "w")
        f.write("algebraic3d\n\n")
        for (i, p) in enumerate(ps):
            f.write(p._write("p%d" % i) + "\n")
        f.write("\n")
        f.write("solid geometry = %s" % expression)
        f.write(";\n\n")
        f.write("tlo geometry;\n");
        f.close()

    def generate_mesh(self,
                      filename="mesh.xml",
                      meshsize="moderate"):
        """Generate DOLFIN mesh and write to given filename. The
        meshsize can be one of "verycoarse", "coarse", "moderate",
        "fine", "veryfine"."""

        # Get prefix
        prefix = filename.split(".")[0]

        # Write NETGEN geometry file
        self.write_geometry(prefix + ".geo")

        # Call NETGEN to generate mesh
        cpp.info("Calling NETGEN to generate mesh, this may take some time...")
        cpp.info("Note that NETGEN may crash after the mesh generation has "
                 "completed but may still succeed in generating the mesh.")
        os.system("netgen -batchmode -%s "
                  "-meshfiletype=\"DIFFPACK Format\" "
                  "-geofile=%s.geo "
                  "-meshfile=%s.grid > %s.log" % (meshsize, prefix, prefix, prefix))
        cpp.info("")
        cpp.info("Call to NETGEN completed, assuming it went fine.")
        cpp.info("The NETGEN log file has been stored to  %s.log." % prefix)
        cpp.info("The output mesh is (presumably) stored in %s.grid (Diffpack format)." % prefix)

        # Call dolfin-convert to convert to DOLFIN format
        cpp.info("")
        cpp.info("Calling dolfin-convert to convert to DOLFIN XML, this may take some time...")
        os.system("dolfin-convert %s.grid %s.xml" % (prefix, prefix))
        cpp.info("")
        cpp.info("Call to dolfin-convert completed.")

    def _expression(self, boolean_and, boolean_or, boolean_not, paranthesize):
        "Return NETGEN description of geometry"
        s = ""
        ps = self.primitives()
        products = []
        for i in self._intersections:
            product = []
            for (p, n) in i:
                if n < 0:
                    product.append("(%sp%d)" % (boolean_not, ps.index(p)))
                else:
                    product.append("p%d" % ps.index(p))
            if paranthesize and len(self._intersections) > 1:
                products.append("(" + boolean_and.join(product) + ")")
            else:
                products.append(boolean_and.join(product))
        return boolean_or.join(products)

    def _name(self, i, n):
        "Return name for NETGEN description"
        return {1: "", -1: "not "}[n] + "object_%d" % i

class Primitive:
    "Base class for all primitives"

    def __init__(self):
        self._sign = 1

    def __add__(self, other):
        "Addition operator (set union)"
        return Geometry(self) + Geometry(other)

    def __sub__(self, other):
        "Subtraction operator (set subtraction)"
        return Geometry(self) - Geometry(other)

    def __mul__(self, other):
        "Multiplication operator (set intersection)"
        return Geometry(self) * Geometry(other)

    def __neg__(self):
        "Negation operator (set complement)"
        return -Geometry(self)

    def write_geometry(self, filename):
        "Write geometry to given filename (NETGEN .geo file)"
        Geometry(self).write(filename)

class Plane(Primitive):

    def __init__(self, x0, x1, x2, n0, n1, n2):
        "A plane at x with normal vector n"

        Primitive.__init__(self)

        self.x = (float(x0), float(x1), float(x2))
        self.n = (float(n0), float(n1), float(n2))

    def __str__(self):
        return "Plane at x = %s with normal n = %s" % \
            (str(self.x), str(self.n))

    def _write(self, prefix):
        x = self.x
        n = self.n
        return "solid %s = plane(%g, %g, %g; %g, %g, %g);" % \
            (prefix, x[0], x[1], x[2], n[0], n[1], n[2])

class InfiniteCylinder(Primitive):

    def __init__(self, x0, x1, x2, y0, y1, y2, r):
        "An infinite cylinder passing through x to y with radius r"

        Primitive.__init__(self)

        self.x = (float(x0), float(x1), float(x2))
        self.y = (float(y0), float(y1), float(y2))
        self.r = float(r)

    def __str__(self):
        return "InfiniteCylinder from x = %s to y = %s with radius %s" % \
            (str(self.x), str(self.y), str(self.r))

    def _write(self, prefix):
        x = self.x
        y = self.y
        r = self.r
        return "solid %s = cylinder(%g, %g, %g; %g, %g, %g; %g);" % \
            (prefix, x[0], x[1], x[2], y[0], y[1], y[2], r)

class Cylinder(Primitive):

    # The non-infinite cylinder class is constructed from other
    # primitives but needs to be a class so we can can rotate it. The
    # logic for building the cylinder from other primitives is instead
    # handled in the _write function. An alternative approach is to
    # define a function instead of a class as is done for some of the
    # other geometric objects.

    def __init__(self, x0, x1, x2, y0, y1, y2, r):
        "A cylinder from x to y with radius r"

        self.x = (float(x0), float(x1), float(x2))
        self.y = (float(y0), float(y1), float(y2))
        self.r = r

    def __str__(self):
        return "Cylinder from x = %s to y = %s with radius %s" % \
            (str(self.x), str(self.y), str(self.r))

    def _write(self, prefix):
        x = self.x
        y = self.y
        r = self.r

        # Build cylinder from other primitives
        c = InfiniteCylinder(x[0], x[1], x[2], y[0], y[1], y[2], r)
        p0 = Plane(x[0], x[1], x[2], x[0] - y[0], x[1] - y[1], x[2] - y[2])
        p1 = Plane(y[0], y[1], y[2], y[0] - x[0], y[1] - x[1], y[2] - x[2])

        # Add definitions for primitives
        s = c._write(prefix + "_0")  + "\n" + \
            p0._write(prefix + "_1") + "\n" + \
            p1._write(prefix + "_2")

        # Add definition for composite object
        s += "\nsolid %s = %s_0 and %s_1 and %s_2;" % \
            (prefix, prefix, prefix, prefix)

        return s

    def rotate(self, angle, axis):
        "Rotate given angle / degrees around given axis through center of mass"

        # Compute center of mass
        c = 0.5 * (numpy.array(self.x) + numpy.array(self.y))

        # Rotate points
        self.x = _rotate(self.x, c, angle, axis)
        self.y = _rotate(self.y, c, angle, axis)

class Sphere(Primitive):

    def __init__(self, x0, x1, x2, r):
        "A sphere at x with radius r"

        Primitive.__init__(self)

        self.x = (float(x0), float(x1), float(x2))
        self.r = r

    def __str__(self):
        return "Sphere at x = %s with radius %s" % \
            (str(self.x), str(self.r))

    def _write(self, prefix):
        x = self.x
        r = self.r
        return "solid %s = sphere(%g, %g, %g; %g);" % \
            (prefix, x[0], x[1], x[2], r)

class Polyhedron(Primitive):

    def __init__(self, points, triangles):
        """A polyhedron defined by a surface. Triangles must be
        oriented counter-clockwise when viewed from the outside."""

        Primitive.__init__(self)

        self.points = points
        self.triangles = triangles

    def __str__(self):
        return "Polyhedron with %d points and %d triangles" % \
            (len(self.points), len(self.triangles))

    def _write(self, prefix):
        points = self.points
        triangles = self.triangles
        return "solid %s = polyhedron(%s;; %s);" % \
            (prefix,
             "; ".join(", ".join(str(pii) for pii in pi) for pi in points),
             "; ".join(", ".join(str(tii + 1) for tii in ti) for ti in triangles))

    def rotate(self, angle, axis):
        "Rotate given angle / degrees around given axis through center of mass"

        # Compute center of mass
        c = sum(numpy.array(p) for p in self.points) / float(len(self.points))

        # Rotate points
        self.points = tuple(_rotate(x, c, angle, axis) for x in self.points)

class Brick(Primitive):

    def __init__(self, x0, x1, x2, y0, y1, y2):
        "A brick with opposite corners x and y"

        Primitive.__init__(self)

        self.x = (float(x0), float(x1), float(x2))
        self.y = (float(y0), float(y1), float(y2))

    def __str__(self):
        return "Brick with corners x = %s and y = %s" % \
            (str(self.x), str(self.y))

    def _write(self, prefix):
        x = self.x
        y = self.y
        return "solid %s = orthobrick(%g, %g, %g; %g, %g, %g);" % \
            (prefix, x[0], x[1], x[2], y[0], y[1], y[2])

# Note: This is a function, not a class. See comment in Cylinder class.
def Box(x0, x1, x2, y0, y1, y2):
    """A box with opposite corners x and y. This differs from a
    brick in that it is constructed as a polyhedron and can be
    rotated."""

    # FIXME: Handle boxes where xi < yi is not required
    if x0 >= y0 or x1 >= y1 or x2 >= y2:
        cpp.error("Coordinates for box must be increasing for each axis.")

    # Create triangulation of box surface

    x = numpy.array((x0, x1, x2))
    y = numpy.array((y0, y1, y2))

    dx0 = numpy.array((y[0] - x[0], 0, 0))
    dx1 = numpy.array((0, y[1] - x[1], 0))
    dx2 = numpy.array((0, 0, y[2] - x[2]))

    points = (x, x + dx0, x + dx0 + dx1, x + dx1,
              x + dx2, x + dx0 + dx2, x + dx0 + dx1 + dx2, x + dx1 + dx2)

    triangles = ((0, 1, 5), (0, 5, 4),
                 (1, 2, 6), (1, 6, 5),
                 (2, 3, 7), (2, 7, 6),
                 (3, 0, 4), (3, 4, 7),
                 (3, 2, 1), (3, 1, 0),
                 (4, 5, 6), (4, 6, 7))

    return Polyhedron(points, triangles)

class OpenCone(Primitive):
    "An open cone from x to y with radii rx and ry"

    def __init__(self, x0, x1, x2, y0, y1, y2, rx, ry):

        Primitive.__init__(self)

        self.x = (float(x0), float(x1), float(x2))
        self.y = (float(y0), float(y1), float(y2))
        self.rx = float(rx)
        self.ry = float(ry)

    def __str__(self):
        return "OpenCone from x = %s to y = %s with radii rx = %s and ry = %s" % \
            (str(self.x), str(self.y), str(self.rx), str(self.ry))

    def _write(self, prefix):
        x = self.x
        y = self.y
        rx = self.rx
        ry = self.ry
        return "solid %s = cone(%g, %g, %g; %g; %g, %g, %g; %g);" % \
            (prefix, x[0], x[1], x[2], rx, y[0], y[1], y[2], ry)

# Note: This is a function, not a class. See comment in Cylinder class.
def Cone(x0, x1, x2, y0, y1, y2, rx, ry):
    "A cone from x to y with radii rx and ry"

    cone = OpenCone(x0, x1, x2, y0, y1, y2, rx, ry)
    p0 = Plane(x0, x1, x2, x0 - y0, x1 - y1, x2 - y2)
    p1 = Plane(y0, y1, y2, y0 - x0, y1 - x1, y2 - x2)

    return cone * p0 * p1

# Note: This is a function, not a class. See comment in Cylinder class.
def LEGO(n0, n1, n2=1, x0=0.0, x1=0.0, x2=0.0):
    """A standard LEGO brick starting at the point x with (n0, n1)
    knobs and height n2. The height should be 1 for a thin brick or 3
    for a regular brick."""

    # Standard dimensions for LEGO bricks / mm
    P = 8.0
    h = 3.2
    D = 5.0
    b = 1.7
    d = 0.2

    # Create brick
    lego = Brick(x0 + 0.5*d, x1 + 0.5*d, x2,
                 x0 + n0*P - 0.5*d, x1 + n1*P - 0.5*d, x2 + n2*h)

    # Add knobs
    for i in range(n0):
        for j in range(n1):
            x = x0 + (i + 0.5)*P
            y = x1 + (j + 0.5)*P
            z = x2
            knob = Cylinder(x, y, z,
                            x, y, z + n2*h + b,
                            0.5*D)
            lego = lego + knob

    return lego
