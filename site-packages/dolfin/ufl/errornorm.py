"""This module provides a simple way to compute the norm of the
difference between two given functions. It can be used to evaluate the
error of a given approximate solution when the exact solution is
known. In simple cases, one may just define

  e = u - uh

and evalute for example the square of the error in the L2 norm by

  e = u - uh
  assemble(e*e*dx, mesh)

However, this is not stable w.r.t. round-off errors considering that
the form compiler will expand the expression above to

  u*u*dx + uh*uh*dx - 2*u*uh*dx

and this might get further expanded into thousands of terms for
higher order elements. Thus, the error will be evaluated by adding
a large number of terms which should sum up to something close to
zero (if the error is small).

This module computes the error by first interpolating both u and uh
to a common space (of high accuracy), then subtracting the two fields
(which is easy since they are expressed in the same basis) and then
evaluating the integral."""

__author__ = "Anders Logg (logg@simula.no)"
__date__ = "2008-09-22 -- 2008-10-06"
__copyright__ = "Copyright (C) 2008 Anders Logg"
__license__  = "GNU LGPL Version 2.1"

__all__ = ["errornorm"]

from ufl import FiniteElement, VectorElement
from cpp import error, Vector
from interpolate import interpolate
from norm import norm
from function import Function
from functionspace import FunctionSpace, VectorFunctionSpace

dim_to_shape = {1: "interval", 2: "triangle", 3: "tetrahedron"}

def errornorm(u, uh, normtype="L2", degree=3):
    """Compute the error e = u - uh in the given norm. The parameter k
    denotes the degree of accuracy (degree of piecewise polynomials
    approximating u an uh)."""

    print "Computing error"

    # Get rank
    if not u.value_rank() == uh.value_rank():
        error("Unable to compute error, functions have different rank.")
    rank = u.value_rank()

    # Get mesh
    if not id(u.function_space().mesh()) == id(uh.function_space().mesh()):
        error("Unable to compute error, functions defined on different meshes.")
    mesh = u.function_space().mesh()

    # Get shape
    shape = dim_to_shape[mesh.topology().dim()]

    # Create function space
    if rank == 0:
        V = FunctionSpace(mesh, "Discontinuous Lagrange", degree)
    elif rank == 1:
        V = VectorFunctionSpace(mesh, "Discontinuous Lagrange", degree)
    else:
        error("Unable to compute error, can't handle elements of rank %d." % rank)

    # Interpolate functions into finite element space
    Pu  = interpolate(u,  V)
    Puh = interpolate(uh, V)

    # Compute the difference
    e = Function(V)
    e.assign(Pu)
    x = e.vector().axpy(-1.0, Puh.vector())

    # Compute norm
    return norm(e, normtype)
