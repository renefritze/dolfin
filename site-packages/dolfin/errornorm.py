"""This module provides a simple way to compute the norm of the
difference between two given functions. It can be used to evaluate the
error of a given approximate solution when the exact solution is
known. In simple cases, one may just define

  e = u - uh

and evalute for example the square of the error in the L2 norm by

  e = u - uh
  assemble(e*e*dx, mesh)

However, this is not stable w.r.t. round-off errors considering that
the form compiler will expand the expression above to

  u*u*dx + uh*uh*dx - 2*u*uh*dx

and this might get further expanded into thousands of terms for
higher order elements. Thus, the error will be evaluated by adding
a large number of terms which should sum up to something close to
zero (if the error is small).

This module computes the error by first projecting both u and uh
to a common space (of high accuracy), then subtracting the two fields
(which is easy since they are expressed in the same basis) and then
evaluating the integral."""

__author__ = "Anders Logg (logg@simula.no)"
__date__ = "2008-09-22 -- 2008-10-01"
__copyright__ = "Copyright (C) 2008 Anders Logg"
__license__  = "GNU LGPL Version 2.1"

__all__ = ["errornorm"]

from ffc import FiniteElement, VectorElement
from dolfin import error, Vector
from project import project
from norm import norm
from function import Function

dim_to_shape = {1: "interval", 2: "triangle", 3: "tetrahedron"}

def errornorm(u, uh, normtype="L2", degree=3):
    """Compute the error e = u - uh in the given norm. The parameter k
    denotes the degree of accuracy (degree of piecewise polynomials
    approximating u an uh)."""

    print "Computing error"

    # Get rank
    if not u.rank() == uh.rank():
        error("Unable to compute error, function have different rank.")
    rank = u.rank()

    # Get mesh
    if not id(u.mesh()) == id(uh.mesh()):
        error("Unable to compute error, functions defined on different meshes.")
    mesh = u.mesh()

    # Get shape
    shape = dim_to_shape[mesh.topology().dim()]

    # Create element
    if rank == 0:
        element = FiniteElement("Discontinuous Lagrange", shape, degree)
    elif rank == 1:
        element = VectorElement("Discontinuous Lagrange", shape, degree)
    else:
        error("Unable to compute error, can't handle elements of rank %d." % rank)

    # Project functions onto finite element space
    Pu  = project(u,  element)
    Puh = project(uh, element)

    # Compute the difference
    e = Function(element, mesh, Vector())
    e.assign(Pu)
    x = e.vector().axpy(-1.0, Puh.vector())

    # Compute norm
    return norm(e, mesh, normtype)
