"""Docstrings for all DOLFIN classes which are generated by Swig.

The contents is organised in three sections all sorted in alphabetical order
if possible.
As an example the cGqMethod derives from Method which derives from Variable.
Variable derives from 'object' so it is located in the first section. Method
is located in the second section right after Mesh (which also derives from
Variable). cGqMethod which is a child class and should be located before Method
when sorting alphabetically is located immediately after Method (the first
position where it can possibly be defined).

  1) Parent classes (which only derives from 'object').
  2) Child classes which derives from the parent classes
  3) Functions defined in the cpp.py namespace.

  Swig helper functions are not documented.
"""

import ufc

# Section 1. Parent classes sorted alphabetically.
class Assembler(object):
    """
    This class provides automated assembly of linear systems, or more
    generally, assembly of a sparse tensor from a given variational form.

    The MeshFunction arguments can be used to specify assembly over
    subdomains of the mesh cells, exterior facets or interior facets.
    Either a null pointer or an empty MeshFunction may be used to specify
    that the tensor should be assembled over the entire set of cells or
    facets.

    C++ includes: Assembler.h 
    """

    def assemble(*args):
        """
        assemble(GenericTensor A, Form a, bool reset_sparsity = True, 
            bool add_values = False)
        assemble(GenericTensor A, Form a, bool reset_sparsity = True)
        assemble(GenericTensor A, Form a)
        assemble(GenericTensor A, Form a, SubDomain sub_domain, bool reset_sparsity = True, 
            bool add_values = False)
        assemble(GenericTensor A, Form a, SubDomain sub_domain, bool reset_sparsity = True)
        assemble(GenericTensor A, Form a, SubDomain sub_domain)
        assemble(GenericTensor A, Form a, MeshFunctionUInt cell_domains, 
            MeshFunctionUInt exterior_facet_domains, 
            MeshFunctionUInt interior_facet_domains, bool reset_sparsity = True, 
            bool add_values = False)
        assemble(GenericTensor A, Form a, MeshFunctionUInt cell_domains, 
            MeshFunctionUInt exterior_facet_domains, 
            MeshFunctionUInt interior_facet_domains, bool reset_sparsity = True)
        assemble(GenericTensor A, Form a, MeshFunctionUInt cell_domains, 
            MeshFunctionUInt exterior_facet_domains, 
            MeshFunctionUInt interior_facet_domains)
        """

    def __init__(self): 
        """__init__(self) -> Assembler"""

class ConstDoubleArray(object):
    """
    This class provides a simple wrapper for a pointer to an array. A
    purpose of this class is to enable the simple and safe exchange of
    data between C++ and Python.

    C++ includes: Array.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> ConstDoubleArray
        __init__(self, uint N) -> ConstDoubleArray

        Construct array from a pointer. Array will not take ownership. 
        """

    def update(self, *args):
        """
        update(self, uint N, double _x)

        Construct array from a pointer. Array will not take ownership. 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). Note that the
        Array class is not a subclass of Variable (for efficiency) which means
        that one needs to call str() directly instead of using the info()
        function on Array objects. 
        """

    def size(self):
        """
        size(self) -> uint

        Return size of array. 
        """

    def zero_eps(self, eps = 3.0e-16):
        """
        zero_eps(self, double eps = 3.0e-16)
        zero_eps(self)
        """

    def min(self):
        """
        min(self) -> double

        Return minimum value of array. 
        """

    def max(self):
        """
        max(self) -> double

        Return maximum value of array. 
        """

    def data(self, *args):
        """
        data(self) -> boost::shared_array<(q(const).double)>
        data(self) -> boost::shared_array<(q(const).double)>

        Return pointer to data (non-const version). 
        """

    def __getitem__(self, *args):
        """__getitem__(self, unsigned int i) -> double"""

class DoubleArray(object):
    """
    This class provides a simple wrapper for a pointer to an array. A
    purpose of this class is to enable the simple and safe exchange of
    data between C++ and Python.

    C++ includes: Array.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> DoubleArray
        __init__(self, uint N) -> DoubleArray
        __init__(self, uint N) -> DoubleArray

        Construct array from a pointer. Array will not take ownership. 
        """

    def update(self, *args):
        """
        update(self, uint N, double _x)

        Construct array from a pointer. Array will not take ownership. 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). Note that the
        Array class is not a subclass of Variable (for efficiency) which means
        that one needs to call str() directly instead of using the info()
        function on Array objects. 
        """

    def resize(self, *args):
        """
        resize(self, uint N)

        Resize array to size N. If size changes, contents will be destroyed.

        """

    def size(self):
        """
        size(self) -> uint

        Return size of array. 
        """

    def zero(self):
        """
        zero(self)

        Zero array. 
        """

    def zero_eps(self, eps = 3.0e-16):
        """
        zero_eps(self, double eps = 3.0e-16)
        zero_eps(self)
        """

    def min(self):
        """
        min(self) -> double

        Return minimum value of array. 
        """

    def max(self):
        """
        max(self) -> double

        Return maximum value of array. 
        """

    def data(self, *args):
        """
        data(self) -> boost::shared_array<(double)>
        data(self) -> boost::shared_array<(double)>

        Return pointer to data (non-const version). 
        """

    def __getitem__(self, *args):
        """__getitem__(self, unsigned int i) -> double"""

    def __setitem__(self, *args):
        """__setitem__(self, unsigned int i, double val)"""

    def array(self):
        """array(self) -> PyObject"""

class File(object):
    """
    A File represents a data file for reading and writing objects. Unless
    specified explicitly, the format is determined by the file name
    suffix. A list of objects that can be read/written to file can be
    found in GenericFile.h

    C++ includes: File.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, string filename, string encoding = "ascii") -> File
        __init__(self, string filename) -> File
        __init__(self, string filename, Type type, string encoding = "ascii") -> File
        __init__(self, string filename, Type type) -> File
        __init__(self, std::ostream outstream) -> File

        Create a outfile object writing to stream. 
        """

    def exists(*args):
        """exists(string filename) -> bool"""

    def __rshift__(self, *args):
        """
        __rshift__(self, GenericVector t)
        __rshift__(self, GenericMatrix t)
        __rshift__(self, Mesh t)
        __rshift__(self, LocalMeshData t)
        __rshift__(self, MeshFunctionInt t)
        __rshift__(self, MeshFunctionUInt t)
        __rshift__(self, MeshFunctionDouble t)
        __rshift__(self, MeshFunctionBool t)
        __rshift__(self, Sample t)
        __rshift__(self, Parameters t)
        __rshift__(self, FunctionPlotData t)
        """

    def __lshift__(self, *args):
        """
        __lshift__(self, Function u)
        __lshift__(self, std::pair<(p.q(const).dolfin::Function,double)> u)
        __lshift__(self, GenericVector t)
        __lshift__(self, GenericMatrix t)
        __lshift__(self, Mesh t)
        __lshift__(self, LocalMeshData t)
        __lshift__(self, MeshFunctionInt t)
        __lshift__(self, MeshFunctionUInt t)
        __lshift__(self, MeshFunctionDouble t)
        __lshift__(self, MeshFunctionBool t)
        __lshift__(self, Sample t)
        __lshift__(self, Parameters t)
        __lshift__(self, FunctionPlotData t)
        """

class Form(object):
    """
    Base class for UFC code generated by FFC for DOLFIN with option -l.

    C++ includes: Form.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, uint rank, uint num_coefficients) -> Form
        __init__(self, form ufc_form, std::vector<(p.q(const).dolfin::FunctionSpace)> function_spaces, 
            std::vector<(p.q(const).dolfin::GenericFunction)> coefficients) -> Form

        Create form (constructor used from Python interface). 
        """

    def rank(self):
        """
        rank(self) -> uint

        Return rank of form (bilinear form = 2, linear form = 1, functional =
        0, etc). 
        """

    def num_coefficients(self):
        """
        num_coefficients(self) -> uint

        Return number of coefficients. 
        """

    def set_mesh(self, *args):
        """
        set_mesh(self, Mesh mesh)
        set_mesh(self, __dummy_37__ mesh)

        Set mesh, necessary for functionals when there are no function spaces.

        """

    def mesh(self):
        """
        mesh(self) -> Mesh

        Return mesh. 
        """

    def function_space(self, *args):
        """
        function_space(self, uint i) -> __dummy_19__

        Return function space for given argument. 
        """

    def function_spaces(self):
        """
        function_spaces(self) -> std::vector<(boost::shared_ptr<(q(const).dolfin::FunctionSpace)>)>

        Return function spaces for arguments. 
        """

    def set_coefficient(self, *args):
        """
        set_coefficient(self, uint i, GenericFunction coefficient)
        set_coefficient(self, uint i, __dummy_23__ coefficient)
        set_coefficient(self, string name, GenericFunction coefficient)
        set_coefficient(self, string name, __dummy_23__ coefficient)

        Set coefficient with given name (shared pointer version). 
        """

    def set_coefficients(self, *args):
        """
        set_coefficients(self, std::map<(std::string,p.q(const).dolfin::GenericFunction)> coefficients)
        set_coefficients(self, std::map<(std::string,boost::shared_ptr<(q(const).dolfin::GenericFunction)>)> coefficients)

        Set all coefficients in given map, possibly a subset (shared pointer
        version). 
        """

    def coefficient(self, *args):
        """
        coefficient(self, uint i) -> GenericFunction
        coefficient(self, string name) -> GenericFunction

        Return coefficient with given name. 
        """

    def coefficients(self):
        """
        coefficients(self) -> std::vector<(p.q(const).dolfin::GenericFunction)>

        Return all coefficients. 
        """

    def coefficient_number(self, *args):
        """
        coefficient_number(self, string name) -> uint

        Return the number of the coefficient with this name. 
        """

    def coefficient_name(self, *args):
        """
        coefficient_name(self, uint i) -> string

        Return the name of the coefficient with this number. 
        """

    def ufc_form(self):
        """
        ufc_form(self) -> form

        Return UFC form. 
        """

    def check(self):
        """
        check(self)

        Check function spaces and coefficients. 
        """

class NonlinearProblem(object):
    """
    This is a base class for nonlinear problems which can return the
    nonlinear function F(u) and its Jacobian J = dF(u)/du.

    C++ includes: NonlinearProblem.h 
    """

    def __init__(self): 
        """
        __init__(self) -> NonlinearProblem

        Constructor. 
        """

    def form(self, *args):
        """
        form(self, GenericMatrix A, GenericVector b, GenericVector x)

        Function called by Newton solver before requesting F or J. This can be
        used to compute F and J together 
        """

    def F(self, *args):
        """
        F(self, GenericVector b, GenericVector x)

        Compute F at current point x. 
        """

    def J(self, *args):
        """
        J(self, GenericMatrix A, GenericVector x)

        Compute J = F' at current point x. 
        """

    def __disown__(self):
        """Missing docstring"""

class ODECollection(object):
    """
    An ODECollection represents a collection of initial value problems of
    the form

    u'(t) = f(u(t), t) on (0, T],

    u(0) = u0,

    where u(t) is a vector of length N.

    Each ODE is governed by the same equation but a separate state is
    maintained for each ODE. Using ODECollection is recommended when
    solving a large number of ODEs and the overhead of instantiating a
    large number of ODE objects should be avoided.

    C++ includes: ODECollection.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, ODE ode, uint num_systems) -> ODECollection

        Create a collection of ODEs. 
        """

    def solve(self, *args):
        """
        solve(self, real t0, real t1)

        Solve ODE collection on [t0, t1]. 
        """

    def set_state(self, *args):
        """
        set_state(self, uint system, real u)
        set_state(self, real u)

        Set states for all ODE systems. 
        """

    def get_state(self, *args):
        """
        get_state(self, uint system, real u)
        get_state(self, real u)

        Get states for all ODE systems. 
        """

    def update(self, *args):
        """
        update(self, real u, real t, uint system)

        Optional user-defined update, called between solves. 
        """

class ODESolution(object):
    """Proxy of C++ dolfin::ODESolution class"""

    def __init__(self, *args): 
        """
        __init__(self) -> ODESolution
        __init__(self, string filename, uint number_of_files = 1) -> ODESolution
        __init__(self, string filename) -> ODESolution
        """

    def init(self, *args):
        """init(self, uint N, Lagrange trial, real quad_weights)"""

    def add_timeslab(self, *args):
        """add_timeslab(self, real a, real b, real values)"""

    def flush(self):
        """
        flush(self)

        Make object ready for evaluating, set to read mode. 
        """

    def eval(self, *args):
        """
        eval(self, real t, real y)

        Evaluate (interpolate) value of solution at given time. 
        """

    def get_timeslab(self, *args):
        """
        get_timeslab(self, uint index) -> ODESolutionData

        Get timeslab (used when iterating). 
        """

    def get_weights(self):
        """
        get_weights(self) -> real

        Get pointer to weights. 
        """

    def set_filename(self, *args):
        """set_filename(self, string filename)"""

    def save_to_file(self):
        """save_to_file(self)"""

    def str(self, *args):
        """str(self, bool verbose) -> string"""

    def size(self):
        """size(self) -> uint"""

    def nsize(self):
        """nsize(self) -> uint"""

    def endtime(self):
        """endtime(self) -> real"""

    def begin(self):
        """begin(self) -> iterator"""

    def end(self):
        """end(self) -> iterator"""

class ODESolutionData(object):
    """Proxy of C++ dolfin::ODESolutionData class"""

    def __init__(self, *args): 
        """
        __init__(self, real a, real k, uint nodal_size, uint N, real values) -> ODESolutionData
        __init__(self, ODESolutionData cp) -> ODESolutionData
        """

    def b(self):
        """b(self) -> real"""

    def eval_a(self, *args):
        """eval_a(self, real u)"""

class ODESolutionIterator(object):
    """Proxy of C++ dolfin::ODESolutionIterator class"""

    def __init__(self, *args): 
        """
        __init__(self, ODESolution u) -> ODESolutionIterator
        __init__(self, ODESolution u, int index) -> ODESolutionIterator
        __init__(self, ODESolutionIterator it) -> ODESolutionIterator
        """

    def get_index(self):
        """get_index(self) -> uint"""

    def get_ODESolution(self):
        """get_ODESolution(self) -> ODESolution"""

    def __eq__(self, *args):
        """__eq__(self, ODESolutionIterator rhs) -> bool"""

    def __ne__(self, *args):
        """__ne__(self, ODESolutionIterator rhs) -> bool"""

    def __ref__(self):
        """__ref__(self) -> ODESolutionData"""

class Point(object):
    """
    A Point represents a point in R^3 with coordinates x, y, z, or,
    alternatively, a vector in R^3, supporting standard operations like
    the norm, distances, scalar and vector products etc.

    C++ includes: Point.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, double x = 0.0, double y = 0.0, double z = 0.0) -> Point
        __init__(self, double x = 0.0, double y = 0.0) -> Point
        __init__(self, double x = 0.0) -> Point
        __init__(self) -> Point
        __init__(self, uint dim, double x) -> Point
        __init__(self, Point p) -> Point

        Copy constructor. 
        """

    def x(self):
        """
        x(self) -> double

        Return x-coordinate. 
        """

    def y(self):
        """
        y(self) -> double

        Return y-coordinate. 
        """

    def z(self):
        """
        z(self) -> double

        Return z-coordinate. 
        """

    def coordinates(self):
        """
        coordinates(self) -> double

        Return coordinate array. 
        """

    def __add__(self, *args):
        """__add__(self, Point p) -> Point"""

    def __sub__(self, *args):
        """__sub__(self, Point p) -> Point"""

    def __iadd__(self, *args):
        """__iadd__(self, Point p) -> Point"""

    def __isub__(self, *args):
        """__isub__(self, Point p) -> Point"""

    def __mul__(self, *args):
        """__mul__(self, double a) -> Point"""

    def __imul__(self, *args):
        """__imul__(self, double a) -> Point"""

    def __div__(self, *args):
        """__div__(self, double a) -> Point"""

    def __idiv__(self, *args):
        """__idiv__(self, double a) -> Point"""

    def distance(self, *args):
        """
        distance(self, Point p) -> double

        Compute distance to given point. 
        """

    def norm(self):
        """
        norm(self) -> double

        Compute norm of point representing a vector from the origin. 
        """

    def cross(self, *args):
        """
        cross(self, Point p) -> Point

        Compute cross product with given vector. 
        """

    def dot(self, *args):
        """
        dot(self, Point p) -> double

        Compute dot product with given vector. 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). 
        """

    def __getitem__(self, *args):
        """__getitem__(self, int i) -> double"""

    def __setitem__(self, *args):
        """__setitem__(self, int i, double val)"""

class StabilityAnalysis(object):
    """Proxy of C++ dolfin::StabilityAnalysis class"""

    def __init__(self, *args): 
        """
        __init__(self, ODE ode, ODESolution u) -> StabilityAnalysis

        Constructor. 
        """

    def analyze_integral(self, *args):
        """
        analyze_integral(self, uint q)

        Compute the integral of the q'th derivative of the dual as function of
        (primal) endtime T. 
        """

    def analyze_endpoint(self):
        """
        analyze_endpoint(self)

        Compute z(0) (the endpoint of the dual) as function of (primal)
        endtime T. 
        """

class SystemAssembler(object):
    """
    This class provides implements an assembler for systems of the form Ax
    = b. It differs from the default DOLFIN assembler in that it assembles
    both A and b and the same time (leading to better performance) and in
    that it applies boundary conditions at the time of assembly.

    C++ includes: SystemAssembler.h 
    """

    def assemble(*args):
        """
        assemble(GenericMatrix A, GenericVector b, Form a, Form L, bool reset_sparsity = True, 
            bool add_values = False)
        assemble(GenericMatrix A, GenericVector b, Form a, Form L, bool reset_sparsity = True)
        assemble(GenericMatrix A, GenericVector b, Form a, Form L)
        assemble(GenericMatrix A, GenericVector b, Form a, Form L, DirichletBC bc, 
            bool reset_sparsity = True, bool add_values = True)
        assemble(GenericMatrix A, GenericVector b, Form a, Form L, DirichletBC bc, 
            bool reset_sparsity = True)
        assemble(GenericMatrix A, GenericVector b, Form a, Form L, DirichletBC bc)
        assemble(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
            bool reset_sparsity = True, 
            bool add_values = False)
        assemble(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
            bool reset_sparsity = True)
        assemble(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs)
        assemble(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
            MeshFunctionUInt cell_domains, 
            MeshFunctionUInt exterior_facet_domains, 
            MeshFunctionUInt interior_facet_domains, 
            GenericVector x0, 
            bool reset_sparsity = True, bool add_values = False)
        assemble(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
            MeshFunctionUInt cell_domains, 
            MeshFunctionUInt exterior_facet_domains, 
            MeshFunctionUInt interior_facet_domains, 
            GenericVector x0, 
            bool reset_sparsity = True)
        assemble(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
            MeshFunctionUInt cell_domains, 
            MeshFunctionUInt exterior_facet_domains, 
            MeshFunctionUInt interior_facet_domains, 
            GenericVector x0)
        """

    def __init__(self): 
        """__init__(self) -> SystemAssembler"""

class Timer(object):
    """
    A timer can be used for timing tasks. The basic usage is

    Timer timer("Assembling over cells");

    The timer is started at construction and timing ends when the timer is
    destroyed (goes out of scope). It is also possible to start and stop a
    timer explicitly by

    timer.start(); timer.stop();

    Timings are stored globally and a summary may be printed by calling

    summary();

    C++ includes: Timer.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, string task) -> Timer

        Create timer. 
        """

    def start(self):
        """
        start(self)

        Start timer. 
        """

    def stop(self):
        """
        stop(self)

        Stop timer. 
        """

    def value(self):
        """
        value(self) -> double

        Return value of timer (or time at start if not stopped). 
        """

class UIntArray(object):
    """
    This class provides a simple wrapper for a pointer to an array. A
    purpose of this class is to enable the simple and safe exchange of
    data between C++ and Python.

    C++ includes: Array.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> UIntArray
        __init__(self, uint N) -> UIntArray
        __init__(self, uint N) -> UIntArray

        Construct array from a pointer. Array will not take ownership. 
        """

    def update(self, *args):
        """
        update(self, uint N, unsigned int _x)

        Construct array from a pointer. Array will not take ownership. 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). Note that the
        Array class is not a subclass of Variable (for efficiency) which means
        that one needs to call str() directly instead of using the info()
        function on Array objects. 
        """

    def resize(self, *args):
        """
        resize(self, uint N)

        Resize array to size N. If size changes, contents will be destroyed.

        """

    def size(self):
        """
        size(self) -> uint

        Return size of array. 
        """

    def zero(self):
        """
        zero(self)

        Zero array. 
        """

    def zero_eps(self, eps = 3.0e-16):
        """
        zero_eps(self, double eps = 3.0e-16)
        zero_eps(self)
        """

    def min(self):
        """
        min(self) -> unsigned int

        Return minimum value of array. 
        """

    def max(self):
        """
        max(self) -> unsigned int

        Return maximum value of array. 
        """

    def data(self, *args):
        """
        data(self) -> boost::shared_array<(unsigned int)>
        data(self) -> boost::shared_array<(unsigned int)>

        Return pointer to data (non-const version). 
        """

    def __getitem__(self, *args):
        """__getitem__(self, unsigned int i) -> unsigned int"""

    def __setitem__(self, *args):
        """__setitem__(self, unsigned int i, unsigned int val)"""

    def array(self):
        """array(self) -> PyObject"""

class Variable(object):
    """
    Common base class for DOLFIN variables.

    C++ includes: Variable.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> Variable
        __init__(self, string name, string label) -> Variable

        Create variable with given name and label. 
        """

    def rename(self, *args):
        """
        rename(self, string name, string label)

        Rename variable. 
        """

    def name(self):
        """
        name(self) -> string

        Return name. 
        """

    def label(self):
        """
        label(self) -> string

        Return label (description). 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). 
        """

    def disp(self):
        """
        .. warning::

            Deprecated, to be removed.
        """

    def __str__(self):
        """__str__(self) -> string"""

# -----------------------------------------------------------------------------
# Section 2. Child classes sorted alphabetically
class BoundaryCondition(Variable):
    """
    Common base class for boundary conditions.

    C++ includes: BoundaryCondition.h 
    """

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def apply(self, *args):
        """
        apply(self, GenericMatrix A)
        apply(self, GenericVector b)
        apply(self, GenericMatrix A, GenericVector b)
        apply(self, GenericVector b, GenericVector x)
        apply(self, GenericMatrix A, GenericVector b, GenericVector x)

        Apply boundary condition to a linear system for a nonlinear problem.

        """

    def _function_space(self):
        """
        _function_space(self) -> __dummy_19__

        Return shared pointer to function space. 
        """

    def function_space(self):
        """Return the FunctionSpace"""

class DirichletBC(BoundaryCondition):
    """
    This class specifies the interface for setting (strong).

    This class specifies the interface for setting (strong) Dirichlet
    boundary conditions for partial differential equations,

    u = g on G,

    where u is the solution to be computed, g is a function and G is a sub
    domain of the mesh.

    A DirichletBC is specified by the function g, the function space
    (trial space) and boundary indicators on (a subset of) the mesh
    boundary.

    The boundary indicators may be specified in a number of different
    ways.

    The simplest approach is to specify the boundary by a SubDomain
    object, using the inside() function to specify on which facets the
    boundary conditions should be applied.

    Alternatively, the boundary may be specified by a MeshFunction
    labeling all mesh facets together with a number that specifies which
    facets should be included in the boundary.

    The third option is to attach the boundary information to the mesh.
    This is handled automatically when exporting a mesh from for example
    VMTK.

    The BCMethod variable may be used to specify the type of method used
    to identify degrees of freedom on the boundary. Available methods are:
    topological approach (default), geometric approach, and pointwise
    approach. The topological approach is faster, but will only identify
    degrees of freedom that are located on a facet that is entirely on the
    boundary. In particular, the topological approach will not identify
    degrees of freedom for discontinuous elements (which are all internal
    to the cell). A remedy for this is to use the geometric approach. To
    apply pointwise boundary conditions e.g. pointloads, one will have to
    use the pointwise approach which in turn is the slowest of the three
    possible methods. The three possibilties are "topological",
    "geometric" and "pointwise".

    C++ includes: DirichletBC.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, __dummy_19__ V, __dummy_23__ g, __dummy_59__ sub_domain, 
            string method = "topological") -> DirichletBC
        __init__(self, __dummy_19__ V, __dummy_23__ g, __dummy_59__ sub_domain) -> DirichletBC
        __init__(self, __dummy_19__ V, __dummy_23__ g, MeshFunctionUInt sub_domains, 
            uint sub_domain, string method = "topological") -> DirichletBC
        __init__(self, __dummy_19__ V, __dummy_23__ g, MeshFunctionUInt sub_domains, 
            uint sub_domain) -> DirichletBC
        __init__(self, __dummy_19__ V, __dummy_23__ g, uint sub_domain, string method = "topological") -> DirichletBC
        __init__(self, __dummy_19__ V, __dummy_23__ g, uint sub_domain) -> DirichletBC
        __init__(self, FunctionSpace V, GenericFunction g, std::vector<(std::pair<(dolfin::uint,dolfin::uint)>)> markers, 
            string method = "topological") -> DirichletBC
        __init__(self, FunctionSpace V, GenericFunction g, std::vector<(std::pair<(dolfin::uint,dolfin::uint)>)> markers) -> DirichletBC
        __init__(self, __dummy_19__ V, __dummy_23__ g, std::vector<(std::pair<(dolfin::uint,dolfin::uint)>)> markers, 
            string method = "topological") -> DirichletBC
        __init__(self, __dummy_19__ V, __dummy_23__ g, std::vector<(std::pair<(dolfin::uint,dolfin::uint)>)> markers) -> DirichletBC
        __init__(self, DirichletBC bc) -> DirichletBC

        Copy constructor. 
        """

    def apply(self, *args):
        """
        apply(self, GenericMatrix A)
        apply(self, GenericVector b)
        apply(self, GenericMatrix A, GenericVector b)
        apply(self, GenericVector b, GenericVector x)
        apply(self, GenericMatrix A, GenericVector b, GenericVector x)

        Apply boundary condition to a linear system for a nonlinear problem.

        """

    def zero(self, *args):
        """
        zero(self, GenericMatrix A)

        Make row associated with boundary conditions zero, useful for non-
        diagonal matrices in a block matrix. 
        """

    def markers(self):
        """
        markers(self) -> std::vector<(std::pair<(dolfin::uint,dolfin::uint)>)>

        Return boundary markers (facets stored as pairs of cells and local
        facet numbers). 
        """

    def value(self):
        """
        value(self) -> GenericFunction

        Return boundary value g. 
        """

    def value_ptr(self):
        """
        value_ptr(self) -> __dummy_23__

        Return shared pointer to boundary value g Testing multiline comment 
        """

    def get_bc(self, *args):
        """
        get_bc(self, uint indicators, double values)

        Get Dirichlet values and indicators. 
        """

    def is_compatible(self, *args):
        """
        is_compatible(self, GenericFunction v) -> bool

        Check if given function is compatible with boundary condition
        (checking only vertex values). 
        """

    def set_value(self, *args):
        """
        set_value(self, GenericFunction g)
        set_value(self, __dummy_23__ g)

        Set value g for boundary condition, domain remains unchanged. 
        """

    def default_parameters():
        """default_parameters() -> Parameters"""

class EqualityBC(BoundaryCondition):
    """
    This class specifies the interface for setting equality boundary
    conditions for partial differential equations,

    u(x) = u(y), for all x and y on G,

    where G is subdomain of the mesh.

    The sub domain G may be specified in two different ways. Both of them
    produce a set of unknowns (dofs) with should be equal.

    The simplest approach is to specify a SubDomain object, using the
    inside() function to specify on which facets the boundary condition
    should be applied.

    Alternatively, the boundary may be specified by the boundary
    indicators included in the mesh.

    Current implementation assume that the problem is scalar, so in case
    of mixed systems (vector-valued and mixed elements) all compoments
    will be set equal.

    C++ includes: EqualityBC.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, FunctionSpace V, SubDomain sub_domain) -> EqualityBC
        __init__(self, __dummy_19__ V, SubDomain sub_domain) -> EqualityBC
        __init__(self, __dummy_19__ V, uint sub_domain) -> EqualityBC
        """

    def apply(self, *args):
        """
        apply(self, GenericMatrix A)
        apply(self, GenericVector b)
        apply(self, GenericMatrix A, GenericVector b)
        apply(self, GenericVector b, GenericVector x)
        apply(self, GenericMatrix A, GenericVector b, GenericVector x)

        Apply boundary condition to a linear system for a nonlinear problem.

        """

    def init_from_sub_domain(self, *args):
        """init_from_sub_domain(self, SubDomain sub_domain)"""

    def init_from_mesh(self, *args):
        """init_from_mesh(self, uint sub_domain)"""

class Mesh(Variable):
    """
    A Mesh consists of a set of connected and numbered mesh entities.

    Both the representation and the interface are dimension-independent,
    but a concrete interface is also provided for standard named mesh
    entities:

    .. tabularcolumns:: |c|c|c|

    +--------+-----------+-------------+
    | Entity | Dimension | Codimension |
    +========+===========+=============+
    | Vertex |  0        |             |
    +--------+-----------+-------------+
    | Edge   |  1        |             | 
    +--------+-----------+-------------+
    | Face   |  2        |             | 
    +--------+-----------+-------------+
    | Facet  |           |      1      |
    +--------+-----------+-------------+
    | Cell   |           |        0    |
    +--------+-----------+-------------+

    When working with mesh iterators, all entities and connectivity
    are precomputed automatically the first time an iterator is
    created over any given topological dimension or connectivity.

    Note that for efficiency, only entities of dimension zero
    (vertices) and entities of the maximal dimension (cells) exist
    when creating a Mesh. Other entities must be explicitly created
    by calling init().

    For example, all edges in a mesh may be created by a call to mesh.init(1).
    Similarly, connectivities such as all edges connected to a given vertex
    must also be explicitly created (in this case by a call to
    mesh.init(0, 1)).
    """

    def __init__(self, *args):
        """
        **Overloaded versions**

        * Mesh\ **()**

          Create empty mesh.

        * Mesh\ **(mesh)**

          Copy constructor.

          *Arguments*
              mesh
                  A :py:class:`Mesh` instance.

        * Mesh\ **(filename)**

          Create mesh from data file.

          *Arguments*
              filename
                  A string, name of file to load.
        """

    def num_vertices(self):
        """
        Get number of vertices in mesh.

        *Returns*
            integer
                Number of vertices.

        *Example*
            >>> mesh = dolfin.UnitSquare(2,2)
            >>> mesh.num_vertices()
            9
        """

    def num_edges(self):
        """
        Get number of edges in mesh.

        *Returns*
            integer
                Number of edges.


        *Example*
            >>> mesh = dolfin.UnitSquare(2,2)
            >>> mesh.num_edges()
            0
            >>> mesh.init(1)
            16
            >>> mesh.num_edges()
            16
        """

    def num_faces(self):
        """
        Get number of faces in mesh.

        *Returns*
            integer
                Number of faces.

        *Example*
            >>> mesh = dolfin.UnitSquare(2,2)
            >>> mesh.num_faces()
            8
        """

    def num_facets(self):
        """
        Get number of facets in mesh.

        *Returns*
            integer
                Number of facets.

        *Example*
            >>> mesh = dolfin.UnitSquare(2,2)
            >>> mesh.num_facets()
            0
            >>> mesh.init(0,1)
            >>> mesh.num_facets()
            16
        """

    def num_cells(self):
        """
        Get number of cells in mesh.

        *Returns*
            integer
                Number of cells.

        *Example*
            >>> mesh = dolfin.UnitSquare(2,2)
            >>> mesh.num_cells()
            8
        """

    def num_entities(self, d):
        """
        Get number of entities of given topological dimension.

        *Arguments*
            d
                An integer, topological dimension.

        *Returns*
            integer
                Number of entities of topological dimension d.

        *Example*
            >>> mesh = dolfin.UnitSquare(2,2)
            >>> mesh.init(0,1)
            >>> mesh.num_entities(0)
            9
            >>> mesh.num_entities(1)
            16
            >>> mesh.num_entities(2)
            8
        """

    def size(self, d):
        """
        Get number of entities of given topological dimension.

        *Arguments*
            d
                An integer, topological dimension.

        *Returns*
            integer
                Number of entities of topological dimension d.

        *Example*
            >>> mesh = dolfin.UnitSquare(2,2)
            >>> mesh.init(0,1)
            >>> mesh.num_entities(0)
            9
            >>> mesh.num_entities(1)
            16
            >>> mesh.num_entities(2)
            8
        """

    def topology(self):
        """
        *Returns*
            :py:class:`MeshTopology`
                The topology object associated with the mesh.
        """

    def geometry(self):
        """
        *Returns*
            :py:class:`MeshGeometry`
                The geometry object associated with the mesh.
        """

    def intersection_operator(self):
        """
        *Returns*
            :py:class:`IntersectionOperator`
                The intersection operator object associated with the mesh.
        """

    def data(self):
        """
        *Returns*
            :py:class:`MeshData`
                The mesh data object associated with the mesh.
        """

    def type(self):
        """
        *Returns*
            :py:class:`CellType`
                The cell type object associated with the mesh.
        """

    def init(self, *args):
        """
        Initialise mesh entities and connectivity.

        **Overloaded versions**

        * init\ **()**

          Compute all entities and connectivity.

        * init\ **(d)**

          Compute entities of given topological dimension.

          *Arguments*
              d
                  An integer, topological dimension.

          *Returns*
              integer
                  Number of created entities.

        * init\ **(d0, d1)**

          Compute connectivity between given pair of dimensions.

          *Arguments*
              d0
                  An integer, topological dimension.

              d1
                  An integer, topological dimension.
        """

    def clear(self):
        """
        Clear all mesh data. 
        """

    def order(self):
        """
        Order all mesh entities (not needed if 'mesh order entities' is
        set).

        .. seealso::

            UFC documentation (put link here!)
        """

    def ordered(self):
        """

        *Returns*
            bool
                Return True iff topology is ordered according to the UFC
                numbering.
        """

    def move(self, *args):
        """
        Move coordinates of Mesh.

        **Overloaded versions**

        * move\ **(boundary, method=hermite)**

          Move coordinates of mesh according to new boundary coordinates.

          *Arguments*
              boundary
                  A :py:class:`BoundaryMesh` instance.

              method
                  An :py:class:`ALEType` (enum).
                  Method which defines how the coordinates should be moved,
                  default is *hermite*.

        * move\ **(mesh, method=hermite)**

          Move coordinates of mesh according to adjacent mesh with common
          global vertices.

          *Arguments*
              mesh
                  A :py:class:`Mesh` instance.

              method
                  An :py:class:`ALEType` (enum).
                  Method which defines how the coordinates should be moved,
                  default is *hermite*.

        * move\ **(function)**

          Move coordinates of mesh according to displacement function. 

          *Arguments*
              function
                  A :py:class:`Function` instance.
        """

    def smooth(self, num_iterations = 1):
        """
        Smooth internal vertices of mesh by local averaging.

        *Arguments*
            num_iterations
                An integer, number of iterations to perform smoothing, default
                value is 1.
        """

    def smooth_boundary(self, num_iterations = 1, harmonic_smoothing = True):
        """
        Smooth boundary vertices of mesh by local averaging.

        *Arguments*
            num_iterations
                An integer, number of iterations to perform smoothing, default
                value is 1.

            harmonic_smoothing
                A bool, flag to turn on harmonics smoothing, default value is
                True.
        """

    def snap_boundary(self, sub_domain, harmonic_smoothing = True):
        """
        Snap boundary vertices of mesh to match given sub domain.

        *Arguments*
            sub_domain
                A :py:class:`SubDomain` instance.

            harmonic_smoothing
                A bool, flag to turn on harmonics smoothing, default value is
                True.
        """

    def all_intersected_entities(self, *args):
        """
        This function computes the cell ids of all cells of the current mesh
        which intersects with a given mesh entity. The result is stored in
        the last argument to the function which might be a vector or a set
        depending on which version is called.

        **Overloaded versions**

        * all_intersected_entities\ **(point, ids_result)**

          Compute all ids of all cells which are intersected by the given
          point.

          *Arguments*
              point
                  A :py:class:`Point` instance.

              ids_result
                  A set of integers.
                  The cell ids which are intersected are stored in a set for
                  efficiency reasons, to avoid to sort out duplicates later on.

        * all_intersected_entities\ **(points, ids_result)**

          Compute all ids of all cells which are intersected by any point in
          points.

          *Arguments*
              points
                  A list of :py:class:`Point` instances.

              ids_result
                  A set of integers.
                  The cell ids which are intersected are stored in a set for
                  efficiency reasons, to avoid to sort out duplicates later on.

        * all_intersected_entities\ **(entity, ids_result)**

          Compute all ids of all cells which are intersected by the given
          entity.

          *Arguments*
              entity
                  A :py:class:`MeshEntity` instance.

              ids_result
                  A list of integers.
                  The ids of the intersected cells are saved in a list. This is
                  more efficent than using a set and allows a map between the
                  (external) cell and the intersected cell of the mesh.

        * all_intersected_entities\ **(entities, ids_result)**

          Compute all id of all cells which are intersected by any entity in the
          list entities.

          *Arguments*
              entities
                  A list of :py:class:`MeshEntity` instances.

              ids_result
                  A set of integers.
                  The cell ids which are intersected are stored in a set for
                  efficiency reasons, to avoid to sort out duplicates later on.

        * all_intersected_entities\ **(another_mesh, ids_result)**

          Compute all ids of all cells which are intersected by another_mesh.

          *Arguments*
              another_mesh
                  A :py:class:`Mesh` instance.

              ids_result
                  A set of integers.
                  The cell ids which are intersected are stored in a set for
                  efficiency reasons, to avoid to sort out duplicates later on.
        """

    def any_intersected_entity(self, point):
        """
        Computes only the first id  of the entity, which contains the point.

        *Arguments*
            point
                A :py:class:`Point` instance.

        *Returns*
            integer
                The first id of the cell, which contains the point, returns -1
                if no cell is intersected.
        """

    def closest_point(self, point):
        """
        Computes the point inside the mesh which is closest to the point query.

        *Arguments*
            point
                A :py:class:`Point` instance.

        *Returns*
            :py:class:`Point`
                The point inside the mesh which is closest to the point.
        """

    def closest_cell(self, point):
        """
        Computes the index of the cell in the mesh which is closest to the
        point query.

        *Arguments*
            point
                A :py:class:`Point` instance.

        *Returns*
            integer
                The index of the cell in the mesh which is closest to point.

        *Example*
            >>> mesh = dolfin.UnitSquare(1,1)
            >>> point = dolfin.Point(0.0, 2.0)
            >>> mesh.closest_cell(point)
            1
        """

    def closest_point_and_cell(self, point):
        """
        Computes the point inside the mesh and the corresponding cell index
        which are closest to the point query.

        *Arguments*
            point
                A :py:class:`Point` instance.

        *Returns*
            std::pair<(dolfin::Point,dolfin::uint)>
                The point inside the mesh and the corresponding cell index
                which is closest to the point query.

        .. warning::

            Incomplete documentation: Don't know what the return value translates into.
        """

    def hmin(self):
        """
        Compute minimum cell diameter.

        *Returns*
            float
                The minimum cell diameter, the diameter is computed as two
                times the circumradius (http://mathworld.wolfram.com).

        *Example*
            >>> mesh = dolfin.UnitSquare(2,2)
            >>> mesh.hmin()
            0.70710678118654757
        """

    def hmax(self):
        """
        Compute maximum cell diameter.

        *Returns*
            float
                The maximum cell diameter, the diameter is computed as two
                times the circumradius (http://mathworld.wolfram.com).

        *Example*
            >>> mesh = dolfin.UnitSquare(2,2)
            >>> mesh.hmax()
            0.70710678118654757
        """

    def str(self, verbose):
        """
        Informal string representation.

        *Arguments*
            verbose
                A bool, flag to turn on additional output.

        *Returns*
            string
                An informal representation of the mesh.

        *Example*
            >>> mesh = dolfin.UnitSquare(2,2)
            >>> mesh.str(False)
            '<Mesh of topological dimension 2 (triangles) with 9 vertices and 8 cells, ordered>'
        """

    def coordinates(self):
        """
        *Returns*
            numpy.ndarray
                Coordinates of all vertices.

        *Example*
            >>> mesh = dolfin.UnitSquare(1,1)
            >>> mesh.coordinates()
            array([[ 0.,  0.],
                   [ 1.,  0.],
                   [ 0.,  1.],
                   [ 1.,  1.]])
        """

    def cells(self):
        """
        *Returns*
            numpy.ndarray
                Connectivity for all cells.

        *Example*
            >>> mesh = dolfin.UnitSquare(1,1)
            >>> mesh.coordinates()
            array([[0, 1, 3],
                   [0, 2, 3]])
        """

class Method(Variable):
    """
    Base class for cGqMethod and dGqMethod, which contain all numeric
    constants, such as nodal points and nodal weights, needed for the
    method.

    C++ includes: Method.h 
    """

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def type(self):
        """
        type(self) -> Type

        Return type (inline optimized). 
        """

    def degree(self):
        """
        degree(self) -> unsigned int

        Return degree (inline optimized). 
        """

    def order(self):
        """
        order(self) -> unsigned int

        Return order (inline optimized). 
        """

    def nsize(self):
        """
        nsize(self) -> unsigned int

        Return number of nodal points (inline optimized). 
        """

    def qsize(self):
        """
        qsize(self) -> unsigned int

        Return number of quadrature points (inline optimized). 
        """

    def npoint(self, *args):
        """
        npoint(self, unsigned int i) -> real

        Return nodal point (inline optimized). 
        """

    def qpoint(self, *args):
        """
        qpoint(self, unsigned int i) -> real

        Return quadrature point (inline optimized). 
        """

    def nweight(self, *args):
        """
        nweight(self, unsigned int i, unsigned int j) -> real

        Return nodal weight j for node i, including quadrature (inline
        optimized). 
        """

    def qweight(self, *args):
        """
        qweight(self, unsigned int i) -> real

        Return quadrature weight, including only quadrature (inline
        optimized). 
        """

    def eval(self, *args):
        """
        eval(self, unsigned int i, real tau) -> real

        Evaluation of trial space basis function i at given tau (inline
        optimized). 
        """

    def derivative(self, *args):
        """
        derivative(self, unsigned int i) -> real

        Evaluation of derivative of basis function i at t = 1 (inline
        optimized). 
        """

    def update(self, *args):
        """
        update(self, real x0, real f, real k, real values)
        update(self, real x0, real f, real k, real values, real alpha)

        Update solution values using fixed-point iteration (damped version).

        """

    def ueval(self, *args):
        """
        ueval(self, real x0, real values, real tau) -> real
        ueval(self, real x0, real values, uint i) -> real

        Evaluate solution at given node. 
        """

    def residual(self, *args):
        """
        residual(self, real x0, real values, real f, real k) -> real

        Compute residual at right end-point. 
        """

    def timestep(self, *args):
        """
        timestep(self, real r, real tol, real k0, real kmax) -> real

        Compute new time step based on the given residual. 
        """

    def error(self, *args):
        """
        error(self, real k, real r) -> real

        Compute error estimate (modulo stability factor). 
        """

    def get_nodal_values(self, *args):
        """
        get_nodal_values(self, real x0, real x, real nodal_values)

        Get nodal values. 
        """

    def get_trial(self):
        """
        get_trial(self) -> Lagrange

        Get trial functions. 
        """

    def get_quadrature_weights(self):
        """
        get_quadrature_weights(self) -> real

        Get quadrature weights. 
        """

class cGqMethod(Method):
    """
    Contains all numeric constants, such as nodal points and nodal
    weights, needed for the cG(q) method. The order q must be at least 1.
    Note that q refers to the polynomial order and not the order of
    convergence for the method, which is 2q.

    C++ includes: cGqMethod.h 
    """

    def __init__(self, *args): 
        """__init__(self, unsigned int q) -> cGqMethod"""

    def ueval(self, *args):
        """
        ueval(self, real x0, real values, real tau) -> real
        ueval(self, real x0, real values, uint i) -> real

        Evaluate solution at given node (inline optimized). 
        """

class dGqMethod(Method):
    """
    Contains all numeric constants, such as nodal points and nodal
    weights, needed for the dG(q) method. The order q must be at least 0.
    Note that q refers to the polynomial order and not the order of
    convergence for the method, which is 2q + 1.

    C++ includes: dGqMethod.h 
    """

    def __init__(self, *args): 
        """__init__(self, unsigned int q) -> dGqMethod"""

    def ueval(self, *args):
        """
        ueval(self, real x0, real values, real tau) -> real
        ueval(self, real x0, real values, uint i) -> real

        Evaluate solution at given node (inline optimized). 
        """

class ODE(Variable):
    """
    An ODE represents an initial value problem of the form

    u'(t) = f(u(t), t) on [0, T],

    u(0) = u0,

    where u(t) is a vector of length N.

    To define an ODE, a user must create a subclass of ODE and create the
    function u0() defining the initial condition, as well the function f()
    defining the right-hand side.

    DOLFIN provides two types of ODE solvers: a set of standard mono-
    adaptive solvers with equal adaptive time steps for all components as
    well as a set of multi-adaptive solvers with individual and adaptive
    time steps for the different components. The right-hand side f() is
    defined differently for the two sets of methods, with the multi-
    adaptive solvers requiring a component-wise evaluation of the right-
    hand side. Only one right-hand side function f() needs to be defined
    for use of any particular solver.

    It is also possible to solve implicit systems of the form

    M(u(t), t) u'(t) = f(u(t),t) on (0,T],

    u(0) = u0,

    by setting the option "implicit" to true and defining the function
    M().

    Two different solve() functions are provided, one to solve the ODE on
    the time interval [0, T], including the solution of a dual problem for
    error control:

    ode.solve();

    Alternatively, a time interval may be given in which case the solution
    will be computed in a single sweep over the given time interval
    without solution of dual problems:

    ode.solve(t0, t1);

    This mode allows the state to be specified and retrieved in between
    intervals by calling set_state() and get_state().

    C++ includes: ODE.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, uint N, real T) -> ODE

        Create an ODE of size N with final time T. 
        """

    def u0(self, *args):
        """
        u0(self, real u)

        Set initial values. 
        """

    def f(self, *args):
        """
        f(self, real u, real t, real y)
        f(self, real u, real t, uint i) -> real

        Evaluate right-hand side f_i(u, t), multi-adaptive version (optional).

        """

    def M(self, *args):
        """
        M(self, real dx, real dy, real u, real t)

        Compute product dy = M dx for implicit system (optional). 
        """

    def J(self, *args):
        """
        J(self, real dx, real dy, real u, real t)

        Compute product dy = J dx for Jacobian J (optional). 
        """

    def JT(self, *args):
        """
        JT(self, real dx, real dy, real u, real t)

        Compute product dy = tranpose(J) dx for Jacobian J (optional, for dual
        problem). 
        """

    def dfdu(self, *args):
        """
        dfdu(self, real u, real t, uint i, uint j) -> real

        Compute entry of Jacobian (optional). 
        """

    def timestep(self, *args):
        """
        timestep(self, real t, real k0) -> real
        timestep(self, real t, uint i, real k0) -> real

        Time step to use for a given component at a given time t (optional).

        """

    def update(self, *args):
        """
        update(self, real u, real t, bool end) -> bool

        Update ODE, return false to stop (optional). 
        """

    def save(self, *args):
        """
        save(self, Sample sample)

        Save sample (optional). 
        """

    def size(self):
        """
        size(self) -> uint

        Return number of components N. 
        """

    def time(self, *args):
        """
        time(self) -> real
        time(self, real t) -> real

        Return real time (might be flipped backwards for dual). 
        """

    def endtime(self):
        """
        endtime(self) -> real

        Return end time (final time T). 
        """

    def sparse(self):
        """
        sparse(self)

        Automatically detect sparsity (optional). 
        """

    def solve(self, *args):
        """
        solve(self)
        solve(self, real t0, real t1)
        solve(self, ODESolution u)
        solve(self, ODESolution u, real t0, real t1)

        Solve ODE on [t0, t1]. Save solution in u. 
        """

    def solve_dual(self, *args):
        """
        solve_dual(self, ODESolution u)
        solve_dual(self, ODESolution u, ODESolution z)

        Solve dual and save soution in z. 
        """

    def analyze_stability(self, *args):
        """
        analyze_stability(self, uint q, ODESolution u)

        Compute stability factors as function of T (including solving the dual
        problem). The stability factor is the integral of the norm of the q'th
        derivative of the dual. 
        """

    def analyze_stability_discretization(self, *args):
        """
        analyze_stability_discretization(self, ODESolution u)

        Compute stability factors as function of T (including solving the dual
        problem). The stability factor accounts for stability wrt the
        discretization scheme. 
        """

    def analyze_stability_computation(self, *args):
        """
        analyze_stability_computation(self, ODESolution u)

        Compute stability factors as function of T (including solving the dual
        problem). The stability factor accounts for stability wrt the round-
        off errors. 
        """

    def analyze_stability_initial(self, *args):
        """
        analyze_stability_initial(self, ODESolution u)

        Compute stability factors as function of T (including solving the dual
        problem). The stability factor accounts for stability wrt errors in
        initial data. 
        """

    def set_state(self, *args):
        """
        set_state(self, real u)

        Set state for ODE (only available during interval stepping). 
        """

    def get_state(self, *args):
        """
        get_state(self, real u)

        Get state for ODE (only available during interval stepping). 
        """

    def default_parameters():
        """default_parameters() -> Parameters"""

    def __disown__(self):
        """Missing docstring"""

class DummyComplexODE(ODE):
    """Proxy of C++ dolfin::DummyComplexODE class"""

    def __init__(self, *args): 
        """__init__(self, uint n, real T) -> DummyComplexODE"""

class PeriodicBC(BoundaryCondition):
    """
    This class specifies the interface for setting periodic boundary
    conditions for partial differential equations,

    u(x) = u(F^{-1}(x)) on G, u(x) = u(F(x)) on H,

    where F : H --> G is a map from a subdomain H to a subdomain G.

    A periodic boundary condition must be defined by the domain G and the
    map F pulling coordinates back from H to G. The domain and the map are
    both defined by a subclass of SubDomain which must overload both the
    inside() function, which specifies the points of G, and the map()
    function, which specifies the map from the points of H to the points
    of G.

    The implementation is based on matching degrees of freedom on G with
    degrees of freedom on H and only works when the mapping F is bijective
    between the sets of coordinates associated with the two domains. In
    other words, the nodes (degrees of freedom) must be aligned on G and
    H.

    The matching of degrees of freedom is done at the construction of the
    periodic boundary condition and is reused on subsequent applications
    to a linear system. The matching may be recomputed by calling the
    rebuild() function.

    C++ includes: PeriodicBC.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, __dummy_19__ V, __dummy_59__ sub_domain) -> PeriodicBC

        Create periodic boundary condition for sub domain. 
        """

    def apply(self, *args):
        """
        apply(self, GenericMatrix A)
        apply(self, GenericVector b)
        apply(self, GenericMatrix A, GenericVector b)
        apply(self, GenericVector b, GenericVector x)
        apply(self, GenericMatrix A, GenericVector b, GenericVector x)

        Apply boundary condition to a linear system for a nonlinear problem.

        """

    def rebuild(self):
        """
        rebuild(self)

        Rebuild mapping between dofs. 
        """

class Sample(Variable):
    """
    Sample of solution values at a given point.

    C++ includes: Sample.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, TimeSlab timeslab, real t, string name, string label) -> Sample

        Constructor. 
        """

    def size(self):
        """
        size(self) -> uint

        Return number of components. 
        """

    def t(self):
        """
        t(self) -> real

        Return time t. 
        """

    def u(self, *args):
        """
        u(self, uint index) -> real

        Return value of component with given index. 
        """

    def k(self, *args):
        """
        k(self, uint index) -> real

        Return time step for component with given index. 
        """

    def r(self, *args):
        """
        r(self, uint index) -> real

        Return residual for component with given index. 
        """

class TimeSeries(Variable):
    """
    This class stores a time series of objects to file(s) in a binary
    format which is efficient for reading and writing.

    When objects are retrieved, the object stored at the time closest to
    the given time will be used.

    A new time series will check if values have been stored to file before
    (for a series with the same name) and in that case reuse those values.
    If new values are stored, old values will be cleared.

    C++ includes: TimeSeries.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, string name) -> TimeSeries

        Create empty time series. 
        """

    def store(self, *args):
        """
        store(self, GenericVector vector, double t)
        store(self, Mesh mesh, double t)

        Store mesh at given time. 
        """

    def retrieve(self, *args):
        """
        retrieve(self, GenericVector vector, double t)
        retrieve(self, Mesh mesh, double t)

        Retrieve mesh at given time. 
        """

    def vector_times(self):
        """
        vector_times(self) -> DoubleArray

        Return array of sample times for vectors. 
        """

    def mesh_times(self):
        """
        mesh_times(self) -> DoubleArray

        Return array of sample times for meshes. 
        """

    def clear(self):
        """
        clear(self)

        Clear time series. 
        """

    def filename_data(*args):
        """filename_data(string series_name, string type_name, uint index) -> string"""

    def filename_times(*args):
        """filename_times(string series_name, string type_name) -> string"""

class VariationalProblem(Variable, NonlinearProblem):
    """
    This class represents a (system of) partial differential equation(s)
    in variational form: Find u in V such that

    F_u(v) = 0 for all v in V'.

    The variational problem is defined in terms of a bilinear form a(v, u)
    and a linear for L(v).

    For a linear variational problem, F_u(v) = a(v, u) - L(v), the forms
    should correspond to the canonical formulation

    a(v, u) = L(v) for all v in V'.

    For a nonlinear variational problem, the forms should be given by

    a(v, u) = F_u'(v) u = F_u'(v, u), L(v) = F(v),

    that is, a(v, u) should be the Frechet derivative of F_u with respect
    to u, and L = F.

    Parameters:

    "linear solvers": "direct" or "iterative" (default: "direct")
    "symmetric": true or false (default: false)

    C++ includes: VariationalProblem.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, Form a, Form L, bool nonlinear = False) -> VariationalProblem
        __init__(self, Form a, Form L) -> VariationalProblem
        __init__(self, Form a, Form L, BoundaryCondition bc, bool nonlinear = False) -> VariationalProblem
        __init__(self, Form a, Form L, BoundaryCondition bc) -> VariationalProblem
        __init__(self, Form a, Form L, std::vector<(p.q(const).dolfin::BoundaryCondition)> bcs, 
            bool nonlinear = False) -> VariationalProblem
        __init__(self, Form a, Form L, std::vector<(p.q(const).dolfin::BoundaryCondition)> bcs) -> VariationalProblem
        __init__(self, Form a, Form L, std::vector<(p.q(const).dolfin::BoundaryCondition)> bcs, 
            MeshFunctionUInt cell_domains, 
            MeshFunctionUInt exterior_facet_domains, 
            MeshFunctionUInt interior_facet_domains, 
            bool nonlinear = False) -> VariationalProblem
        __init__(self, Form a, Form L, std::vector<(p.q(const).dolfin::BoundaryCondition)> bcs, 
            MeshFunctionUInt cell_domains, 
            MeshFunctionUInt exterior_facet_domains, 
            MeshFunctionUInt interior_facet_domains) -> VariationalProblem

        Define variational problem with a list of Dirichlet boundary
        conditions and subdomains 
        """

    def solve(self, *args):
        """
        solve(self, Function u)
        solve(self, Function u0, Function u1)
        solve(self, Function u0, Function u1, Function u2)

        Solve variational problem and extract sub functions. 
        """

    def update(self, *args):
        """
        update(self, GenericVector x)

        Optional callback called before calls to F() and J(). 
        """

    def newton_solver(self):
        """
        newton_solver(self) -> NewtonSolver

        Return Newton solver (only useful when solving a nonlinear problem).

        """

    def default_parameters():
        """default_parameters() -> Parameters"""

# -----------------------------------------------------------------------------
# Section 3. Functions defined in cpp.py sorted alphabetically
def assemble(*args):
  """
    assemble(GenericTensor A, Form a, bool reset_sparsity = True, 
        bool add_values = False)
    assemble(GenericTensor A, Form a, bool reset_sparsity = True)
    assemble(GenericTensor A, Form a)
    assemble(GenericTensor A, Form a, SubDomain sub_domain, bool reset_sparsity = True, 
        bool add_values = False)
    assemble(GenericTensor A, Form a, SubDomain sub_domain, bool reset_sparsity = True)
    assemble(GenericTensor A, Form a, SubDomain sub_domain)
    assemble(GenericTensor A, Form a, MeshFunctionUInt cell_domains, 
        MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains, bool reset_sparsity = True, 
        bool add_values = False)
    assemble(GenericTensor A, Form a, MeshFunctionUInt cell_domains, 
        MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains, bool reset_sparsity = True)
    assemble(GenericTensor A, Form a, MeshFunctionUInt cell_domains, 
        MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains)
    assemble(Form a, bool reset_sparsity = True, bool add_values = False) -> double
    assemble(Form a, bool reset_sparsity = True) -> double
    assemble(Form a) -> double
    assemble(Form a, SubDomain sub_domain, bool reset_sparsity = True, 
        bool add_values = False) -> double
    assemble(Form a, SubDomain sub_domain, bool reset_sparsity = True) -> double
    assemble(Form a, SubDomain sub_domain) -> double
    assemble(Form a, MeshFunctionUInt cell_domains, MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains, 
        bool reset_sparsity = True, 
        bool add_values = False) -> double
    assemble(Form a, MeshFunctionUInt cell_domains, MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains, 
        bool reset_sparsity = True) -> double
    assemble(Form a, MeshFunctionUInt cell_domains, MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains) -> double

    Assemble scalar on sub domains. 
    """

def assemble_system(*args):
  """
    assemble_system(GenericMatrix A, GenericVector b, Form a, Form L, bool reset_sparsitys = True, 
        bool add_values = False)
    assemble_system(GenericMatrix A, GenericVector b, Form a, Form L, bool reset_sparsitys = True)
    assemble_system(GenericMatrix A, GenericVector b, Form a, Form L)
    assemble_system(GenericMatrix A, GenericVector b, Form a, Form L, DirichletBC bc, 
        bool reset_sparsitys = True, bool add_values = False)
    assemble_system(GenericMatrix A, GenericVector b, Form a, Form L, DirichletBC bc, 
        bool reset_sparsitys = True)
    assemble_system(GenericMatrix A, GenericVector b, Form a, Form L, DirichletBC bc)
    assemble_system(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
        bool reset_sparsitys = True, 
        bool add_values = False)
    assemble_system(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
        bool reset_sparsitys = True)
    assemble_system(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs)
    assemble_system(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
        MeshFunctionUInt cell_domains, 
        MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains, 
        GenericVector x0, 
        bool reset_sparsitys = True, bool add_values = False)
    assemble_system(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
        MeshFunctionUInt cell_domains, 
        MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains, 
        GenericVector x0, 
        bool reset_sparsitys = True)
    assemble_system(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
        MeshFunctionUInt cell_domains, 
        MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains, 
        GenericVector x0)

    Assemble system (A, b) on sub domains and apply Dirichlet boundary
    conditions. 
    """

def Assembler_assemble(*args):
  """
    assemble(GenericTensor A, Form a, bool reset_sparsity = True, 
        bool add_values = False)
    assemble(GenericTensor A, Form a, bool reset_sparsity = True)
    assemble(GenericTensor A, Form a)
    assemble(GenericTensor A, Form a, SubDomain sub_domain, bool reset_sparsity = True, 
        bool add_values = False)
    assemble(GenericTensor A, Form a, SubDomain sub_domain, bool reset_sparsity = True)
    assemble(GenericTensor A, Form a, SubDomain sub_domain)
    assemble(GenericTensor A, Form a, MeshFunctionUInt cell_domains, 
        MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains, bool reset_sparsity = True, 
        bool add_values = False)
    assemble(GenericTensor A, Form a, MeshFunctionUInt cell_domains, 
        MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains, bool reset_sparsity = True)
    Assembler_assemble(GenericTensor A, Form a, MeshFunctionUInt cell_domains, 
        MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains)
    """

def DirichletBC_default_parameters():
  """DirichletBC_default_parameters() -> Parameters"""

def dolfin_set_precision(*args):
  """dolfin_set_precision(uint prec)"""

def dolfin_swigversion():
  """dolfin_swigversion() -> int"""

def File_exists(*args):
  """File_exists(string filename) -> bool"""

def has_cgal():
  """has_cgal() -> bool"""

def has_cholmod():
  """has_cholmod() -> bool"""

def has_gmp():
  """has_gmp() -> bool"""

def has_la_backend(*args):
  """has_la_backend(string backend) -> bool"""

def has_mpi():
  """has_mpi() -> bool"""

def has_parmetis():
  """has_parmetis() -> bool"""

def has_scotch():
  """has_scotch() -> bool"""

def has_slepc():
  """has_slepc() -> bool"""

def has_umfpack():
  """has_umfpack() -> bool"""

def has_zlib():
  """has_zlib() -> bool"""

def isnormal(*args):
  """isnormal(real x) -> int"""

def ODE_default_parameters():
  """ODE_default_parameters() -> Parameters"""

def pow(*args):
  """pow(real x, real y) -> real"""

def real_abs(*args):
  """real_abs(real x) -> real"""

def real_decimal_prec():
  """real_decimal_prec() -> int"""

def real_epsilon():
  """real_epsilon() -> real"""

def real_exp(*args):
  """
    real_exp(real x) -> real

    Exponential function (note: not full precision!). 
    """

def real_frexp(*args):
  """real_frexp(int exp, real x) -> double"""

def real_log(*args):
  """
    real_log(real x) -> real

    Logarithmic function (note: not full precision!). 
    """

def real_mat_exp(*args):
  """
    real_mat_exp(uint n, real res, real A, uint p = 6)
    real_mat_exp(uint n, real res, real A)

    Compute matrix exponential using Pade approximation og degree p. 
    """

def real_mat_pow(*args):
  """real_mat_pow(uint n, real A, real B, uint q)"""

def real_mat_prod(*args):
  """real_mat_prod(uint n, real res, real A, real B)"""

def real_mat_prod_inplace(*args):
  """real_mat_prod_inplace(uint n, real A, real B)"""

def real_mat_vector_prod(*args):
  """real_mat_vector_prod(uint n, real y, real A, real x)"""

def real_max(*args):
  """real_max(real x, real y) -> real"""

def real_min(*args):
  """real_min(real x, real y) -> real"""

def real_pi():
  """
    real_pi() -> real

    Compute pi. 
    """

def real_pow(*args):
  """
    real_pow(real x, uint y) -> real
    real_pow(real x, real y) -> real
    """

def real_sqrt(*args):
  """
    real_sqrt(real a) -> real

    Square root. 
    """

def SystemAssembler_assemble(*args):
  """
    assemble(GenericMatrix A, GenericVector b, Form a, Form L, bool reset_sparsity = True, 
        bool add_values = False)
    assemble(GenericMatrix A, GenericVector b, Form a, Form L, bool reset_sparsity = True)
    assemble(GenericMatrix A, GenericVector b, Form a, Form L)
    assemble(GenericMatrix A, GenericVector b, Form a, Form L, DirichletBC bc, 
        bool reset_sparsity = True, bool add_values = True)
    assemble(GenericMatrix A, GenericVector b, Form a, Form L, DirichletBC bc, 
        bool reset_sparsity = True)
    assemble(GenericMatrix A, GenericVector b, Form a, Form L, DirichletBC bc)
    assemble(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
        bool reset_sparsity = True, 
        bool add_values = False)
    assemble(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
        bool reset_sparsity = True)
    assemble(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs)
    assemble(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
        MeshFunctionUInt cell_domains, 
        MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains, 
        GenericVector x0, 
        bool reset_sparsity = True, bool add_values = False)
    assemble(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
        MeshFunctionUInt cell_domains, 
        MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains, 
        GenericVector x0, 
        bool reset_sparsity = True)
    SystemAssembler_assemble(GenericMatrix A, GenericVector b, Form a, Form L, std::vector<(p.q(const).dolfin::DirichletBC)> bcs, 
        MeshFunctionUInt cell_domains, 
        MeshFunctionUInt exterior_facet_domains, 
        MeshFunctionUInt interior_facet_domains, 
        GenericVector x0)
    """

def tic():
  """
    tic()

    Start timing (should not be used internally in DOLFIN!).

    Timing functions measure CPU time as determined by clock(), the
    precision of which seems to be 0.01 seconds. 
    """

def time():
  """
    time() -> double

    Return current CPU time used by process. 
    """

def TimeSeries_filename_data(*args):
  """TimeSeries_filename_data(string series_name, string type_name, uint index) -> string"""

def TimeSeries_filename_times(*args):
  """TimeSeries_filename_times(string series_name, string type_name) -> string"""

def toc():
  """
    toc() -> double

    Return elapsed CPU time (should not be used internally in DOLFIN!). 
    """

def to_double(*args):
  """to_double(real x) -> double"""

def to_real(*args):
  """to_real(double x) -> real"""

def VariationalProblem_default_parameters():
  """VariationalProblem_default_parameters() -> Parameters"""


# The following is just a copy of the original cpp.py file, the classes and
# functions have not been sorted or cleaned up yet.
class IntArray(object):
    """
    This class provides a simple wrapper for a pointer to an array. A
    purpose of this class is to enable the simple and safe exchange of
    data between C++ and Python.

    C++ includes: Array.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> IntArray
        __init__(self, uint N) -> IntArray
        __init__(self, uint N) -> IntArray

        Construct array from a pointer. Array will not take ownership. 
        """

    def update(self, *args):
        """
        update(self, uint N, int _x)

        Construct array from a pointer. Array will not take ownership. 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). Note that the
        Array class is not a subclass of Variable (for efficiency) which means
        that one needs to call str() directly instead of using the info()
        function on Array objects. 
        """

    def resize(self, *args):
        """
        resize(self, uint N)

        Resize array to size N. If size changes, contents will be destroyed.

        """

    def size(self):
        """
        size(self) -> uint

        Return size of array. 
        """

    def zero(self):
        """
        zero(self)

        Zero array. 
        """

    def zero_eps(self, eps = 3.0e-16):
        """
        zero_eps(self, double eps = 3.0e-16)
        zero_eps(self)
        """

    def min(self):
        """
        min(self) -> int

        Return minimum value of array. 
        """

    def max(self):
        """
        max(self) -> int

        Return maximum value of array. 
        """

    def data(self, *args):
        """
        data(self) -> boost::shared_array<(int)>
        data(self) -> boost::shared_array<(int)>

        Return pointer to data (non-const version). 
        """

    def __getitem__(self, *args):
        """__getitem__(self, unsigned int i) -> int"""

    def __setitem__(self, *args):
        """__setitem__(self, unsigned int i, int val)"""

    def array(self):
        """array(self) -> PyObject"""

class ParameterValue(object):
    """
    Base class for parameters.

    C++ includes: Parameter.h 
    """

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def key(self):
        """
        key(self) -> string

        Return parameter key. 
        """

    def description(self):
        """
        description(self) -> string

        Return parameter description. 
        """

    def access_count(self):
        """
        access_count(self) -> uint

        Return access count (number of times parameter has been accessed). 
        """

    def change_count(self):
        """
        change_count(self) -> uint

        Return change count (number of times parameter has been changed). 
        """

    def set_range(self, *args):
        """
        set_range(self, int min_value, int max_value)
        set_range(self, real min_value, real max_value)
        set_range(self, std::set<(std::string)> range)

        Set range for string-valued parameter. 
        """

    def _get_int_range(self):
        """
        _get_int_range(self)

        Get range for string-valued parameter. 
        """

    def _get_real_range(self):
        """
        _get_real_range(self)

        Get range for string-valued parameter. 
        """

    def _get_string_range(self):
        """
        _get_string_range(self)

        Get range for string-valued parameter. 
        """

    def _assign(self, *args):
        """
        _assign(self, int value) -> ParameterValue
        _assign(self, double value) -> ParameterValue
        _assign(self, real value) -> ParameterValue
        _assign(self, string value) -> ParameterValue
        _assign(self, char value) -> ParameterValue
        """

    def _assign_bool(self, *args):
        """_assign_bool(self, bool value) -> ParameterValue"""

    def __int__(self):
        """__int__(self) -> int"""

    def __float__(self):
        """__float__(self) -> double"""

    def __str__(self):
        """__str__(self) -> string"""

    def __nonzero__(self):
        """Missing docstring"""

    def get_real(self):
        """
        get_real(self) -> real

        Get real value of parameter with (possibly) extended precision. 
        """

    def type_str(self):
        """
        type_str(self) -> string

        Return value type string. 
        """

    def value_str(self):
        """
        value_str(self) -> string

        Return value string. 
        """

    def range_str(self):
        """
        range_str(self) -> string

        Return range string. 
        """

    def str(self):
        """
        str(self) -> string

        Return short string description. 
        """

    def check_key(*args):
        """check_key(string key)"""

    def warn_once(self, msg):
        """Missing docstring"""

    def value(self):
        """Missing docstring"""

    def get_range(self):
        """Missing docstring"""

    def data(self):
        """Missing docstring"""

def ParameterValue_check_key(*args):
  """ParameterValue_check_key(string key)"""

class IntParameter(ParameterValue):
    """
    Parameter with value type int.

    C++ includes: Parameter.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, string key, int value) -> IntParameter

        Create int-valued parameter. 
        """

    def _assign(self, *args):
        """_assign(self, int value) -> IntParameter"""

class RealParameter(ParameterValue):
    """
    Parameter with value type double.

    C++ includes: Parameter.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, string key, real value) -> RealParameter

        Create double-valued parameter. 
        """

    def _assign(self, *args):
        """
        _assign(self, double value) -> RealParameter
        _assign(self, real value) -> RealParameter
        """

class StringParameter(ParameterValue):
    """
    Parameter with value type string.

    C++ includes: Parameter.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, string key, string value) -> StringParameter

        Create string-valued parameter. 
        """

    def _assign(self, *args):
        """
        _assign(self, string value) -> StringParameter
        _assign(self, char value) -> StringParameter
        """

class BoolParameter(ParameterValue):
    """
    Parameter with value type bool.

    C++ includes: Parameter.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, string key, bool value) -> BoolParameter

        Create bool-valued parameter. 
        """

    def _assign_bool(self, *args):
        """_assign_bool(self, bool value) -> BoolParameter"""

class Parameters(object):
    """
    This class stores a set of parameters. Each parameter is identified by
    a unique string (the key) and a value of some given value type.
    Parameter sets can be nested at arbitrary depths.

    A parameter may be either int, double, string or boolean valued.

    Parameters may be added as follows:

    Parameters p("my_parameters"); p.add("relative_tolerance", 1e-15);
    p.add("absolute_tolerance", 1e-15); p.add("gmres_restart", 30);
    p.add("monitor_convergence", false);

    Parameters may be changed as follows:

    p("gmres_restart") = 50;

    Parameter values may be retrieved as follows:

    int gmres_restart = p("gmres_restart");

    Parameter sets may be nested as follows:

    Parameters q("nested_parameters"); p.add(q);

    Nested parameters may then be accessed by

    p["nested_parameters"]("...")

    Parameters may be nested at arbitrary depths.

    Parameters may be parsed from the command-line as follows:

    p.parse(argc, argv);

    Note: spaces in parameter keys are not allowed (to simplify usage from
    command-line).

    C++ includes: Parameters.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, string key = "parameters") -> Parameters
        __init__(self) -> Parameters
        __init__(self, Parameters parameters) -> Parameters

        Copy constructor. 
        """

    def name(self):
        """
        name(self) -> string

        Return name for parameter set. 
        """

    def rename(self, *args):
        """
        rename(self, string key)

        Rename parameter set. 
        """

    def clear(self):
        """
        clear(self)

        Clear parameter set. 
        """

    def _add_bool(self, *args):
        """
        _add_bool(self, string key, bool value)

        Add nested parameter set. 
        """

    def _add(self, *args):
        """
        _add(self, string key, int value)
        _add(self, string key, int value, int min_value, int max_value)
        _add(self, string key, double value)
        _add(self, string key, double value, double min_value, double max_value)
        _add(self, string key, real value)
        _add(self, string key, real value, real min_value, real max_value)
        _add(self, string key, string value)
        _add(self, string key, char value)
        _add(self, string key, string value, std::set<(std::string)> range)
        _add(self, string key, char value, std::set<(std::string)> range)
        _add(self, Parameters parameters)

        Add nested parameter set. 
        """

    def _get_parameter(self, *args):
        """
        _get_parameter(self, string key) -> ParameterValue
        _get_parameter(self, string key) -> ParameterValue
        """

    def _get_parameter_set(self, *args):
        """
        _get_parameter_set(self, string key) -> Parameters
        _get_parameter_set(self, string key) -> Parameters
        """

    def assign(self, *args):
        """assign(self, Parameters parameters) -> Parameters"""

    def has_key(self, *args):
        """
        has_key(self, string key) -> bool

        Check if parameter set has given key. 
        """

    def _get_parameter_keys(self):
        """
        _get_parameter_keys(self)

        Return a vector of parameter keys. 
        """

    def _get_parameter_set_keys(self):
        """
        _get_parameter_set_keys(self)

        Return a vector of parameter set keys. 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). 
        """

    def _parse(self, *args):
        """_parse(self, PyObject op)"""

    def add(self,*args):
        """Add a parameter to the parameter set"""

    def parse(self,argv=None):
        """Parse command line arguments"""

    def keys(self):
        """Returns a list of the parameter keys"""

    def iterkeys(self):
        """Returns an iterator for the parameter keys"""

    def values(self):
        """Returns a list of the parameter values"""

    def itervalues(self):
        """Returns an iterator to the parameter values"""

    def items(self):
        """Missing docstring"""

    def iteritems(self):
        """Returns an iterator over the (key, value) items of the Parameters"""

    def set_range(self, key, *arg):
        """Set the range for the given parameter"""

    def __getitem__(self, key):
        """Return the parameter corresponding to the given key"""

    def __setitem__(self, key, value):
        """Set the parameter 'key', with given 'value'"""

    def update(self, other):
        """A recursive update that handles parameter subsets correctly."""

    def to_dict(self):
        """Convert the Parameters to a dict"""

    def copy(self):
        """Return a copy of it self"""

    def option_string(self):
        """Return an option string representation of the Parameters"""

    def __str__(self):
        """p.__str__() <==> str(x)"""

    def iterdata(self):
        """Returns an iterator of a tuple of a parameter key together with its value"""

    def get(self, key):
        """Return all data available for a certain parameter

        The data is returned in a tuple:
        value, range, access_count, change_count = parameters.get('name')
        """

class GlobalParameters(Parameters):
    """
    This class defines the global DOLFIN parameter database.

    C++ includes: GlobalParameters.h 
    """

    def __init__(self): 
        """
        __init__(self) -> GlobalParameters

        Constructor. 
        """

    def default_parameters():
        """default_parameters() -> Parameters"""

def GlobalParameters_default_parameters():
  """GlobalParameters_default_parameters() -> Parameters"""

def __new_Parameter_init__(self,*args,**kwargs):
    """ Initialize Parameters

    Usage:
    Parameters("parameters")
       returns an empty Parameters

    Parameters(other_parameters)
       returns a copy of the other_parameters

    Parameters("parameters",dim=3,tol=0.1,name='Name')
       returns a parameters with the given values

    Parameters("parameters",dim=(3,0,4),name=("Name",["Name","Blame"])
      returns a parameters with the given values and ranges
    """

def info_stream(*args):
  """
    info_stream(std::ostream out, string msg)

    Print message to stream. 
    """

def info_underline(*args):
  """
    info_underline(string msg, v(...) *args)

    Print underlined message. 
    """

def warning(*args):
  """
    warning(string msg, v(...) *args)

    Print warning. 
    """

def error(*args):
  """
    error(string msg, v(...) *args)

    Print error message and throw an exception. 
    """

def end():
  """
    end()

    End task (decrease indentation level). 
    """

def set_log_level(*args):
  """
    set_log_level(int level)

    Set log level. 
    """

def get_log_level():
  """
    get_log_level() -> int

    Get log level. 
    """

def not_working_in_parallel(*args):
  """
    not_working_in_parallel(string what)

    Report that functionality has not (yet) been implemented to work in
    parallel. 
    """

def check_equal(*args):
  """
    check_equal(uint value, uint valid_value, string task, string value_name)

    Check value and print an informative error message if invalid. 
    """

def __debug(*args):
  """
    __debug(string file, unsigned long line, string function, string format, 
        v(...) *args)
    """

class Event(object):
    """
    A event is a string message which is displayed only a limited number
    of times.

    Example of usage:

    Event event("System is stiff, damping is needed."); while () { ...
    if ( ... ) { event(); ... } }

    C++ includes: Event.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, string msg, unsigned int maxcount = 1) -> Event
        __init__(self, string msg) -> Event

        Constructor. 
        """

    def __call__(self):
        """__call__(self)"""

    def count(self):
        """
        count(self) -> unsigned int

        Display count. 
        """

    def maxcount(self):
        """
        maxcount(self) -> unsigned int

        Maximum display count. 
        """

def _info(*args):
  """
    _info(string msg, v(...) *args)
    _info(int debug_level, string msg, v(...) *args)

    Print variable (using output of str() method). 
    """

def begin(*args):
  """
    begin(string msg, v(...) *args)
    begin(int debug_level, string msg, v(...) *args)

    Begin task (increase indentation level). 
    """

def logging(active = True):
  """
    logging(bool active = True)
    logging()

    Turn logging on or off. 
    """

def summary(reset = False):
  """
    summary(bool reset = False)
    summary()

    Print summary of timings and tasks, optionally clearing stored
    timings. 
    """

def timing(*args):
  """
    timing(string task, bool reset = False) -> double
    timing(string task) -> double

    Return timing (average) for given task, optionally clearing timing for
    task. 
    """

class Progress(object):
    """
    This class provides a simple way to create and update progress bars
    during a computation. A progress bar may be used either in an
    iteration with a known number of steps:

    Progress p("Iterating...", n); for (int i = 0; i < n; i++) { ...
    p++; }

    or in an iteration with an unknown number of steps:

    Progress p("Iterating..."); while (t < T) { ... p = t / T; }

    C++ includes: Progress.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, string title, unsigned int n) -> Progress
        __init__(self, string title) -> Progress

        Create progress bar with an unknown number of steps. 
        """

    def __add(self, *args):
        """__add(self, int incr)"""

    def __set(self, *args):
        """__set(self, double value)"""

    def __iadd__(self, other):
        """Missing docstring"""

    def update(self, other):
        """Missing docstring"""

class Table(Variable):
    """
    This class provides storage and pretty-printing for tables. Example
    usage:

    Table table("Timings");

    table("uBLAS", "Assemble") = 0.010; table("uBLAS", "Solve") =
    0.020; table("PETSc", "Assemble") = 0.011; table("PETSc",
    "Solve") = 0.019; table("Epetra", "Assemble") = 0.012;
    table("Epetra", "Solve") = 0.018;

    info(table);

    C++ includes: Table.h 
    """

    def __init__(self, title = ""): 
        """
        __init__(self, string title = "") -> Table
        __init__(self) -> Table

        Create empty table. 
        """

    def __call__(self, *args):
        """__call__(self, string row, string col) -> TableEntry"""

    def set(self, *args):
        """
        set(self, string row, string col, int value)
        set(self, string row, string col, double value)
        set(self, string row, string col, string value)

        Set value of table entry. 
        """

    def get(self, *args):
        """
        get(self, string row, string col) -> string

        Get value of table entry. 
        """

    def title(self):
        """
        title(self) -> string

        Return table title. 
        """

    def str_latex(self):
        """
        str_latex(self) -> string

        Return informal string representation for LaTeX. 
        """

class TableEntry(object):
    """
    This class represents an entry in a Table.

    C++ includes: Table.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, string row, string col, Table table) -> TableEntry

        Create table entry. 
        """

def debug(message):
    """Missing docstring"""

def info(*args):
    """Missing docstring"""

class GenericLinearSolver(Variable):
    """
    This class provides a general solver for linear systems Ax = b.

    C++ includes: GenericLinearSolver.h 
    """

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def set_operator(self, *args):
        """
        set_operator(self, GenericMatrix A)

        Solve the operator (matrix). 
        """

    def set_operators(self, *args):
        """
        set_operators(self, GenericMatrix A, GenericMatrix P)

        Solve the operator (matrix) and preconditioner matrix. 
        """

    def solve(self, *args):
        """
        solve(self, GenericMatrix A, GenericVector x, GenericVector b) -> uint
        solve(self, GenericVector x, GenericVector b) -> uint

        Solve linear system Ax = b. 
        """

class GenericLUSolver(GenericLinearSolver):
    """
    This a base class for LU solvers.

    C++ includes: GenericLUSolver.h 
    """

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def solve(self, *args):
        """
        solve(self, GenericVector x, GenericVector b) -> uint
        solve(self, GenericMatrix A, GenericVector x, GenericVector b) -> uint

        Solve linear system Ax = b. 
        """

class GenericTensor(Variable):
    """
    This class defines a common interface for arbitrary rank tensors.

    C++ includes: GenericTensor.h 
    """

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def resize(self, *args):
        """
        resize(self, uint rank, uint dims)

        Resize tensor with given dimensions. 
        """

    def init(self, *args):
        """
        init(self, GenericSparsityPattern sparsity_pattern)

        Initialize zero tensor using sparsity pattern. 
        """

    def copy(self):
        """
        copy(self) -> GenericTensor

        Return copy of tensor. 
        """

    def rank(self):
        """
        rank(self) -> uint

        Return tensor rank (number of dimensions). 
        """

    def size(self, *args):
        """
        size(self, uint dim) -> uint

        Return size of given dimension. 
        """

    def zero(self):
        """
        zero(self)

        Set all entries to zero and keep any sparse structure. 
        """

    def apply(self, *args):
        """
        apply(self, string mode)

        Finalize assembly of tensor. 
        """

    def factory(self):
        """
        factory(self) -> LinearAlgebraFactory

        Return linear algebra backend factory. 
        """

class GenericMatrix(GenericTensor):
    """
    This class defines a common interface for matrices.

    C++ includes: GenericMatrix.h 
    """

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def copy(self):
        """
        copy(self) -> GenericMatrix

        Return copy of tensor. 
        """

    def resize(self, *args):
        """
        resize(self, uint rank, uint dims)
        resize(self, uint M, uint N)

        Resize matrix to M x N. 
        """

    def get(self, *args):
        """
        get(self, double block, uint m, uint n)

        Get block of values. 
        """

    def set(self, *args):
        """
        set(self, double block, uint m, uint n)

        Set block of values. 
        """

    def add(self, *args):
        """
        add(self, double block, uint m, uint n)

        Add block of values. 
        """

    def axpy(self, *args):
        """
        axpy(self, double a, GenericMatrix A, bool same_nonzero_pattern)

        Add multiple of given matrix (AXPY operation). 
        """

    def norm(self, *args):
        """
        norm(self, string norm_type) -> double

        Return norm of matrix. 
        """

    def getrow(self, *args):
        """
        getrow(self, uint row)

        Get non-zero values of given row on local process. 
        """

    def setrow(self, *args):
        """
        setrow(self, uint row)

        Set values for given row on local process. 
        """

    def zero(self, *args):
        """
        zero(self)
        zero(self, uint m)

        Set given rows to zero. 
        """

    def ident(self, *args):
        """
        ident(self, uint m)

        Set given rows to identity matrix. 
        """

    def mult(self, *args):
        """
        mult(self, GenericVector x, GenericVector y)

        Matrix-vector product, y = Ax. 
        """

    def transpmult(self, *args):
        """
        transpmult(self, GenericVector x, GenericVector y)

        Matrix-vector product, y = A^T x. 
        """

    def assign(self, *args):
        """assign(self, GenericMatrix x) -> GenericMatrix"""

    def ident_zeros(self):
        """
        ident_zeros(self)

        Insert one on the diagonal for all zero rows. 
        """

    def _scale(self, *args):
        """_scale(self, double a)"""

    def _data(self):
        """_data(self) -> PyObject"""

    def __is_compatible(self,other):
        """Returns True if self, and other are compatible Vectors"""

    def array(self):
        """Return a numpy array representation of Matrix"""

    def data(self):
        """ Return arrays to underlying compresssed row/column storage data """

    def __getitem__(self,indices):
        """Missing docstring"""

    def __setitem__(self, indices, values):
        """Missing docstring"""

    def __add__(self,other):
        """x.__add__(y) <==> x+y"""

    def __sub__(self,other):
        """x.__sub__(y) <==> x-y"""

    def __mul__(self,other):
        """x.__mul__(y) <==> x*y"""

    def __div__(self,other):
        """x.__div__(y) <==> x/y"""

    def __radd__(self,other):
        """x.__radd__(y) <==> y+x"""

    def __rsub__(self,other):
        """x.__rsub__(y) <==> y-x"""

    def __rmul__(self,other):
        """x.__rmul__(y) <==> y*x"""

    def __rdiv__(self,other):
        """x.__rdiv__(y) <==> y/x"""

    def __iadd__(self,other):
        """x.__iadd__(y) <==> x+y"""

    def __isub__(self,other):
        """x.__isub__(y) <==> x-y"""

    def __imul__(self,other):
        """x.__imul__(y) <==> x*y"""

    def __idiv__(self,other):
        """x.__idiv__(y) <==> x/y"""

class GenericSparsityPattern(Variable):
    """
    Base class (interface) for generic tensor sparsity patterns.
    Currently, this interface is mostly limited to matrices.

    C++ includes: GenericSparsityPattern.h 
    """

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def init(self, *args):
        """
        init(self, uint rank, uint dims)

        Initialize sparsity pattern for a generic tensor. 
        """

    def insert(self, *args):
        """
        insert(self, uint num_rows, uint rows)

        Insert non-zero entries. 
        """

    def rank(self):
        """
        rank(self) -> uint

        Return rank. 
        """

    def size(self, *args):
        """
        size(self, uint i) -> uint

        Return global size for dimension i. 
        """

    def local_range(self, *args):
        """
        local_range(self, uint dim) -> std::pair<(dolfin::uint,dolfin::uint)>

        Return local range for dimension dim. 
        """

    def num_nonzeros(self):
        """
        num_nonzeros(self) -> uint

        Return total number of nonzeros in local_range for dimension 0. 
        """

    def num_nonzeros_diagonal(self, *args):
        """
        num_nonzeros_diagonal(self, uint num_nonzeros)

        Fill array with number of nonzeros for diagonal block in local_range
        for dimension 0. 
        """

    def num_nonzeros_off_diagonal(self, *args):
        """
        num_nonzeros_off_diagonal(self, uint num_nonzeros)

        Fill array with number of nonzeros for off-diagonal block in
        local_range for dimension 0. 
        """

    def apply(self):
        """
        apply(self)

        Finalize sparsity pattern. 
        """

class GenericVector(GenericTensor):
    """
    This class defines a common interface for vectors.

    C++ includes: GenericVector.h 
    """

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def copy(self):
        """
        copy(self) -> GenericVector

        Return copy of tensor. 
        """

    def resize(self, *args):
        """
        resize(self, uint rank, uint dims)
        resize(self, uint N)

        Resize vector to size N. 
        """

    def size(self, *args):
        """
        size(self, uint dim) -> uint
        size(self) -> uint

        Return global size of vector. 
        """

    def local_size(self):
        """
        local_size(self) -> uint

        Return local size of vector. 
        """

    def local_range(self):
        """
        local_range(self) -> std::pair<(dolfin::uint,dolfin::uint)>

        Return local ownership range of a vector. 
        """

    def add(self, *args):
        """
        add(self, double block, uint m)

        Add block of values. 
        """

    def get_local(self, *args):
        """
        get_local(self, double block, uint m)
        get_local(self, DoubleArray values)

        Get all values on local process. 
        """

    def set_local(self, *args):
        """
        set_local(self, DoubleArray values)

        Set all values on local process. 
        """

    def add_local(self, *args):
        """
        add_local(self, DoubleArray values)

        Add values to each entry on local process. 
        """

    def gather(self, *args):
        """
        gather(self, GenericVector x, dolfin::Array<(dolfin::uint)> indices)

        Gather entries into local vector x. 
        """

    def axpy(self, *args):
        """
        axpy(self, double a, GenericVector x)

        Add multiple of given vector (AXPY operation). 
        """

    def inner(self, *args):
        """
        inner(self, GenericVector x) -> double

        Return inner product with given vector. 
        """

    def norm(self, *args):
        """
        norm(self, string norm_type) -> double

        Return norm of vector. 
        """

    def min(self):
        """
        min(self) -> double

        Return minimum value of vector. 
        """

    def max(self):
        """
        max(self) -> double

        Return maximum value of vector. 
        """

    def sum(self, *args):
        """
        sum(self) -> double
        sum(self, dolfin::Array<(dolfin::uint)> rows) -> double

        Return sum of selected rows in vector. Repeated entries only summed
        once. 
        """

    def _assign(self, *args):
        """
        _assign(self, GenericVector x) -> GenericVector
        _assign(self, double a) -> GenericVector
        """

    def _scale(self, *args):
        """_scale(self, double a)"""

    def _vec_mul(self, *args):
        """_vec_mul(self, GenericVector other)"""

    def __in_parallel(self):
        """Missing docstring"""

    def __is_compatible(self, other):
        """Returns True if self, and other are compatible Vectors"""

    def array(self):
        """Return a numpy array representation of Vector"""

    def __contains__(self, value):
        """Missing docstring"""

    def __gt__(self, value):
        """Missing docstring"""

    def __ge__(self,value):
        """Missing docstring"""

    def __lt__(self,value):
        """Missing docstring"""

    def __le__(self,value):
        """Missing docstring"""

    def __eq__(self,value):
        """Missing docstring"""

    def __neq__(self,value):
        """Missing docstring"""

    def __neg__(self):
        """Missing docstring"""

    def __delitem__(self,i):
        """Missing docstring"""

    def __delslice__(self,i,j):
        """Missing docstring"""

    def __setslice__(self,i,j,values):
        """Missing docstring"""

    def __getslice__(self, i, j):
        """Missing docstring"""

    def __getitem__(self, indices):
        """Missing docstring"""

    def __setitem__(self, indices, values):
        """Missing docstring"""

    def __len__(self):
        """Missing docstring"""

    def __iter__(self):
        """Missing docstring"""

    def __add__(self, other):
        """x.__add__(y) <==> x+y"""

    def __sub__(self,other):
        """x.__sub__(y) <==> x-y"""

    def __mul__(self,other):
        """x.__mul__(y) <==> x*y"""

    def __div__(self,other):
        """x.__div__(y) <==> x/y"""

    def __radd__(self,other):
        """x.__radd__(y) <==> y+x"""

    def __rsub__(self,other):
        """x.__rsub__(y) <==> y-x"""

    def __rmul__(self,other):
        """x.__rmul__(y) <==> y*x"""

    def __rdiv__(self,other):
        """x.__rdiv__(y) <==> y/x"""

    def __iadd__(self,other):
        """x.__iadd__(y) <==> x+y"""

    def __isub__(self,other):
        """x.__isub__(y) <==> x-y"""

    def __imul__(self,other):
        """x.__imul__(y) <==> x*y"""

    def __idiv__(self,other):
        """x.__idiv__(y) <==> x/y"""

class PETScObject(object):
    """
    This class calls SubSystemsManger to initialise PETSc.

    All PETSc objects must be derived from this class.

    C++ includes: PETScObject.h 
    """

    def __init__(self): 
        """__init__(self) -> PETScObject"""

class PETScMatrixDeleter(object):
    """Proxy of C++ dolfin::PETScMatrixDeleter class"""

    def __call__(self, *args):
        """__call__(self, Mat A)"""

    def __init__(self): 
        """__init__(self) -> PETScMatrixDeleter"""

class PETScBaseMatrix(PETScObject,Variable):
    """Proxy of C++ dolfin::PETScBaseMatrix class"""

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def resize(self, *args):
        """resize(self, uint m, uint n)"""

    def size(self, *args):
        """size(self, uint dim) -> uint"""

    def mat(self):
        """mat(self) -> boost::shared_ptr<(Mat)>"""

class uBLASKrylovMatrix(object):
    """
    This class provides an interface for matrices that define linear
    systems for the uBLASKrylovSolver. This interface is implemented by
    the classes uBLASSparseMatrix and DenseMatrix. Users may also overload
    the mult() function to specify a linear system only in terms of its
    action.

    C++ includes: uBLASKrylovMatrix.h 
    """

    def __init__(self): 
        """
        __init__(self) -> uBLASKrylovMatrix

        Constructor. 
        """

    def size(self, *args):
        """
        size(self, uint dim) -> uint

        Return number of rows (dim = 0) or columns (dim = 1). 
        """

    def mult(self, *args):
        """
        mult(self, uBLASVector x, uBLASVector y)

        Compute product y = Ax. 
        """

    def solve(self, *args):
        """
        solve(self, uBLASVector x, uBLASVector b)

        Solve linear system Ax = b for a Krylov matrix using uBLAS and dense
        matrices. 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). 
        """

    def __disown__(self):
        """Missing docstring"""

class PETScMatrix(PETScBaseMatrix,GenericMatrix):
    """Proxy of C++ dolfin::PETScMatrix class"""

    def __init__(self, *args): 
        """
        __init__(self) -> PETScMatrix
        __init__(self, uint M, uint N) -> PETScMatrix
        __init__(self, PETScMatrix A) -> PETScMatrix
        __init__(self, boost::shared_ptr<(Mat)> A) -> PETScMatrix
        """

    def copy(self):
        """copy(self) -> PETScMatrix"""

    def size(self, *args):
        """
        size(self, uint dim) -> uint

        Return size of given dimension. 
        """

    def zero(self, *args):
        """
        zero(self)
        zero(self, uint m)

        Set given rows to zero. 
        """

    def assign(self, *args):
        """
        assign(self, GenericMatrix A) -> GenericMatrix
        assign(self, PETScMatrix A) -> PETScMatrix
        """

class PETScKrylovMatrix(PETScBaseMatrix):
    """Proxy of C++ dolfin::PETScKrylovMatrix class"""

    def __init__(self, *args): 
        """
        __init__(self) -> PETScKrylovMatrix
        __init__(self, uint m, uint n) -> PETScKrylovMatrix
        """

    def mult(self, *args):
        """mult(self, PETScVector x, PETScVector y)"""

    def __disown__(self):
        """Missing docstring"""

class PETScPreconditioner(PETScObject,Variable):
    """Proxy of C++ dolfin::PETScPreconditioner class"""

    def __init__(self, type = "default"): 
        """
        __init__(self, string type = "default") -> PETScPreconditioner
        __init__(self) -> PETScPreconditioner
        """

    def set(self, *args):
        """set(self, PETScKrylovSolver solver)"""

    def default_parameters():
        """default_parameters() -> Parameters"""

def PETScPreconditioner_default_parameters():
  """PETScPreconditioner_default_parameters() -> Parameters"""

class PETScKrylovSolver(GenericLinearSolver,PETScObject):
    """Proxy of C++ dolfin::PETScKrylovSolver class"""

    def __init__(self, *args): 
        """
        __init__(self, string method = "default", string pc_type = "default") -> PETScKrylovSolver
        __init__(self, string method = "default") -> PETScKrylovSolver
        __init__(self) -> PETScKrylovSolver
        __init__(self, string method, PETScPreconditioner preconditioner) -> PETScKrylovSolver
        __init__(self, string method, PETScUserPreconditioner preconditioner) -> PETScKrylovSolver
        __init__(self, boost::shared_ptr<(KSP)> ksp) -> PETScKrylovSolver
        """

    def set_operator(self, *args):
        """
        set_operator(self, GenericMatrix A)
        set_operator(self, PETScBaseMatrix A)

        Solve the operator (matrix). 
        """

    def set_operators(self, *args):
        """
        set_operators(self, GenericMatrix A, GenericMatrix P)
        set_operators(self, PETScBaseMatrix A, PETScBaseMatrix P)

        Solve the operator (matrix) and preconditioner matrix. 
        """

    def solve(self, *args):
        """
        solve(self, GenericVector x, GenericVector b) -> uint
        solve(self, PETScVector x, PETScVector b) -> uint
        solve(self, GenericMatrix A, GenericVector x, GenericVector b) -> uint
        solve(self, PETScBaseMatrix A, PETScVector x, PETScVector b) -> uint

        Solve linear system Ax = b. 
        """

    def ksp(self):
        """ksp(self) -> boost::shared_ptr<(KSP)>"""

    def default_parameters():
        """default_parameters() -> Parameters"""

def PETScKrylovSolver_default_parameters():
  """PETScKrylovSolver_default_parameters() -> Parameters"""

class PETScLUSolver(GenericLUSolver,PETScObject):
    """Proxy of C++ dolfin::PETScLUSolver class"""

    def __init__(self, *args): 
        """
        __init__(self, string lu_package = "default") -> PETScLUSolver
        __init__(self) -> PETScLUSolver
        __init__(self, GenericMatrix A, string lu_package = "default") -> PETScLUSolver
        __init__(self, GenericMatrix A) -> PETScLUSolver
        __init__(self, boost::shared_ptr<(q(const).dolfin::PETScMatrix)> A, 
            string lu_package = "default") -> PETScLUSolver
        __init__(self, boost::shared_ptr<(q(const).dolfin::PETScMatrix)> A) -> PETScLUSolver
        """

    def set_operator(self, *args):
        """
        set_operator(self, GenericMatrix A)
        set_operator(self, PETScMatrix A)

        Set operator (matrix). 
        """

    def solve(self, *args):
        """
        solve(self, GenericVector x, GenericVector b) -> uint
        solve(self, GenericMatrix A, GenericVector x, GenericVector b) -> uint
        solve(self, PETScMatrix A, PETScVector x, PETScVector b) -> uint

        Solve linear system Ax = b. 
        """

    def ksp(self):
        """ksp(self) -> boost::shared_ptr<(KSP)>"""

    def default_parameters():
        """default_parameters() -> Parameters"""

def PETScLUSolver_default_parameters():
  """PETScLUSolver_default_parameters() -> Parameters"""

class CholmodCholeskySolver(GenericLinearSolver):
    """
    This class implements the direct solution (Cholesky factorization) of
    linear systems of the form Ax = b. Sparse matrices are solved using
    CHOLMODhttp://www.cise.ufl.edu/research/sparse/cholmod/ if installed.

    C++ includes: CholmodCholeskySolver.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> CholmodCholeskySolver
        __init__(self, GenericMatrix A) -> CholmodCholeskySolver
        __init__(self, boost::shared_ptr<(q(const).dolfin::GenericMatrix)> A) -> CholmodCholeskySolver

        Constructor. 
        """

    def factorize(self, *args):
        """
        factorize(self, GenericMatrix A) -> uint

        Cholesky-factor sparse matrix A if CHOLMOD is installed. 
        """

    def factorized_solve(self, *args):
        """
        factorized_solve(self, GenericVector x, GenericVector b) -> uint

        Solve factorized system (CHOLMOD). 
        """

    def default_parameters():
        """default_parameters() -> Parameters"""

def CholmodCholeskySolver_default_parameters():
  """CholmodCholeskySolver_default_parameters() -> Parameters"""

class UmfpackLUSolver(GenericLUSolver):
    """
    This class implements the direct solution (LU factorization) of linear
    systems of the form Ax = b using UMFPACK
    (http://www.cise.ufl.edu/research/sparse/umfpack/) if installed.

    C++ includes: UmfpackLUSolver.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> UmfpackLUSolver
        __init__(self, GenericMatrix A) -> UmfpackLUSolver
        __init__(self, boost::shared_ptr<(q(const).dolfin::GenericMatrix)> A) -> UmfpackLUSolver

        Constructor. 
        """

    def solve(self, *args):
        """
        solve(self, GenericVector x, GenericVector b) -> uint
        solve(self, GenericMatrix A, GenericVector x, GenericVector b) -> uint

        Solve linear system. 
        """

    def default_parameters():
        """default_parameters() -> Parameters"""

def UmfpackLUSolver_default_parameters():
  """UmfpackLUSolver_default_parameters() -> Parameters"""

class ITLKrylovSolver(GenericLinearSolver):
    """Proxy of C++ dolfin::ITLKrylovSolver class"""

    def __init__(self, method = "default", pc_type = "default"): 
        """
        __init__(self, string method = "default", string pc_type = "default") -> ITLKrylovSolver
        __init__(self, string method = "default") -> ITLKrylovSolver
        __init__(self) -> ITLKrylovSolver
        """

    def solve(self, *args):
        """
        solve(self, GenericVector x, GenericVector b) -> uint
        solve(self, MTL4Vector x, MTL4Vector b) -> uint
        solve(self, GenericMatrix A, GenericVector x, GenericVector b) -> uint

        Solve linear system Ax = b. 
        """

    def default_parameters():
        """default_parameters() -> Parameters"""

def ITLKrylovSolver_default_parameters():
  """ITLKrylovSolver_default_parameters() -> Parameters"""

class MTL4Matrix(GenericMatrix):
    """Proxy of C++ dolfin::MTL4Matrix class"""

    def copy(self):
        """copy(self) -> MTL4Matrix"""

    def zero(self, *args):
        """
        zero(self)
        zero(self, uint m)

        Set given rows to zero. 
        """

    def __init__(self, *args): 
        """
        __init__(self) -> MTL4Matrix
        __init__(self, uint M, uint N) -> MTL4Matrix
        __init__(self, MTL4Matrix A) -> MTL4Matrix
        __init__(self, uint M, uint N, uint nz) -> MTL4Matrix
        """

    def assign(self, *args):
        """
        assign(self, GenericMatrix A) -> GenericMatrix
        assign(self, MTL4Matrix A) -> MTL4Matrix
        """

class STLMatrix(GenericMatrix):
    """
    Simple implementation of a GenericMatrix for experimenting with new
    assembly. Not sure this will be used later but it might be useful.

    C++ includes: STLMatrix.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> STLMatrix
        __init__(self, uint M, uint N) -> STLMatrix
        __init__(self, STLMatrix A) -> STLMatrix

        Copy constructor. 
        """

    def copy(self):
        """
        copy(self) -> STLMatrix

        Return copy of tensor. 
        """

    def zero(self, *args):
        """
        zero(self)
        zero(self, uint m)

        Set given rows to zero. 
        """

    def resize(self, *args):
        """
        resize(self, uint M, uint N)
        resize(self, uint rank, uint dims, bool reset)

        Resize tensor of given rank and dimensions. 
        """

class uBLASVector(GenericVector):
    """
    This class provides a simple vector class based on uBLAS. It is a
    simple wrapper for a uBLAS vector implementing the GenericVector
    interface.

    The interface is intentionally simple. For advanced usage, access the
    underlying uBLAS vector and use the standard uBLAS interface which is
    documented athttp://www.boost.org/libs/numeric/ublas/doc/index.htm.

    C++ includes: uBLASVector.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> uBLASVector
        __init__(self, uint N) -> uBLASVector
        __init__(self, uBLASVector x) -> uBLASVector
        __init__(self, boost::shared_ptr<(dolfin::ublas_vector)> x) -> uBLASVector

        Construct vector from a ublas_vector. 
        """

    def copy(self):
        """
        copy(self) -> uBLASVector

        Create copy of tensor. 
        """

    def vec(self, *args):
        """
        vec(self) -> ublas_vector
        vec(self) -> ublas_vector

        Return reference to uBLAS vector (non-const version). 
        """

    def _assign(self, *args):
        """
        _assign(self, GenericVector x) -> GenericVector
        _assign(self, double a) -> uBLASVector
        _assign(self, uBLASVector x) -> uBLASVector
        """

    def _data(self):
        """_data(self) -> PyObject"""

    def data(self):
        """Return an array to the underlaying data"""

class PETScVector(GenericVector,PETScObject):
    """Proxy of C++ dolfin::PETScVector class"""

    def __init__(self, *args): 
        """
        __init__(self, string type = "global") -> PETScVector
        __init__(self) -> PETScVector
        __init__(self, uint N, string type = "global") -> PETScVector
        __init__(self, uint N) -> PETScVector
        __init__(self, PETScVector x) -> PETScVector
        __init__(self, boost::shared_ptr<(Vec)> x) -> PETScVector
        """

    def copy(self):
        """copy(self) -> PETScVector"""

    def get_local(self, *args):
        """
        get_local(self, double block, uint m)
        get_local(self, DoubleArray values)

        Get all values on local process. 
        """

    def sum(self, *args):
        """
        sum(self) -> double
        sum(self, dolfin::Array<(dolfin::uint)> rows) -> double

        Return sum of selected rows in vector. Repeated entries only summed
        once. 
        """

    def vec(self):
        """vec(self) -> boost::shared_ptr<(Vec)>"""

    def _assign(self, *args):
        """
        _assign(self, GenericVector x) -> GenericVector
        _assign(self, double a) -> PETScVector
        _assign(self, PETScVector x) -> PETScVector
        """

class MTL4Vector(GenericVector):
    """Proxy of C++ dolfin::MTL4Vector class"""

    def __init__(self, *args): 
        """
        __init__(self) -> MTL4Vector
        __init__(self, uint N) -> MTL4Vector
        __init__(self, MTL4Vector x) -> MTL4Vector
        """

    def copy(self):
        """copy(self) -> MTL4Vector"""

    def _assign(self, *args):
        """
        _assign(self, double a) -> MTL4Vector
        _assign(self, GenericVector x) -> GenericVector
        _assign(self, MTL4Vector x) -> MTL4Vector
        """

    def _data(self):
        """_data(self) -> PyObject"""

    def data(self):
        """Return an array to the underlaying data"""

class SparsityPattern(GenericSparsityPattern):
    """
    This class implements the GenericSparsityPattern interface. It is used
    by most linear algebra backends, except for Epetra which uses a
    special/native implementation.

    C++ includes: SparsityPattern.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, Type type) -> SparsityPattern

        Create empty sparsity pattern. 
        """

    def str(self):
        """
        str(self) -> string

        Return informal string representation (pretty-print). 
        """

    def diagonal_pattern(self):
        """
        diagonal_pattern(self) -> std::vector<(dolfin::Set<(dolfin::uint)>)>

        Return underlying sparsity pattern (diagonal). 
        """

    def off_diagonal_pattern(self):
        """
        off_diagonal_pattern(self) -> std::vector<(dolfin::Set<(dolfin::uint)>)>

        Return underlying sparsity pattern (off-diagional). 
        """

class LinearAlgebraFactory(object):
    """Proxy of C++ dolfin::LinearAlgebraFactory class"""

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def create_matrix(self):
        """
        create_matrix(self) -> GenericMatrix

        Create empty matrix. 
        """

    def create_vector(self):
        """
        create_vector(self) -> GenericVector

        Create empty vector (global). 
        """

    def create_local_vector(self):
        """
        create_local_vector(self) -> GenericVector

        Create empty vector (local). 
        """

    def create_pattern(self):
        """
        create_pattern(self) -> GenericSparsityPattern

        Create empty sparsity pattern (returning zero if not used/needed). 
        """

    def create_lu_solver(self):
        """
        create_lu_solver(self) -> GenericLinearSolver

        Create LU solver. 
        """

    def create_krylov_solver(self, *args):
        """
        create_krylov_solver(self, string method, string pc) -> GenericLinearSolver

        Create Krylov solver. 
        """

class DefaultFactory(LinearAlgebraFactory):
    """Proxy of C++ dolfin::DefaultFactory class"""

    def __init__(self): 
        """
        __init__(self) -> DefaultFactory

        Constructor. 
        """

class PETScUserPreconditioner(PETScObject):
    """Proxy of C++ dolfin::PETScUserPreconditioner class"""

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def setup(*args):
        """setup(KSP ksp, PETScUserPreconditioner pc)"""

    def solve(self, *args):
        """solve(self, PETScVector x, PETScVector b)"""

def PETScUserPreconditioner_setup(*args):
  """PETScUserPreconditioner_setup(KSP ksp, PETScUserPreconditioner pc)"""

class PETScFactory(LinearAlgebraFactory):
    """Proxy of C++ dolfin::PETScFactory class"""

    def __init__(self, *args, **kwargs):
        """No constructor defined"""

    def create_matrix(self):
        """create_matrix(self) -> PETScMatrix"""

    def create_vector(self):
        """create_vector(self) -> PETScVector"""

    def create_local_vector(self):
        """
        create_local_vector(self) -> PETScVector

        Create empty vector (local). 
        """

    def create_pattern(self):
        """create_pattern(self) -> SparsityPattern"""

    def create_lu_solver(self):
        """
        create_lu_solver(self) -> PETScLUSolver

        Create LU solver. 
        """

    def create_krylov_solver(self, *args):
        """
        create_krylov_solver(self, string method, string pc) -> PETScKrylovSolver

        Create Krylov solver. 
        """

    def instance():
        """instance() -> PETScFactory"""

def PETScFactory_instance():
  """PETScFactory_instance() -> PETScFactory"""

class MTL4Factory(LinearAlgebraFactory):
    """Proxy of C++ dolfin::MTL4Factory class"""

    def __init__(self, *args, **kwargs):
        """No constructor defined"""

    def create_matrix(self):
        """create_matrix(self) -> MTL4Matrix"""

    def create_vector(self):
        """create_vector(self) -> MTL4Vector"""

    def create_local_vector(self):
        """
        create_local_vector(self) -> MTL4Vector

        Create empty vector (local). 
        """

    def create_lu_solver(self):
        """
        create_lu_solver(self) -> UmfpackLUSolver

        Create LU solver. 
        """

    def create_krylov_solver(self, *args):
        """
        create_krylov_solver(self, string method, string pc) -> ITLKrylovSolver

        Create Krylov solver. 
        """

    def instance():
        """instance() -> MTL4Factory"""

def MTL4Factory_instance():
  """MTL4Factory_instance() -> MTL4Factory"""

class STLFactory(LinearAlgebraFactory):
    """Proxy of C++ dolfin::STLFactory class"""

    def __init__(self, *args, **kwargs):
        """No constructor defined"""

    def create_matrix(self):
        """
        create_matrix(self) -> STLMatrix

        Create empty matrix. 
        """

    def create_vector(self):
        """
        create_vector(self) -> uBLASVector

        Create empty vector (global). 
        """

    def create_local_vector(self):
        """
        create_local_vector(self) -> uBLASVector

        Create empty vector (local). 
        """

    def instance():
        """instance() -> STLFactory"""

def STLFactory_instance():
  """STLFactory_instance() -> STLFactory"""

class SLEPcEigenSolver(Variable,PETScObject):
    """Proxy of C++ dolfin::SLEPcEigenSolver class"""

    def __init__(self): 
        """__init__(self) -> SLEPcEigenSolver"""

    def solve(self, *args):
        """
        solve(self, PETScMatrix A)
        solve(self, PETScMatrix A, uint n)
        solve(self, PETScMatrix A, PETScMatrix B)
        solve(self, PETScMatrix A, PETScMatrix B, uint n)
        """

    def get_iteration_number(self):
        """get_iteration_number(self) -> int"""

    def get_number_converged(self):
        """get_number_converged(self) -> int"""

    def default_parameters():
        """default_parameters() -> Parameters"""

    def _get_eigenvalue(self, *args):
        """_get_eigenvalue(self, int i) -> PyObject"""

    def _get_eigenpair(self, *args):
        """_get_eigenpair(self, PETScVector r, PETScVector c, int i) -> PyObject"""

    def get_eigenpair(self, i = 0, r_vec = None, c_vec = None,):
        """Gets the i-th solution of the eigenproblem"""

    def get_eigenvalue(self, i = 0):
        """Gets the i-th eigenvalue of the eigenproblem"""

def SLEPcEigenSolver_default_parameters():
  """SLEPcEigenSolver_default_parameters() -> Parameters"""

class uBLASPreconditioner(object):
    """
    This class specifies the interface for preconditioners for the uBLAS
    Krylov solver.

    C++ includes: uBLASPreconditioner.h 
    """

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def init(self, *args):
        """
        init(self, uBLASSparseMatrix P)
        init(self, uBLASDenseMatrix P)
        init(self, uBLASKrylovMatrix P)

        Initialise preconditioner (virtual matrix). 
        """

    def solve(self, *args):
        """
        solve(self, uBLASVector x, uBLASVector b)

        Solve linear system (M^-1)Ax = y. 
        """

class uBLASKrylovSolver(GenericLinearSolver):
    """
    This class implements Krylov methods for linear systems of the form Ax
    = b using uBLAS data types.

    C++ includes: uBLASKrylovSolver.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, string solver_type = "default", string pc_type = "default") -> uBLASKrylovSolver
        __init__(self, string solver_type = "default") -> uBLASKrylovSolver
        __init__(self) -> uBLASKrylovSolver
        __init__(self, uBLASPreconditioner pc) -> uBLASKrylovSolver
        __init__(self, string solver_type, uBLASPreconditioner preconditioner) -> uBLASKrylovSolver

        Create Krylov solver for a particular method and uBLASPreconditioner.

        """

    def solve(self, *args):
        """
        solve(self, GenericMatrix A, GenericVector x, GenericVector b) -> uint
        solve(self, uBLASDenseMatrix A, uBLASVector x, uBLASVector b) -> uint
        solve(self, uBLASSparseMatrix A, uBLASVector x, uBLASVector b) -> uint
        solve(self, uBLASKrylovMatrix A, uBLASVector x, uBLASVector b) -> uint

        Solve linear system Ax = b and return number of iterations (virtual
        matrix). 
        """

    def default_parameters():
        """default_parameters() -> Parameters"""

def uBLASKrylovSolver_default_parameters():
  """uBLASKrylovSolver_default_parameters() -> Parameters"""

class uBLASILUPreconditioner(uBLASPreconditioner):
    """
    This class implements an incomplete LU factorization (ILU)
    preconditioner for the uBLAS Krylov solver.

    C++ includes: uBLASILUPreconditioner.h 
    """
    def __init__(self, *args): 
        """
        __init__(self, Parameters krylov_parameters) -> uBLASILUPreconditioner

        Constructor. 
        """

class Vector(GenericVector):
    """
    This class provides the default DOLFIN vector class, based on the
    default DOLFIN linear algebra backend.

    C++ includes: Vector.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> Vector
        __init__(self, uint N) -> Vector
        __init__(self, Vector x) -> Vector
        __init__(self, GenericVector x) -> Vector

        Create a Vector from a GenericVetor. 
        """

    def copy(self):
        """
        copy(self) -> Vector

        Return copy of tensor. 
        """

    def get_local(self, *args):
        """
        get_local(self, double block, uint m)
        get_local(self, DoubleArray values)

        Get all values on local process. 
        """

    def sum(self, *args):
        """
        sum(self) -> double
        sum(self, dolfin::Array<(dolfin::uint)> rows) -> double

        Return sum of selected rows in vector. Repeated entries only summed
        once. 
        """

    def _assign(self, *args):
        """
        _assign(self, GenericVector x) -> GenericVector
        _assign(self, double a) -> Vector
        _assign(self, Vector x) -> Vector
        """

    def _data(self):
        """_data(self) -> PyObject"""

    def data(self):
        """Return an array to the underlaying data"""

class Matrix(GenericMatrix):
    """
    This class provides the default DOLFIN matrix class, based on the
    default DOLFIN linear algebra backend.

    C++ includes: Matrix.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> Matrix
        __init__(self, uint M, uint N) -> Matrix
        __init__(self, Matrix A) -> Matrix

        Copy constructor. 
        """

    def copy(self):
        """
        copy(self) -> Matrix

        Return copy of tensor. 
        """

    def zero(self, *args):
        """
        zero(self)
        zero(self, uint m)

        Set given rows to zero. 
        """

    def assign(self, *args):
        """
        assign(self, GenericMatrix A) -> GenericMatrix
        assign(self, Matrix A) -> Matrix
        """

class Scalar(GenericTensor):
    """
    This class represents a real-valued scalar quantity and implements the
    GenericTensor interface for scalars.

    C++ includes: Scalar.h 
    """

    def __init__(self): 
        """
        __init__(self) -> Scalar

        Create zero scalar. 
        """

    def copy(self):
        """
        copy(self) -> Scalar

        Return copy of tensor. 
        """

    def __float__(self):
        """__float__(self) -> double"""

    def assign(self, *args):
        """assign(self, double value) -> Scalar"""

    def getval(self):
        """
        getval(self) -> double

        Get value. 
        """

class LinearSolver(GenericLinearSolver):
    """
    This class provides a general solver for linear systems Ax = b.

    C++ includes: LinearSolver.h 
    """

    def __init__(self, solver_type = "lu", pc_type = "ilu"): 
        """
        __init__(self, string solver_type = "lu", string pc_type = "ilu") -> LinearSolver
        __init__(self, string solver_type = "lu") -> LinearSolver
        __init__(self) -> LinearSolver

        Create linear solver. 
        """

    def solve(self, *args):
        """
        solve(self, GenericMatrix A, GenericVector x, GenericVector b) -> uint
        solve(self, GenericVector x, GenericVector b) -> uint

        Solve linear system Ax = b. 
        """

    def default_parameters():
        """default_parameters() -> Parameters"""

def LinearSolver_default_parameters():
  """LinearSolver_default_parameters() -> Parameters"""

class KrylovSolver(GenericLinearSolver):
    """
    This class defines an interface for a Krylov solver. The approproiate
    solver is chosen on the basis of the matrix/vector type.

    C++ includes: KrylovSolver.h 
    """

    def __init__(self, solver_type = "default", pc_type = "default"): 
        """
        __init__(self, string solver_type = "default", string pc_type = "default") -> KrylovSolver
        __init__(self, string solver_type = "default") -> KrylovSolver
        __init__(self) -> KrylovSolver

        Create Krylov solver. 
        """

    def solve(self, *args):
        """
        solve(self, GenericVector x, GenericVector b) -> uint
        solve(self, GenericMatrix A, GenericVector x, GenericVector b) -> uint

        Solve linear system Ax = b. 
        """

    def default_parameters():
        """default_parameters() -> Parameters"""

def KrylovSolver_default_parameters():
  """KrylovSolver_default_parameters() -> Parameters"""

class LUSolver(GenericLUSolver):
    """Proxy of C++ dolfin::LUSolver class"""

    def __init__(self, *args): 
        """
        __init__(self, string type = "lu") -> LUSolver
        __init__(self) -> LUSolver
        __init__(self, GenericMatrix A, string type = "lu") -> LUSolver
        __init__(self, GenericMatrix A) -> LUSolver

        Constructor. 
        """

    def solve(self, *args):
        """
        solve(self, GenericVector x, GenericVector b) -> uint
        solve(self, GenericMatrix A, GenericVector x, GenericVector b) -> uint

        Solve linear system. 
        """

    def default_parameters():
        """default_parameters() -> Parameters"""

def LUSolver_default_parameters():
  """LUSolver_default_parameters() -> Parameters"""

class SingularSolver(Variable):
    """
    This class provides a linear solver for singular linear systems Ax = b
    where A has a one-dimensional null-space (kernel). This may happen for
    example when solving Poisson's equation with pure Neumann boundary
    conditions.

    The solver attempts to create an extended non-singular system by
    adding the constraint [1, 1, 1, ...]^T x = 0.

    If an optional mass matrix M is supplied, the solver attempts to
    create an extended non-singular system by adding the constraint m^T x
    = 0 where m is the lumped mass matrix. This corresponds to setting the
    average (integral) of the finite element function with coefficients x
    to zero.

    The solver makes not attempt to check that the null-space is indeed
    one-dimensional. It is also assumed that the system Ax = b retains its
    sparsity pattern between calls to solve().

    C++ includes: SingularSolver.h 
    """

    def __init__(self, solver_type = "lu", pc_type = "ilu"): 
        """
        __init__(self, string solver_type = "lu", string pc_type = "ilu") -> SingularSolver
        __init__(self, string solver_type = "lu") -> SingularSolver
        __init__(self) -> SingularSolver

        Create linear solver. 
        """

    def solve(self, *args):
        """
        solve(self, GenericMatrix A, GenericVector x, GenericVector b) -> uint
        solve(self, GenericMatrix A, GenericVector x, GenericVector b, 
            GenericMatrix M) -> uint

        Solve linear system Ax = b using mass matrix M for setting constraint.

        """

    def default_parameters():
        """default_parameters() -> Parameters"""

def SingularSolver_default_parameters():
  """SingularSolver_default_parameters() -> Parameters"""


def residual(*args):
  """
    residual(GenericMatrix A, GenericVector x, GenericVector b) -> double

    Compute residual ||Ax - b||. 
    """

class BlockVector(object):
    """Proxy of C++ dolfin::BlockVector class"""

    def __init__(self, n_ = 0, owner = False): 
        """
        __init__(self, uint n_ = 0, bool owner = False) -> BlockVector
        __init__(self, uint n_ = 0) -> BlockVector
        __init__(self) -> BlockVector

        Constructor. 
        """

    def copy(self):
        """
        copy(self) -> BlockVector

        Return copy of tensor. 
        """

    def __call__(self, *args):
        """__call__(self, uint i) -> SubVector"""

    def set(self, *args):
        """
        set(self, uint i, Vector v)

        Set function. 
        """

    def get(self, *args):
        """
        get(self, uint i) -> Vector
        get(self, uint arg0) -> Vector
        """

    def axpy(self, *args):
        """
        axpy(self, double a, BlockVector x)

        Add multiple of given vector (AXPY operation). 
        """

    def inner(self, *args):
        """
        inner(self, BlockVector x) -> double

        Return inner product with given vector. 
        """

    def norm(self, *args):
        """
        norm(self, string norm_type) -> double

        Return norm of vector. 
        """

    def min(self):
        """
        min(self) -> double

        Return minimum value of vector. 
        """

    def max(self):
        """
        max(self) -> double

        Return maximum value of vector. 
        """

    def __imul__(self, *args):
        """__imul__(self, double a) -> BlockVector"""

    def __idiv__(self, *args):
        """__idiv__(self, double a) -> BlockVector"""

    def __iadd__(self, *args):
        """__iadd__(self, BlockVector x) -> BlockVector"""

    def __isub__(self, *args):
        """__isub__(self, BlockVector x) -> BlockVector"""

    def size(self):
        """
        size(self) -> uint

        Number of vectors. 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). 
        """

    def __getitem__(self, i):
        """Missing docstring"""

    def __setitem__(self, i, m):
        """Missing docstring"""

    def __add__(self, v):
        """Missing docstring"""

    def __sub__(self, v):
        """Missing docstring"""

    def __mul__(self, v):
        """Missing docstring"""

    def __rmul__(self, v):
        """Missing docstring"""

def solve(*args):
  """
    solve(GenericMatrix A, GenericVector x, GenericVector b, 
        string solver_type = "lu", string pc_type = "default")
    solve(GenericMatrix A, GenericVector x, GenericVector b, 
        string solver_type = "lu")
    solve(GenericMatrix A, GenericVector x, GenericVector b)

    Solve linear system Ax = b. 
    """

def normalize(*args):
  """
    normalize(GenericVector x, string normalization_type = "average") -> double
    normalize(GenericVector x) -> double

    Normalize vector according to given normalization type. 
    """

class SubVector(object):
    """Proxy of C++ dolfin::SubVector class"""

    def __init__(self, *args): 
        """__init__(self, uint n, BlockVector bv) -> SubVector"""

class BlockMatrix(object):
    """Proxy of C++ dolfin::BlockMatrix class"""

    def __init__(self, n = 0, m = 0, owner = False): 
        """
        __init__(self, uint n = 0, uint m = 0, bool owner = False) -> BlockMatrix
        __init__(self, uint n = 0, uint m = 0) -> BlockMatrix
        __init__(self, uint n = 0) -> BlockMatrix
        __init__(self) -> BlockMatrix
        """

    def __call__(self, *args):
        """__call__(self, uint i, uint j) -> SubMatrix"""

    def set(self, *args):
        """
        set(self, uint i, uint j, Matrix m)

        Set block. 
        """

    def get(self, *args):
        """
        get(self, uint i, uint j) -> Matrix
        get(self, uint i, uint j) -> Matrix

        Get block. 
        """

    def size(self, *args):
        """
        size(self, uint dim) -> uint

        Return size of given dimension. 
        """

    def zero(self):
        """
        zero(self)

        Set all entries to zero and keep any sparse structure. 
        """

    def apply(self, *args):
        """
        apply(self, string mode)

        Finalize assembly of tensor. 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). 
        """

    def mult(self, *args):
        """
        mult(self, BlockVector x, BlockVector y, bool transposed = False)
        mult(self, BlockVector x, BlockVector y)

        Matrix-vector product, y = Ax. 
        """

    def __mul__(self, other):
        """Missing docstring"""

    def __getitem__(self, t):
        """Missing docstring"""

    def __setitem__(self, t, m):
        """Missing docstring"""

class SubMatrix(object):
    """Proxy of C++ dolfin::SubMatrix class"""

    def __init__(self, *args): 
        """__init__(self, uint row, uint col, BlockMatrix bm) -> SubMatrix"""

class uBLASSparseMatrix(GenericMatrix):
    """
    This class provides a simple matrix class based on uBLAS. It is a
    simple wrapper for a uBLAS matrix implementing the GenericMatrix
    interface.

    The interface is intentionally simple. For advanced usage, access the
    underlying uBLAS matrix and use the standard uBLAS interface which is
    documented athttp://www.boost.org/libs/numeric/ublas/doc/index.htm.

    Developer note: specialised member functions must be inlined to avoid
    link errors.

    C++ includes: uBLASMatrix.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> uBLASSparseMatrix
        __init__(self, uint M, uint N) -> uBLASSparseMatrix
        __init__(self, uBLASSparseMatrix A) -> uBLASSparseMatrix

        Create matrix from given uBLAS matrix expression. 
        """

    def copy(self):
        """
        copy(self) -> uBLASSparseMatrix

        Return copy of tensor. 
        """

    def zero(self, *args):
        """
        zero(self)
        zero(self, uint m)

        Set given rows to zero. 
        """

    def mat(self, *args):
        """
        mat(self) -> dolfin::ublas::compressed_matrix<(double,dolfin::ublas::row_major)>
        mat(self) -> dolfin::ublas::compressed_matrix<(double,dolfin::ublas::row_major)>

        Return reference to uBLAS matrix (non-const version). 
        """

    def solve(self, *args):
        """
        solve(self, uBLASVector x, uBLASVector b)

        Solve Ax = b out-of-place using uBLAS (A is not destroyed). 
        """

    def solveInPlace(self, *args):
        """
        solveInPlace(self, uBLASVector x, uBLASVector b)

        Solve Ax = b in-place using uBLAS(A is destroyed). 
        """

    def invert(self):
        """
        invert(self)

        Compute inverse of matrix. 
        """

    def lump(self, *args):
        """
        lump(self, uBLASVector m)

        Lump matrix into vector m. 
        """

    def compress(self):
        """
        compress(self)

        Compress matrix (eliminate all non-zeros from a sparse matrix). 
        """

    def assign(self, *args):
        """
        assign(self, GenericMatrix A) -> GenericMatrix
        assign(self, uBLASSparseMatrix A) -> uBLASSparseMatrix
        """

class uBLASDenseMatrix(GenericMatrix):
    """
    This class provides a simple matrix class based on uBLAS. It is a
    simple wrapper for a uBLAS matrix implementing the GenericMatrix
    interface.

    The interface is intentionally simple. For advanced usage, access the
    underlying uBLAS matrix and use the standard uBLAS interface which is
    documented athttp://www.boost.org/libs/numeric/ublas/doc/index.htm.

    Developer note: specialised member functions must be inlined to avoid
    link errors.

    C++ includes: uBLASMatrix.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> uBLASDenseMatrix
        __init__(self, uint M, uint N) -> uBLASDenseMatrix
        __init__(self, uBLASDenseMatrix A) -> uBLASDenseMatrix

        Create matrix from given uBLAS matrix expression. 
        """

    def copy(self):
        """
        copy(self) -> uBLASDenseMatrix

        Return copy of tensor. 
        """

    def zero(self, *args):
        """
        zero(self)
        zero(self, uint m)

        Set given rows to zero. 
        """

    def mat(self, *args):
        """
        mat(self) -> dolfin::ublas::matrix<(double)>
        mat(self) -> dolfin::ublas::matrix<(double)>

        Return reference to uBLAS matrix (non-const version). 
        """

    def solve(self, *args):
        """
        solve(self, uBLASVector x, uBLASVector b)

        Solve Ax = b out-of-place using uBLAS (A is not destroyed). 
        """

    def solveInPlace(self, *args):
        """
        solveInPlace(self, uBLASVector x, uBLASVector b)

        Solve Ax = b in-place using uBLAS(A is destroyed). 
        """

    def invert(self):
        """
        invert(self)

        Compute inverse of matrix. 
        """

    def lump(self, *args):
        """
        lump(self, uBLASVector m)

        Lump matrix into vector m. 
        """

    def compress(self):
        """
        compress(self)

        Compress matrix (eliminate all non-zeros from a sparse matrix). 
        """

    def assign(self, *args):
        """
        assign(self, GenericMatrix A) -> GenericMatrix
        assign(self, uBLASDenseMatrix A) -> uBLASDenseMatrix
        """

class uBLASSparseFactory(LinearAlgebraFactory):
    """Proxy of C++ dolfin::uBLASFactory<(dolfin::ublas_sparse_matrix)> class"""

    def __init__(self, *args, **kwargs):
        """No constructor defined"""

    def create_matrix(self):
        """
        create_matrix(self) -> uBLASSparseMatrix

        Create empty matrix. 
        """

    def create_vector(self):
        """
        create_vector(self) -> uBLASVector

        Create empty vector. 
        """

    def create_local_vector(self):
        """
        create_local_vector(self) -> uBLASVector

        Create empty vector (local). 
        """

    def create_pattern(self):
        """
        create_pattern(self) -> SparsityPattern

        Create empty sparsity pattern. 
        """

    def create_lu_solver(self):
        """
        create_lu_solver(self) -> UmfpackLUSolver

        Create LU solver. 
        """

    def instance():
        """instance() -> uBLASSparseFactory"""

def uBLASSparseFactory_instance():
  """uBLASSparseFactory_instance() -> uBLASSparseFactory"""

class uBLASDenseFactory(LinearAlgebraFactory):
    """Proxy of C++ dolfin::uBLASFactory<(dolfin::ublas_dense_matrix)> class"""

    def __init__(self, *args, **kwargs):
        """No constructor defined"""

    def create_matrix(self):
        """
        create_matrix(self) -> uBLASDenseMatrix

        Create empty matrix. 
        """

    def create_vector(self):
        """
        create_vector(self) -> uBLASVector

        Create empty vector. 
        """

    def create_local_vector(self):
        """
        create_local_vector(self) -> uBLASVector

        Create empty vector (local). 
        """

    def create_pattern(self):
        """
        create_pattern(self) -> SparsityPattern

        Create empty sparsity pattern. 
        """

    def create_lu_solver(self):
        """
        create_lu_solver(self) -> UmfpackLUSolver

        Create LU solver. 
        """

    def instance():
        """instance() -> uBLASDenseFactory"""

def uBLASDenseFactory_instance():
  """uBLASDenseFactory_instance() -> uBLASDenseFactory"""

def _get_vector_values(*args):
  """_get_vector_values(GenericVector self) -> DoubleArray"""

def _contains(*args):
  """_contains(GenericVector self, double value) -> bool"""

def _compare_vector_with_value(*args):
  """_compare_vector_with_value(GenericVector self, double value, DolfinCompareType cmp_type) -> PyObject"""

def _compare_vector_with_vector(*args):
  """_compare_vector_with_vector(GenericVector self, GenericVector other, DolfinCompareType cmp_type) -> PyObject"""

def _get_vector_single_item(*args):
  """_get_vector_single_item(GenericVector self, int index) -> double"""

def _get_vector_sub_vector(*args):
  """_get_vector_sub_vector(GenericVector self, PyObject op) -> GenericVector"""

def _set_vector_items_vector(*args):
  """_set_vector_items_vector(GenericVector self, PyObject op, GenericVector other)"""

def _set_vector_items_array_of_float(*args):
  """_set_vector_items_array_of_float(GenericVector self, PyObject op, PyObject other)"""

def _set_vector_items_value(*args):
  """_set_vector_items_value(GenericVector self, PyObject op, double value)"""

def _get_matrix_single_item(*args):
  """_get_matrix_single_item(GenericMatrix self, int m, int n) -> double"""

def _get_matrix_sub_vector(*args):
  """_get_matrix_sub_vector(GenericMatrix self, uint single, PyObject op, bool row) -> GenericVector"""

def _get_matrix_sub_matrix(*args):
  """_get_matrix_sub_matrix(GenericMatrix self, PyObject row_op, PyObject col_op) -> GenericMatrix"""

def _set_matrix_single_item(*args):
  """_set_matrix_single_item(GenericMatrix self, int m, int n, double value)"""

def _set_matrix_items_array_of_float(*args):
  """_set_matrix_items_array_of_float(GenericMatrix self, PyObject op, PyObject other)"""

def _set_matrix_items_matrix(*args):
  """_set_matrix_items_matrix(GenericMatrix self, GenericMatrix arg1)"""

def _set_matrix_items_vector(*args):
  """_set_matrix_items_vector(GenericMatrix self, PyObject op, GenericVector other)"""

def has_type_uBLASVector(*args):
  """has_type_uBLASVector(GenericTensor tensor) -> bool"""

def down_cast_uBLASVector(*args):
  """down_cast_uBLASVector(GenericTensor tensor) -> uBLASVector"""

def has_type_uBLASSparseMatrix(*args):
  """has_type_uBLASSparseMatrix(GenericTensor tensor) -> bool"""

def down_cast_uBLASSparseMatrix(*args):
  """down_cast_uBLASSparseMatrix(GenericTensor tensor) -> uBLASSparseMatrix"""

def has_type_uBLASDenseMatrix(*args):
  """has_type_uBLASDenseMatrix(GenericTensor tensor) -> bool"""

def down_cast_uBLASDenseMatrix(*args):
  """down_cast_uBLASDenseMatrix(GenericTensor tensor) -> uBLASDenseMatrix"""

def has_type_PETScVector(*args):
  """has_type_PETScVector(GenericTensor tensor) -> bool"""

def down_cast_PETScVector(*args):
  """down_cast_PETScVector(GenericTensor tensor) -> PETScVector"""

def has_type_PETScMatrix(*args):
  """has_type_PETScMatrix(GenericTensor tensor) -> bool"""

def down_cast_PETScMatrix(*args):
  """down_cast_PETScMatrix(GenericTensor tensor) -> PETScMatrix"""

def has_type_MTL4Vector(*args):
  """has_type_MTL4Vector(GenericTensor tensor) -> bool"""

def down_cast_MTL4Vector(*args):
  """down_cast_MTL4Vector(GenericTensor tensor) -> MTL4Vector"""

def has_type_MTL4Matrix(*args):
  """has_type_MTL4Matrix(GenericTensor tensor) -> bool"""

def down_cast_MTL4Matrix(*args):
  """down_cast_MTL4Matrix(GenericTensor tensor) -> MTL4Matrix"""

def get_tensor_type(tensor):
    """Return the concrete subclass of tensor."""

def has_type(tensor, subclass):
    """Return wether tensor is of the given subclass."""

def down_cast(tensor, subclass=None):
    """Cast tensor to the given subclass, passing the wrong class is an error."""


class NewtonSolver(Variable):
    """
    This class defines a Newton solver for equations of the form F(u) = 0.

    C++ includes: NewtonSolver.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, string solver_type = "lu", string pc_type = "default") -> NewtonSolver
        __init__(self, string solver_type = "lu") -> NewtonSolver
        __init__(self) -> NewtonSolver
        __init__(self, GenericLinearSolver solver, LinearAlgebraFactory factory) -> NewtonSolver

        Create nonlinear solver using provided linear solver and linear
        algebra backend determined by factory 
        """

    def solve(self, *args):
        """
        solve(self, NonlinearProblem nonlinear_function, GenericVector x) -> std::pair<(dolfin::uint,bool)>

        Solve abstract nonlinear problem F(x) = 0 for given vector F and
        Jacobian dF/dx 
        """

    def iteration(self):
        """
        iteration(self) -> uint

        Return Newton iteration number. 
        """

    def residual(self):
        """
        residual(self) -> double

        Return current residual. 
        """

    def relative_residual(self):
        """
        relative_residual(self) -> double

        Return current relative residual. 
        """

    def linear_solver(self):
        """
        linear_solver(self) -> GenericLinearSolver

        Return the linear solver. 
        """

    def default_parameters():
        """default_parameters() -> Parameters"""

def NewtonSolver_default_parameters():
  """NewtonSolver_default_parameters() -> Parameters"""

class CellType(object):
    """
    This class provides a common interface for different cell types. Each
    cell type implements mesh functionality that is specific to a certain
    type of cell.

    C++ includes: CellType.h 
    """

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def create(*args):
        """
        create(Type type) -> CellType
        create(string type) -> CellType
        """

    def string2type(*args):
        """string2type(string type) -> Type"""

    def type2string(*args):
        """type2string(Type type) -> string"""

    def cell_type(self):
        """
        cell_type(self) -> Type

        Return type of cell. 
        """

    def facet_type(self):
        """
        facet_type(self) -> Type

        Return type of cell for facets. 
        """

    def dim(self):
        """
        dim(self) -> uint

        Return topological dimension of cell. 
        """

    def num_entities(self, *args):
        """
        num_entities(self, uint dim) -> uint

        Return number of entitites of given topological dimension. 
        """

    def num_vertices(self, *args):
        """
        num_vertices(self, uint dim) -> uint

        Return number of vertices for entity of given topological dimension.

        """

    def orientation(self, *args):
        """
        orientation(self, Cell cell) -> uint

        Return orientation of the cell. 
        """

    def create_entities(self, *args):
        """
        create_entities(self, uint e, uint dim, uint v)

        Create entities e of given topological dimension from vertices v. 
        """

    def refine_cell(self, *args):
        """
        refine_cell(self, Cell cell, MeshEditor editor, uint current_cell)

        Refine cell uniformly. 
        """

    def volume(self, *args):
        """
        volume(self, MeshEntity entity) -> double

        Compute (generalized) volume of mesh entity. 
        """

    def diameter(self, *args):
        """
        diameter(self, MeshEntity entity) -> double

        Compute diameter of mesh entity. 
        """

    def normal(self, *args):
        """
        normal(self, Cell cell, uint facet, uint i) -> double
        normal(self, Cell cell, uint facet) -> Point

        Compute of given facet with respect to the cell. 
        """

    def facet_area(self, *args):
        """
        facet_area(self, Cell cell, uint facet) -> double

        Compute the area/length of given facet with respect to the cell. 
        """

    def order(self, *args):
        """
        order(self, Cell cell, MeshFunctionUInt global_vertex_indices)

        Order entities locally. 
        """

    def ordered(self, *args):
        """
        ordered(self, Cell cell, MeshFunctionUInt global_vertex_indices) -> bool

        Check if entities are ordered. 
        """

    def description(self, *args):
        """
        description(self, bool plural) -> string

        Return description of cell type. 
        """

def CellType_create(*args):
  """
    create(Type type) -> CellType
    CellType_create(string type) -> CellType
    """

def CellType_string2type(*args):
  """CellType_string2type(string type) -> Type"""

def CellType_type2string(*args):
  """CellType_type2string(Type type) -> string"""

class MeshEntity(object):
    """
    A MeshEntity represents a mesh entity associated with a specific
    topological dimension of some mesh.

    C++ includes: MeshEntity.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> MeshEntity
        __init__(self, Mesh mesh, uint dim, uint index) -> MeshEntity

        Constructor. 
        """

    def __eq__(self, *args):
        """__eq__(self, MeshEntity another) -> bool"""

    def __ne__(self, *args):
        """__ne__(self, MeshEntity another) -> bool"""

    def mesh(self):
        """
        mesh(self) -> Mesh

        Return mesh associated with mesh entity. 
        """

    def dim(self):
        """
        dim(self) -> uint

        Return topological dimension. 
        """

    def num_entities(self, *args):
        """
        num_entities(self, uint dim) -> uint

        Return number of incident mesh entities of given topological
        dimension. 
        """

    def incident(self, *args):
        """
        incident(self, MeshEntity entity) -> bool

        Check if given entity is indicent. 
        """

    def intersects(self, *args):
        """
        intersects(self, Point point) -> bool
        intersects(self, MeshEntity entity) -> bool

        Check if given entity intersects (using inexact but fast numerics). 
        """

    def intersects_exactly(self, *args):
        """
        intersects_exactly(self, Point point) -> bool
        intersects_exactly(self, MeshEntity entity) -> bool

        Check if given entity intersects (using exact numerics). 
        """

    def index(self, *args):
        """
        index(self) -> uint
        index(self, MeshEntity entity) -> uint

        Compute local index of given incident entity (error if not found). 
        """

    def midpoint(self):
        """
        midpoint(self) -> Point

        Compute midpoint of cell. 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). 
        """

    def entities(self, dim):
        """ Return number of incident mesh entities of given topological dimension"""

class entities(object):
    """
    MeshEntityIterator provides a common iterator for mesh entities over
    meshes, boundaries and incidence relations. The basic use is
    illustrated below.

    The following example shows how to iterate over all mesh entities of a
    mesh of topological dimension dim:

    for ( MeshEntityIterator e(mesh, dim); !e. end(); ++e) { e->foo(); }

    The following example shows how to iterate over mesh entities of
    topological dimension dim connected (incident) to some mesh entity f:

    for ( MeshEntityIterator e(f, dim); !e. end(); ++e) { e->foo(); }

    In addition to the general iterator, a set of specific named iterators
    are provided for entities of type Vertex, Edge, Face, Facet and Cell.
    These iterators are defined along with their respective classes.

    C++ includes: MeshEntityIterator.h 
    """

    def __init__(self, *args): 
        """
        MeshEntityIterator() -> entities
        MeshEntityIterator(Mesh mesh, uint dim) -> entities
        MeshEntityIterator(MeshEntity entity, uint dim) -> entities
        __init__(self, entities it) -> entities

        Copy Constructor. 
        """

    def _increment(self):
        """_increment(self) -> entities"""

    def _decrease(self):
        """_decrease(self) -> entities"""

    def pos(self):
        """
        pos(self) -> uint

        Return current position. 
        """

    def __eq__(self, *args):
        """__eq__(self, entities it) -> bool"""

    def __ne__(self, *args):
        """__ne__(self, entities it) -> bool"""

    def _dereference(self):
        """_dereference(self) -> MeshEntity"""

    def end(self):
        """
        end(self) -> bool

        Check if iterator has reached the end. 
        """

    def end_iterator(self):
        """
        end_iterator(self) -> entities

        Provide a safeguard iterator pointing beyond the end of an iteration
        process, either iterating over the mesh /or incident entities. Added
        to be bit more like STL iteratoren, since many algorithms rely on a
        kind of beyond iterator. 
        """

    def __iter__(self):
        """Missing docstring"""

    def next(self):
        """Missing docstring"""

def __mul__(*args):
  """__mul__(double a, Point p) -> Point"""

def __lshift__(*args):
  """__lshift__(std::ostream stream, Point point) -> std::ostream"""

class Vertex(MeshEntity):
    """
    A Vertex is a MeshEntity of topological dimension 0.

    C++ includes: Vertex.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, Mesh mesh, uint index) -> Vertex
        __init__(self, MeshEntity entity) -> Vertex

        Create vertex from mesh entity. 
        """

    def point(self):
        """
        point(self) -> Point

        Return vertex coordinates as a 3D point value. 
        """

    def x(self, *args):
        """
        x(self, uint i) -> double
        x(self) -> double

        Return array of vertex coordinates (const version). 
        """

class vertices(entities):
    """
    A VertexIterator is a MeshEntityIterator of topological dimension 0.

    C++ includes: Vertex.h 
    """

    def __init__(self, *args): 
        """
        VertexIterator(Mesh mesh) -> vertices
        __init__(self, MeshEntity entity) -> vertices
        """

    def _dereference(self):
        """_dereference(self) -> Vertex"""

class Edge(MeshEntity):
    """
    An Edge is a MeshEntity of topological dimension 1.

    C++ includes: Edge.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, Mesh mesh, uint index) -> Edge
        __init__(self, MeshEntity entity) -> Edge

        Create edge from mesh entity. 
        """

    def length(self):
        """
        length(self) -> double

        Compute Euclidean length of edge. 
        """

class edges(entities):
    """
    An EdgeIterator is a MeshEntityIterator of topological dimension 1.

    C++ includes: Edge.h 
    """

    def __init__(self, *args): 
        """
        EdgeIterator(Mesh mesh) -> edges
        __init__(self, MeshEntity entity) -> edges
        """

    def _dereference(self):
        """_dereference(self) -> Edge"""

class Face(MeshEntity):
    """
    A Face is a MeshEntity of topological dimension 2.

    C++ includes: Face.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, Mesh mesh, uint index) -> Face

        Constructor. 
        """

class faces(entities):
    """
    A FaceIterator is a MeshEntityIterator of topological dimension 2.

    C++ includes: Face.h 
    """

    def __init__(self, *args): 
        """
        FaceIterator(Mesh mesh) -> faces
        __init__(self, MeshEntity entity) -> faces
        """

    def _dereference(self):
        """_dereference(self) -> Face"""

class Facet(MeshEntity):
    """
    A Facet is a MeshEntity of topological codimension 1.

    C++ includes: Facet.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, Mesh mesh, uint index) -> Facet

        Constructor. 
        """

    def interior(self):
        """
        interior(self) -> bool

        Determine whether or not facet is an interior facet. This is
        'relative' to the given partition of the mesh if the mesh is
        distributed 
        """

    def adjacent_cells(self, facet_orientation = None):
        """
        adjacent_cells(self, MeshFunctionUInt facet_orientation = None) -> std::pair<(q(const).dolfin::Cell,q(const).dolfin::Cell)>
        adjacent_cells(self) -> std::pair<(q(const).dolfin::Cell,q(const).dolfin::Cell)>

        Return adjacent cells. An optional argument that lists for each facet
        the index of the first cell may be given to specify the ordering of
        the two cells. If not specified, the ordering will depend on the
        (arbitrary) ordering of the mesh connectivity. 
        """

class facets(entities):
    """
    A FacetIterator is a MeshEntityIterator of topological codimension 1.

    C++ includes: Facet.h 
    """

    def __init__(self, *args): 
        """
        FacetIterator(Mesh mesh) -> facets
        __init__(self, MeshEntity entity) -> facets
        """

    def _dereference(self):
        """_dereference(self) -> Facet"""

class Cell(MeshEntity):
    """
    A Cell is a MeshEntity of topological codimension 0.

    C++ includes: Cell.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> Cell
        __init__(self, Mesh mesh, uint index) -> Cell

        Create cell on given mesh with given index. 
        """

    def type(self):
        """
        type(self) -> Type

        Return type of cell. 
        """

    def orientation(self):
        """
        orientation(self) -> double

        Compute orientation of cell (0 is right, 1 is left). 
        """

    def volume(self):
        """
        volume(self) -> double

        Compute (generalized) volume of cell. 
        """

    def diameter(self):
        """
        diameter(self) -> double

        Compute diameter of cell. 
        """

    def normal(self, *args):
        """
        normal(self, uint facet, uint i) -> double
        normal(self, uint facet) -> Point

        Compute normal of given facet with respect to the cell. 
        """

    def facet_area(self, *args):
        """
        facet_area(self, uint facet) -> double

        Compute the area/length of given facet with respect to the cell. 
        """

    def order(self, *args):
        """
        order(self, MeshFunctionUInt global_vertex_indices)

        Order entities locally. 
        """

    def ordered(self, *args):
        """
        ordered(self, MeshFunctionUInt global_vertex_indices) -> bool

        Check if entities are ordered. 
        """

class cells(entities):
    """
    A CellIterator is a MeshEntityIterator of topological codimension 0.

    C++ includes: Cell.h 
    """

    def __init__(self, *args): 
        """
        CellIterator() -> cells
        CellIterator(Mesh mesh) -> cells
        __init__(self, MeshEntity entity) -> cells
        """

    def _dereference(self):
        """_dereference(self) -> Cell"""

class FacetCell(Cell):
    """
    This class represents a cell in a mesh incident to a facet on the
    boundary. It is useful in cases where one needs to iterate over a
    boundary mesh and access the corresponding cells in the original mesh.

    C++ includes: FacetCell.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, Mesh mesh, Cell facet) -> FacetCell

        Create cell on mesh corresponding to given facet (cell) on boundary.

        """

    def facet_index(self):
        """
        facet_index(self) -> uint

        Return local index of facet with respect to the cell. 
        """

class MeshTopology(object):
    """
    MeshTopology stores the topology of a mesh, consisting of mesh
    entities and connectivity (incidence relations for the mesh entities).
    Note that the mesh entities don't need to be stored, only the number
    of entities and the connectivity. Any numbering scheme for the mesh
    entities is stored separately in a MeshFunction over the entities.

    A mesh entity e may be identified globally as a pair e = (dim, i),
    where dim is the topological dimension and i is the index of the
    entity within that topological dimension.

    C++ includes: MeshTopology.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> MeshTopology
        __init__(self, MeshTopology topology) -> MeshTopology

        Copy constructor. 
        """

    def dim(self):
        """
        dim(self) -> uint

        Return topological dimension. 
        """

    def size(self, *args):
        """
        size(self, uint dim) -> uint

        Return number of entities for given dimension. 
        """

    def clear(self):
        """
        clear(self)

        Clear all data. 
        """

    def init(self, *args):
        """
        init(self, uint dim)
        init(self, uint dim, uint size)

        Set number of entities (size) for given topological dimension. 
        """

    def __call__(self, *args):
        """
        __call__(self, uint d0, uint d1) -> MeshConnectivity
        __call__(self, uint d0, uint d1) -> MeshConnectivity
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). 
        """

class MeshGeometry(object):
    """Proxy of C++ dolfin::MeshGeometry class"""

    def __init__(self, *args): 
        """
        __init__(self) -> MeshGeometry
        __init__(self, MeshGeometry geometry) -> MeshGeometry

        Copy constructor. 
        """

    def dim(self):
        """
        dim(self) -> uint

        Return Euclidean dimension of coordinate system. 
        """

    def size(self):
        """
        size(self) -> uint

        Return number of coordinates. 
        """

    def x(self, *args):
        """
        x(self, uint n, uint i) -> double
        x(self, uint n) -> double
        x(self, uint n) -> double
        x(self) -> double
        x(self) -> double

        Return array of values for all coordinates. 
        """

    def higher_order_x(self, *args):
        """
        higher_order_x(self, uint n) -> double
        higher_order_x(self, uint n) -> double
        higher_order_x(self) -> double
        higher_order_x(self) -> double

        Return array of values for all higher order coordinates. 
        """

    def num_higher_order_vertices_per_cell(self):
        """
        num_higher_order_vertices_per_cell(self) -> uint

        Return number of vertices used (per cell) to represent the higher
        order geometry. 
        """

    def higher_order_cell(self, *args):
        """
        higher_order_cell(self, uint c) -> uint
        higher_order_cell(self, uint c) -> uint

        Return array of higher order vertex indices for a specific higher
        order cell. 
        """

    def higher_order_cells(self, *args):
        """
        higher_order_cells(self) -> uint
        higher_order_cells(self) -> uint

        Return array of values for all higher order cell data. 
        """

    def point(self, *args):
        """
        point(self, uint n) -> Point

        Return coordinate n as a 3D point value. 
        """

    def affine_cell_bool(self):
        """
        affine_cell_bool(self) -> bool

        Return pointer to boolean affine indicator array. 
        """

    def clear(self):
        """
        clear(self)

        Clear all data. 
        """

    def init(self, *args):
        """
        init(self, uint dim, uint size)

        Initialize coordinate list to given dimension and size. 
        """

    def init_higher_order_vertices(self, *args):
        """
        init_higher_order_vertices(self, uint dim, uint size_higher_order)

        Initialize higher order coordinate list to given dimension and size.

        """

    def init_higher_order_cells(self, *args):
        """
        init_higher_order_cells(self, uint num_cells, uint num_dof)

        Initialize higher order cell data list to given number of cells and
        dofs. 
        """

    def init_affine_indicator(self, *args):
        """
        init_affine_indicator(self, uint num_cells)

        Initialize the affine indicator array. 
        """

    def set_affine_indicator(self, *args):
        """
        set_affine_indicator(self, uint i, bool value)

        set affine indicator at index i 
        """

    def set(self, *args):
        """
        set(self, uint n, uint i, double x)

        Set value of coordinate n in direction i. 
        """

    def set_higher_order_coordinates(self, *args):
        """
        set_higher_order_coordinates(self, uint N, uint i, double x)

        Set value of higher order coordinate N in direction i. 
        """

    def set_higher_order_cell_data(self, *args):
        """
        set_higher_order_cell_data(self, uint N, std::vector<(dolfin::uint)> vector_cell_data)

        Set higher order cell data for cell # N in direction i. 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). 
        """

class IntersectionOperator(object):
    """Proxy of C++ dolfin::IntersectionOperator class"""

    def __init__(self, *args): 
        """
        __init__(self, Mesh _mesh, string kernel_type = "SimpleCartesian") -> IntersectionOperator
        __init__(self, Mesh _mesh) -> IntersectionOperator
        __init__(self, __dummy_37__ _mesh, string kernel_type = "SimpleCartesian") -> IntersectionOperator
        __init__(self, __dummy_37__ _mesh) -> IntersectionOperator
        """

    def all_intersected_entities(self, *args):
        """
        all_intersected_entities(self, Point point)
        all_intersected_entities(self, std::vector<(dolfin::Point)> points)
        all_intersected_entities(self, MeshEntity entity, std::vector<(dolfin::uint)> ids_result)
        all_intersected_entities(self, std::vector<(dolfin::MeshEntity)> entities)
        all_intersected_entities(self, Mesh another_mesh)

        Compute all id of all cells which are intersects by the given mesh
        another_mesh;

        Parameters:
        -----------

        ids_result:  The ids of the intersected entities are saved in a set
        for efficienty reasons, to avoid to sort out duplicates later on. 
        """

    def any_intersected_entity(self, *args):
        """
        any_intersected_entity(self, Point point) -> int

        Computes only the first id of the entity, which contains the point.
        Returns -1 if no cell is intersected. 
        """

    def closest_point(self, *args):
        """
        closest_point(self, Point point) -> Point

        Computes the point inside the mesh which are closest to the point
        query. 
        """

    def closest_cell(self, *args):
        """
        closest_cell(self, Point point) -> uint

        Computes the index of the cell inside the mesh which are closest to
        the point query. 
        """

    def closest_point_and_cell(self, *args):
        """
        closest_point_and_cell(self, Point point) -> std::pair<(dolfin::Point,dolfin::uint)>

        Computes the point inside the mesh and the corresponding cell index
        which are closest to the point query. 
        """

    def reset_kernel(self, kernel_type = "SimpleCartesian"):
        """
        reset_kernel(self, string kernel_type = "SimpleCartesian")
        reset_kernel(self)

        Rebuilds the underlying search structure from scratch and uses the
        kernel kernel_type underlying CGAL Geometry kernel. 
        """

    def clear(self):
        """
        clear(self)

        Clears search structure. Should be used if the mesh has changed. 
        """

    def mesh(self):
        """mesh(self) -> Mesh"""

class PrimitiveIntersector(object):
    """
    This class implements an intersection detection, detecting whether two
    given (arbitrary) meshentities intersect.

    C++ includes: PrimitiveIntersector.h 
    """

    def do_intersect(*args):
        """
        do_intersect(MeshEntity entity_1, MeshEntity entity_2) -> bool
        do_intersect(MeshEntity entity_1, Point point) -> bool
        """

    def do_intersect_exact(*args):
        """
        do_intersect_exact(MeshEntity entity_1, MeshEntity entity_2) -> bool
        do_intersect_exact(MeshEntity entity_1, Point point) -> bool
        """

    def __init__(self): 
        """__init__(self) -> PrimitiveIntersector"""

def PrimitiveIntersector_do_intersect(*args):
  """
    do_intersect(MeshEntity entity_1, MeshEntity entity_2) -> bool
    PrimitiveIntersector_do_intersect(MeshEntity entity_1, Point point) -> bool
    """

def PrimitiveIntersector_do_intersect_exact(*args):
  """
    do_intersect_exact(MeshEntity entity_1, MeshEntity entity_2) -> bool
    PrimitiveIntersector_do_intersect_exact(MeshEntity entity_1, Point point) -> bool
    """

class MeshData(Variable):
    """
    The class MeshData is a container for auxiliary mesh data, represented
    either as MeshFunctions over topological mesh entities, arrays or
    maps. Each dataset is identified by a unique user-specified string.
    Only uint- valued data are currently supported.

    The following named mesh data are recognized by DOLFIN:

    Boundary indicators

    "boundary facet cells" - Array<uint> of size num_facets "boundary
    facet numbers" - Array<uint> of size num_facets "boundary
    indicators" - Array<uint> of size num_facets "material indicators"
    - MeshFunction<uint> of dimension D

    Boundary indicators (alternative)

    "exterior facet domains" - MeshFunction<uint> of dimension D - 1

    Facet orientation (used for assembly over interior facets)

    "facet orientation" - MeshFunction<uint> of dimension D - 1

    Boundary extraction

    "vertex map" - MeshFunction<uint> of dimension 0 "cell map" -
    MeshFunction<uint> of dimension D

    Mesh partitioning

    "global entity indices %d" - MeshFunction<uint> of dimension 0, 1,
    ..., D "exterior facets" - MeshFunction<uint> of dimension D - 1
    "num global entities" - Array<uint> of size D + 1 "overlap" -
    vector mapping

    Sub meshes

    "global vertex indices" - MeshFunction<uint> of dimension 0

    C++ includes: MeshData.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, Mesh mesh) -> MeshData

        Constructor. 
        """

    def clear(self):
        """
        clear(self)

        Clear all data. 
        """

    def create_mesh_function(self, *args):
        """
        create_mesh_function(self, string name) -> MeshFunctionUInt
        create_mesh_function(self, string name, uint dim) -> MeshFunctionUInt

        Create MeshFunction with given name and dimension. 
        """

    def create_array(self, *args):
        """
        create_array(self, string name, uint size) -> std::vector<(dolfin::uint)>

        Create array (vector) with given name and size. 
        """

    def create_mapping(self, *args):
        """
        create_mapping(self, string name) -> std::map<(dolfin::uint,dolfin::uint)>

        Create mapping from uint to uint with given name. 
        """

    def create_vector_mapping(self, *args):
        """
        create_vector_mapping(self, string name) -> std::map<(dolfin::uint,std::vector<(dolfin::uint)>)>

        Create mapping from uint to vector of uint with given name. 
        """

    def mesh_function(self, *args):
        """
        mesh_function(self, string name) -> MeshFunctionUInt

        Return MeshFunction with given name (returning zero if data is not
        available). 
        """

    def array(self, *args):
        """
        array(self, string name) -> std::vector<(dolfin::uint)>

        Return array with given name (returning zero if data is not
        available). 
        """

    def mapping(self, *args):
        """
        mapping(self, string name) -> std::map<(dolfin::uint,dolfin::uint)>

        Return mapping with given name (returning zero if data is not
        available). 
        """

    def vector_mapping(self, *args):
        """
        vector_mapping(self, string name) -> std::map<(dolfin::uint,std::vector<(dolfin::uint)>)>

        Return vector mapping with given name (returning zero if data is not
        available). 
        """

    def erase_mesh_function(self, *args):
        """
        erase_mesh_function(self, string name)

        Erase MeshFunction with given name. 
        """

    def erase_array(self, *args):
        """
        erase_array(self, string name)

        Erase array with given name. 
        """

    def erase_mapping(self, *args):
        """
        erase_mapping(self, string name)

        Erase mapping with given name. 
        """

    def erase_vector_mapping(self, *args):
        """
        erase_vector_mapping(self, string name)

        Erase vector mapping with given name. 
        """

class MeshConnectivity(object):
    """
    Mesh connectivity stores a sparse data structure of connections
    (incidence relations) between mesh entities for a fixed pair of
    topological dimensions.

    The connectivity can be specified either by first giving the number of
    entities and the number of connections for each entity, which may
    either be equal for all entities or different, or by giving the entire
    (sparse) connectivity pattern.

    C++ includes: MeshConnectivity.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, uint d0, uint d1) -> MeshConnectivity
        __init__(self, MeshConnectivity connectivity) -> MeshConnectivity

        Copy constructor. 
        """

    def size(self, *args):
        """
        size(self) -> uint
        size(self, uint entity) -> uint

        Return number of connections for given entity. 
        """

    def clear(self):
        """
        clear(self)

        Clear all data. 
        """

    def init(self, *args):
        """
        init(self, uint num_entities, uint num_connections)
        init(self, std::vector<(dolfin::uint)> num_connections)

        Initialize number of entities and number of connections
        (individually). 
        """

    def set(self, *args):
        """
        set(self, uint entity, uint connection, uint pos)
        set(self, uint entity, std::vector<(dolfin::uint)> connections)
        set(self, uint entity, uint connections)
        set(self, std::vector<(std::vector<(dolfin::uint)>)> connectivity)

        Set all connections for all entities. 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). 
        """

    def __call__(self, *args):
        """
        __call__(self) -> PyObject
        __call__(self, uint entity) -> PyObject
        """

class MeshEditor(object):
    """
    A simple mesh editor for creating simplicial meshes in 1D, 2D and 3D.

    C++ includes: MeshEditor.h 
    """

    def __init__(self): 
        """
        __init__(self) -> MeshEditor

        Constructor. 
        """

    def open(self, *args):
        """
        open(self, Mesh mesh, uint tdim, uint gdim)
        open(self, Mesh mesh, string type, uint tdim, uint gdim)

        Open mesh of given cell type, topological and geometrical dimension.

        """

    def init_vertices(self, *args):
        """
        init_vertices(self, uint num_vertices)

        Specify number of vertices. 
        """

    def init_higher_order_vertices(self, *args):
        """
        init_higher_order_vertices(self, uint num_higher_order_vertices)

        Specify number of vertices. 
        """

    def init_cells(self, *args):
        """
        init_cells(self, uint num_cells)

        Specify number of cells. 
        """

    def init_higher_order_cells(self, *args):
        """
        init_higher_order_cells(self, uint num_higher_order_cells, uint num_higher_order_cell_dof)

        Specify number of cells. 
        """

    def set_affine_cell_indicator(self, *args):
        """
        set_affine_cell_indicator(self, uint c, string affine_str)

        Set boolean indicator inside MeshGeometry. 
        """

    def add_vertex(self, *args):
        """
        add_vertex(self, uint v, Point p)
        add_vertex(self, uint v, double x)
        add_vertex(self, uint v, double x, double y)
        add_vertex(self, uint v, double x, double y, double z)

        Add vertex v at given coordinate (x, y, z). 
        """

    def add_higher_order_vertex(self, *args):
        """
        add_higher_order_vertex(self, uint v, Point p)
        add_higher_order_vertex(self, uint v, double x)
        add_higher_order_vertex(self, uint v, double x, double y)
        add_higher_order_vertex(self, uint v, double x, double y, double z)

        Add vertex v at given coordinate (x, y, z). 
        """

    def add_cell(self, *args):
        """
        add_cell(self, uint c, std::vector<(dolfin::uint)> v)
        add_cell(self, uint c, uint v0, uint v1)
        add_cell(self, uint c, uint v0, uint v1, uint v2)
        add_cell(self, uint c, uint v0, uint v1, uint v2, uint v3)

        Add cell (tetrahedron) with given vertices. 
        """

    def add_higher_order_cell_data(self, *args):
        """
        add_higher_order_cell_data(self, uint c, uint v0, uint v1, uint v2, uint v3, uint v4, 
            uint v5)

        Add higher order cell data (assume P2 triangle for now). 
        """

    def close(self, order = True):
        """
        close(self, bool order = True)
        close(self)

        Close mesh, finish editing, and order entities locally. 
        """

class DynamicMeshEditor(object):
    """
    This class provides an interface for dynamic editing of meshes, that
    is, when the number of vertices and cells are not known a priori. If
    the number of vertices and cells are known a priori, it is more
    efficient to use the default editor MeshEditor.

    C++ includes: DynamicMeshEditor.h 
    """

    def __init__(self): 
        """
        __init__(self) -> DynamicMeshEditor

        Constructor. 
        """

    def open(self, *args):
        """
        open(self, Mesh mesh, Type type, uint tdim, uint gdim)
        open(self, Mesh mesh, string type, uint tdim, uint gdim)

        Open mesh of given cell type, topological and geometrical dimension.

        """

    def add_vertex(self, *args):
        """
        add_vertex(self, uint v, Point p)
        add_vertex(self, uint v, double x)
        add_vertex(self, uint v, double x, double y)
        add_vertex(self, uint v, double x, double y, double z)

        Add vertex v at given coordinate (x, y, z). 
        """

    def add_cell(self, *args):
        """
        add_cell(self, uint c, std::vector<(dolfin::uint)> v)
        add_cell(self, uint c, uint v0, uint v1)
        add_cell(self, uint c, uint v0, uint v1, uint v2)
        add_cell(self, uint c, uint v0, uint v1, uint v2, uint v3)

        Add cell (tetrahedron) with given vertices. 
        """

    def close(self, order = False):
        """
        close(self, bool order = False)
        close(self)

        Close mesh, finish editing, and order entities locally. 
        """

class MeshPartitioning(object):
    """
    This class partitions and distributes a mesh based on partitioned
    local mesh data. Note that the local mesh data will also be
    repartitioned and redistributed during the computation of the mesh
    partitioning.

    After partitioning, each process has a local mesh and set of mesh data
    that couples the meshes together.

    The following mesh data is created:

    1. "global entity indices 0" ( MeshFunction<uint>)

    This maps each local vertex to its global index.

    2. "overlap" (std::map<uint, std::vector<uint> >)

    This maps each shared vertex to a list of the processes sharing the
    vertex.

    3. "global entity indices %d" ( MeshFunction<uint>)

    After partitioning, the function number_entities() may be called to
    create global indices for all entities of a given topological
    dimension. These are stored as mesh data ( MeshFunction<uint>) named

    "global entity indices 1" "global entity indices 2" etc

    4. "num global entities" (std::vector<uint>)

    The function number_entities also records the number of global
    entities for the dimension of the numbered entities in the array named
    "num global entities". This array has size D + 1, where D is the
    topological dimension of the mesh. This array is initially created by
    the mesh and then contains only the number entities of dimension 0
    (vertices) and dimension D (cells).

    C++ includes: MeshPartitioning.h 
    """

    def partition(*args):
        """
        partition(Mesh mesh)
        partition(Mesh mesh, LocalMeshData data)
        """

    def number_entities(*args):
        """number_entities(Mesh mesh, uint d)"""

    def __init__(self): 
        """__init__(self) -> MeshPartitioning"""

def MeshPartitioning_partition(*args):
  """
    partition(Mesh mesh)
    MeshPartitioning_partition(Mesh mesh, LocalMeshData data)
    """

def MeshPartitioning_number_entities(*args):
  """MeshPartitioning_number_entities(Mesh mesh, uint d)"""

class PointPrimitive(object):
    """Proxy of C++ dolfin::PointPrimitive class"""

    def __init__(self): 
        """__init__(self) -> PointPrimitive"""

class LocalMeshData(Variable):
    """
    This class stores mesh data on a local processor corresponding to a
    portion of a (larger) global mesh.

    Note that the data stored in this class does typically not correspond
    to a topologically connected mesh; it merely stores a list of vertex
    coordinates, a list of cell-vertex mappings and a list of global
    vertex numbers for the locally stored vertices.

    It is typically used for parsing meshes in parallel from mesh XML
    files. After local mesh data has been parsed on each processor, a
    subsequent repartitioning takes place: first a geometric partitioning
    of the vertices followed by a redistribution of vertex and cell data,
    and then a topological partitioning again followed by redistribution
    of vertex and cell data, at that point corresponding to topologically
    connected meshes instead of local mesh data.

    C++ includes: LocalMeshData.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> LocalMeshData
        __init__(self, Mesh mesh) -> LocalMeshData

        Create local mesh data for given mesh. 
        """

class SubDomain(object):
    """
    This class defines the interface for definition of sub domains.
    Alternatively, sub domains may be defined by a Mesh and a
    MeshFunction<uint> over the mesh.

    C++ includes: SubDomain.h 
    """

    def __init__(self): 
        """
        __init__(self) -> SubDomain

        Constructor. 
        """

    def inside(self, *args):
        """
        inside(self, DoubleArray x, bool on_boundary) -> bool

        Return true for points inside the subdomain. 
        """

    def map(self, *args):
        """
        map(self, DoubleArray x, DoubleArray arg0)

        Map coordinate x in domain H to coordinate y in domain G (used for
        periodic boundary conditions) 
        """

    def snap(self, *args):
        """
        snap(self, DoubleArray x)

        Snap coordinate to boundary of sub domain. 
        """

    def mark(self, *args):
        """
        mark(self, MeshFunctionUInt sub_domains, uint sub_domain)

        Set sub domain markers for given subdomain. 
        """

    def geometric_dimension(self):
        """
        geometric_dimension(self) -> uint

        Return geometric dimension. 
        """

    def __disown__(self):
        """Missing docstring"""

class SubMesh(Mesh):
    """
    A SubMesh is a mesh defined as a subset of a given mesh. It provides a
    convenient way to create matching meshes for multiphysics applications
    by creating meshes for subdomains as subsets of a single global mesh.

    C++ includes: SubMesh.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, Mesh mesh, SubDomain sub_domain) -> SubMesh
        __init__(self, Mesh mesh, MeshFunctionUInt sub_domains, uint sub_domain) -> SubMesh

        Create subset of given mesh marked by mesh function. 
        """

def SubMesh_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class DomainBoundary(SubDomain):
    """
    This class provides a SubDomain which picks out the boundary of a
    mesh, and provides a convenient way to specify boundary conditions on
    the entire boundary of a mesh.

    C++ includes: DomainBoundary.h 
    """

    def __init__(self): 
        """
        __init__(self) -> DomainBoundary

        Constructor. 
        """

def DomainBoundary_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class BoundaryMesh(Mesh):
    """
    A BoundaryMesh is a mesh over the boundary of some given mesh.

    C++ includes: BoundaryMesh.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> BoundaryMesh
        __init__(self, Mesh mesh) -> BoundaryMesh

        Create (interior) boundary mesh from given mesh. 
        """

    def init_exterior_boundary(self, *args):
        """
        init_exterior_boundary(self, Mesh mesh)

        Initialize exterior boundary of given mesh. 
        """

    def init_interior_boundary(self, *args):
        """
        init_interior_boundary(self, Mesh mesh)

        Initialize interior boundary of given mesh. 
        """

def BoundaryMesh_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class UnitCube(Mesh):
    """
    Tetrahedral mesh of the 3D unit cube (0,1) x (0,1) x (0,1). Given the
    number of cells (nx, ny, nz) in each direction, the total number of
    tetrahedra will be 6*nx*ny*nz and the total number of vertices will be
    (nx + 1)*(ny + 1)*(nz + 1).

    C++ includes: UnitCube.h 
    """

    def __init__(self, *args): 
        """__init__(self, uint nx, uint ny, uint nz) -> UnitCube"""

def UnitCube_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class UnitInterval(Mesh):
    """
    Interval mesh of the 1D unit line (0,1). Given the number of cells
    (nx) in the axial direction, the total number of intervals will be nx
    and the total number of vertices will be (nx + 1).

    C++ includes: UnitInterval.h 
    """

    def __init__(self, *args): 
        """__init__(self, uint nx) -> UnitInterval"""

def UnitInterval_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class Interval(Mesh):
    """
    Interval mesh of the 1D line (a,b). Given the number of cells (nx) in
    the axial direction, the total number of intervals will be nx and the
    total number of vertices will be (nx + 1).

    C++ includes: Interval.h 
    """

    def __init__(self, *args): 
        """__init__(self, uint nx, double a, double b) -> Interval"""

def Interval_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class UnitSquare(Mesh):
    """
    Triangular mesh of the 2D unit square (0,1) x (0,1). Given the number
    of cells (nx, ny) in each direction, the total number of triangles
    will be 2*nx*ny and the total number of vertices will be (nx + 1)*(ny
    + 1). std::string diagonal ("left", "right", "right/left" or
    "crossed") indicates the direction of the diagonals.

    C++ includes: UnitSquare.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, uint nx, uint ny, string diagonal = "right") -> UnitSquare
        __init__(self, uint nx, uint ny) -> UnitSquare
        """

def UnitSquare_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class UnitCircle(Mesh):
    """
    std:string transformation ("maxn", "sumn" or "rotsumn")

    Triangular mesh of the 2D unit circle. Given the number of cells (nx,
    ny) in each direction, the total number of triangles will be 2*nx*ny
    and the total number of vertices will be (nx + 1)*(ny + 1).
    std::string diagonal ("left", "right" or "crossed") indicates
    the direction of the diagonals.

    C++ includes: UnitCircle.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, uint nx, string diagonal = "crossed", string transformation = "rotsumn") -> UnitCircle
        __init__(self, uint nx, string diagonal = "crossed") -> UnitCircle
        __init__(self, uint nx) -> UnitCircle
        """

def UnitCircle_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class Box(Mesh):
    """
    Tetrahedral mesh of the 3D rectangular prism (x0, y0) x (x1, y1) x
    (x2, y2). Given the number of cells (nx, ny, nz) in each direction,
    the total number of tetrahedra will be 6*nx*ny*nz and the total number
    of vertices will be (nx + 1)*(ny + 1)*(nz + 1).

    C++ includes: Box.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, double x0, double y0, double z0, double x1, double y1, 
            double z1, uint nx, uint ny, uint nz) -> Box
        """

def Box_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class Rectangle(Mesh):
    """
    Triangular mesh of the 2D rectangle (x0, y0) x (x1, y1). Given the
    number of cells (nx, ny) in each direction, the total number of
    triangles will be 2*nx*ny and the total number of vertices will be (nx
    + 1)*(ny + 1).

    std::string diagonal ("left", "right", "right/left" or
    "crossed") indicates the direction of the diagonals.

    C++ includes: Rectangle.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, double x0, double y0, double x1, double y1, uint nx, 
            uint ny, string diagonal = "right") -> Rectangle
        __init__(self, double x0, double y0, double x1, double y1, uint nx, 
            uint ny) -> Rectangle
        """

def Rectangle_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class UnitSphere(Mesh):
    """
    Triangular mesh of the 3D unit sphere.

    Given the number of cells (nx, ny, nz) in each direction, the total
    number of tetrahedra will be 6*nx*ny*nz and the total number of
    vertices will be (nx + 1)*(ny + 1)*(nz + 1).

    C++ includes: UnitSphere.h 
    """

    def __init__(self, *args): 
        """__init__(self, uint nx) -> UnitSphere"""

def UnitSphere_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class MeshFunctionInt(Variable):
    """
    A MeshFunction is a function that can be evaluated at a set of mesh
    entities. A MeshFunction is discrete and is only defined at the set of
    mesh entities of a fixed topological dimension. A MeshFunction may for
    example be used to store a global numbering scheme for the entities of
    a (parallel) mesh, marking sub domains or boolean markers for mesh
    refinement.

    C++ includes: MeshFunction.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> MeshFunctionInt
        __init__(self, Mesh mesh) -> MeshFunctionInt
        __init__(self, Mesh mesh, uint dim) -> MeshFunctionInt
        __init__(self, Mesh mesh, uint dim, int value) -> MeshFunctionInt
        __init__(self, Mesh mesh, string filename) -> MeshFunctionInt
        __init__(self, MeshFunctionInt f) -> MeshFunctionInt

        Copy constructor. 
        """

    def mesh(self):
        """
        mesh(self) -> Mesh

        Return mesh associated with mesh function. 
        """

    def dim(self):
        """
        dim(self) -> uint

        Return topological dimension. 
        """

    def size(self):
        """
        size(self) -> uint

        Return size (number of entities). 
        """

    def init(self, *args):
        """
        init(self, uint dim)
        init(self, uint dim, uint size)
        init(self, Mesh mesh, uint dim)
        init(self, Mesh mesh, uint dim, uint size)

        Initialize mesh function for given topological dimension of given
        size. 
        """

    def set_all(self, *args):
        """
        set_all(self, int value)

        Set all values to given value. 
        """

    def values(self):
        """
        values(self) -> PyObject

        Return array of values. 
        """

    def __getitem__(self, *args):
        """
        __getitem__(self, unsigned int i) -> int
        __getitem__(self, MeshEntity e) -> int
        """

    def __setitem__(self, *args):
        """
        __setitem__(self, unsigned int i, int val)
        __setitem__(self, MeshEntity e, int val)
        """

def _refine(*args):
  """
    _refine(Mesh mesh) -> Mesh
    _refine(Mesh refined_mesh, Mesh mesh)
    _refine(Mesh mesh, MeshFunctionBool cell_markers) -> Mesh
    _refine(Mesh refined_mesh, Mesh mesh, MeshFunctionBool cell_markers)

    Create locally refined mesh. 
    """

class MeshFunctionUInt(Variable):
    """
    A MeshFunction is a function that can be evaluated at a set of mesh
    entities. A MeshFunction is discrete and is only defined at the set of
    mesh entities of a fixed topological dimension. A MeshFunction may for
    example be used to store a global numbering scheme for the entities of
    a (parallel) mesh, marking sub domains or boolean markers for mesh
    refinement.

    C++ includes: MeshFunction.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> MeshFunctionUInt
        __init__(self, Mesh mesh) -> MeshFunctionUInt
        __init__(self, Mesh mesh, uint dim) -> MeshFunctionUInt
        __init__(self, Mesh mesh, uint dim, unsigned int value) -> MeshFunctionUInt
        __init__(self, Mesh mesh, string filename) -> MeshFunctionUInt
        __init__(self, MeshFunctionUInt f) -> MeshFunctionUInt

        Copy constructor. 
        """

    def mesh(self):
        """
        mesh(self) -> Mesh

        Return mesh associated with mesh function. 
        """

    def dim(self):
        """
        dim(self) -> uint

        Return topological dimension. 
        """

    def size(self):
        """
        size(self) -> uint

        Return size (number of entities). 
        """

    def init(self, *args):
        """
        init(self, uint dim)
        init(self, uint dim, uint size)
        init(self, Mesh mesh, uint dim)
        init(self, Mesh mesh, uint dim, uint size)

        Initialize mesh function for given topological dimension of given
        size. 
        """

    def set_all(self, *args):
        """
        set_all(self, unsigned int value)

        Set all values to given value. 
        """

    def values(self):
        """
        values(self) -> PyObject

        Return array of values. 
        """

    def __getitem__(self, *args):
        """
        __getitem__(self, unsigned int i) -> uint
        __getitem__(self, MeshEntity e) -> uint
        """

    def __setitem__(self, *args):
        """
        __setitem__(self, unsigned int i, uint val)
        __setitem__(self, MeshEntity e, uint val)
        """

class MeshFunctionDouble(Variable):
    """
    A MeshFunction is a function that can be evaluated at a set of mesh
    entities. A MeshFunction is discrete and is only defined at the set of
    mesh entities of a fixed topological dimension. A MeshFunction may for
    example be used to store a global numbering scheme for the entities of
    a (parallel) mesh, marking sub domains or boolean markers for mesh
    refinement.

    C++ includes: MeshFunction.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> MeshFunctionDouble
        __init__(self, Mesh mesh) -> MeshFunctionDouble
        __init__(self, Mesh mesh, uint dim) -> MeshFunctionDouble
        __init__(self, Mesh mesh, uint dim, double value) -> MeshFunctionDouble
        __init__(self, Mesh mesh, string filename) -> MeshFunctionDouble
        __init__(self, MeshFunctionDouble f) -> MeshFunctionDouble

        Copy constructor. 
        """

    def mesh(self):
        """
        mesh(self) -> Mesh

        Return mesh associated with mesh function. 
        """

    def dim(self):
        """
        dim(self) -> uint

        Return topological dimension. 
        """

    def size(self):
        """
        size(self) -> uint

        Return size (number of entities). 
        """

    def init(self, *args):
        """
        init(self, uint dim)
        init(self, uint dim, uint size)
        init(self, Mesh mesh, uint dim)
        init(self, Mesh mesh, uint dim, uint size)

        Initialize mesh function for given topological dimension of given
        size. 
        """

    def set_all(self, *args):
        """
        set_all(self, double value)

        Set all values to given value. 
        """

    def values(self):
        """
        values(self) -> PyObject

        Return array of values. 
        """

    def __getitem__(self, *args):
        """
        __getitem__(self, unsigned int i) -> double
        __getitem__(self, MeshEntity e) -> double
        """

    def __setitem__(self, *args):
        """
        __setitem__(self, unsigned int i, double val)
        __setitem__(self, MeshEntity e, double val)
        """

class MeshFunctionBool(Variable):
    """
    A MeshFunction is a function that can be evaluated at a set of mesh
    entities. A MeshFunction is discrete and is only defined at the set of
    mesh entities of a fixed topological dimension. A MeshFunction may for
    example be used to store a global numbering scheme for the entities of
    a (parallel) mesh, marking sub domains or boolean markers for mesh
    refinement.

    C++ includes: MeshFunction.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> MeshFunctionBool
        __init__(self, Mesh mesh) -> MeshFunctionBool
        __init__(self, Mesh mesh, uint dim) -> MeshFunctionBool
        __init__(self, Mesh mesh, uint dim, bool value) -> MeshFunctionBool
        __init__(self, Mesh mesh, string filename) -> MeshFunctionBool
        __init__(self, MeshFunctionBool f) -> MeshFunctionBool

        Copy constructor. 
        """

    def mesh(self):
        """
        mesh(self) -> Mesh

        Return mesh associated with mesh function. 
        """

    def dim(self):
        """
        dim(self) -> uint

        Return topological dimension. 
        """

    def size(self):
        """
        size(self) -> uint

        Return size (number of entities). 
        """

    def init(self, *args):
        """
        init(self, uint dim)
        init(self, uint dim, uint size)
        init(self, Mesh mesh, uint dim)
        init(self, Mesh mesh, uint dim, uint size)

        Initialize mesh function for given topological dimension of given
        size. 
        """

    def set_all(self, *args):
        """
        set_all(self, bool value)

        Set all values to given value. 
        """

    def values(self):
        """
        values(self) -> PyObject

        Return array of values. 
        """

    def __getitem__(self, *args):
        """
        __getitem__(self, unsigned int i) -> bool
        __getitem__(self, MeshEntity e) -> bool
        """

    def __setitem__(self, *args):
        """
        __setitem__(self, unsigned int i, bool val)
        __setitem__(self, MeshEntity e, bool val)
        """

class MeshFunction(object):
    """Missing docstring"""

    def __new__(cls, tp, *args):
        """Missing docstring"""

class Data(object):
    """
    This class holds data for function evaluation, including the
    coordinates x, the time t, and auxiliary data that a function may
    depend on.

    C++ includes: Data.h 
    """

    def __init__(self): 
        """
        __init__(self) -> Data

        Constructor. 
        """

    def cell(self):
        """
        cell(self) -> Cell

        Return current cell (if available). 
        """

    def ufc_cell(self):
        """
        ufc_cell(self) -> cell

        Return current UFC cell (if available). 
        """

    def facet(self):
        """
        facet(self) -> uint

        Return current facet (if available). 
        """

    def normal(self):
        """
        normal(self) -> Point

        Return current facet normal (if available). 
        """

    def geometric_dimension(self):
        """
        geometric_dimension(self) -> uint

        Return geometric dimension of cell. 
        """

    def on_facet(self):
        """
        on_facet(self) -> bool

        Check if we are on a facet. 
        """

    def set(self, *args):
        """
        set(self, Cell dolfin_cell, cell ufc_cell, int local_facet)
        set(self, cell ufc_cell, double x)
        set(self, uint gdim, double x)
        """

    def clear(self):
        """
        clear(self)

        Clear all cell data. 
        """

    def x(self):
        """x(self) -> PyObject"""

class GenericFunction(ufc.function,Variable):
    """
    This is a common base class for functions. Functions can be evaluated
    at a given point and they can be restricted to a given cell in a
    finite element mesh. This functionality is implemented by sub-classes
    that implement the eval() and restrict() functions.

    DOLFIN provides two implementations of the GenericFunction interface
    in the form of the classes Function and Expression.

    Sub-classes may optionally implement the gather() function that will
    be called prior to restriction when running in parallel.

    C++ includes: GenericFunction.h 
    """

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def value_rank(self):
        """
        value_rank(self) -> uint

        Return value rank. 
        """

    def value_dimension(self, *args):
        """
        value_dimension(self, uint i) -> uint

        Return value dimension for given axis. 
        """

    def eval_data(self, *args):
        """
        eval_data(self, DoubleArray values, Data data)

        Evaluate function for given data. 
        """

    def compute_vertex_values(self, *args):
        """
        compute_vertex_values(self, DoubleArray vertex_values, Mesh mesh)

        Compute values at all mesh vertices. 
        """

    def gather(self):
        """
        gather(self)

        Collect off-process coefficients to prepare for interpolation. 
        """

    def value_size(self):
        """
        value_size(self) -> uint

        Return value size (product of value dimensions). 
        """

    def restrict(self, *args):
        """
        restrict(self, double w, FiniteElement element, Cell dolfin_cell, 
            cell ufc_cell, int local_facet)
        restrict(self, double w, FiniteElement element, Cell dolfin_cell, 
            cell ufc_cell)

        Convenience function for restriction when facet is unknown. 
        """

    def str(self,verbose):
        """Return a string representation of it self"""

class Expression(GenericFunction):
    """
    This class represents a user-defined expression. Expressions can be
    used as coefficients in variational forms or interpolated into finite
    element spaces.

    An expression is defined by overloading the eval() method. Users may
    choose to overload either a simple version of eval(), in the case of
    expressions only depending on the coordinate x, or an optional version
    for expressions depending on x and mesh data like cell indices or
    facet normals.

    The geometric dimension (the size of x) and the value rank and
    dimensions of an expression must supplied as arguments to the
    constructor.

    C++ includes: Expression.h 
    """

    def __init__(self, *args): 
        """
        __init__(self) -> Expression
        __init__(self, uint dim) -> Expression
        __init__(self, uint dim0, uint dim1) -> Expression
        __init__(self, std::vector<(dolfin::uint)> value_shape) -> Expression
        __init__(self, Expression expression) -> Expression

        Copy constructor. 
        """

    def eval_data(self, *args):
        """
        eval_data(self, DoubleArray values, Data data)

        Evaluate expression, must be overloaded by user (simple version). 
        """

    def eval(self, *args):
        """
        eval(self, DoubleArray values, DoubleArray x)

        Evaluate expression, must be overloaded by user (simple version). 
        """
    def __disown__(self):
        """Missing docstring"""

def Expression_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class Function(GenericFunction):
    """
    This class represents a function u_h in a finite element function
    space V_h, given by

    u_h = sum_i U_i phi_i

    where {phi_i}_i is a basis for V_h, and U is a vector of expansion
    coefficients for u_h.

    C++ includes: Function.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, __dummy_19__ V) -> Function
        __init__(self, __dummy_19__ V, boost::shared_ptr<(dolfin::GenericVector)> x) -> Function
        __init__(self, __dummy_19__ V, GenericVector x) -> Function
        __init__(self, __dummy_19__ V, string filename) -> Function
        __init__(self, Function v) -> Function
        __init__(self, Function v, uint i) -> Function

        Sub-function constructor with shallow copy of vector (used in Python
        interface) 
        """

    def assign(self, *args):
        """
        assign(self, Function v) -> Function
        assign(self, Expression v) -> Function
        """

    def _sub(self, *args):
        """_sub(self, uint i) -> Function"""

    def _function_space(self):
        """
        _function_space(self) -> __dummy_19__

        Return shared pointer to function space. 
        """

    def vector(self, *args):
        """
        vector(self) -> GenericVector
        vector(self) -> GenericVector

        Return vector of expansion coefficients (const version). 
        """

    def _in(self, *args):
        """
        _in(self, FunctionSpace V) -> bool

        Check if function is a member of the given function space. 
        """

    def geometric_dimension(self):
        """
        geometric_dimension(self) -> uint

        Return geometric dimension. 
        """

    def eval(self, *args):
        """
        eval(self, DoubleArray values, DoubleArray x)
        eval(self, DoubleArray values, DoubleArray x, Cell dolfin_cell, 
            cell ufc_cell)

        Evaluate function for given data. 
        """

    def interpolate(self, *args):
        """
        interpolate(self, GenericFunction v)

        Interpolate function (possibly non-matching meshes). 
        """

    def extrapolate(self, *args):
        """
        extrapolate(self, Function v)

        Extrapolate function (from a possibly lower-degree function space). 
        """

    def function_space(self):
        """Return the FunctionSpace"""

def Function_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class FunctionSpace(Variable):
    """
    This class represents a finite element function space defined by a
    mesh, a finite element, and a local-to-global mapping of the degrees
    of freedom (dofmap).

    C++ includes: FunctionSpace.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, __dummy_36__ mesh, __dummy_17__ element, __dummy_13__ dofmap) -> FunctionSpace
        __init__(self, __dummy_37__ mesh, __dummy_17__ element, __dummy_13__ dofmap) -> FunctionSpace
        __init__(self, FunctionSpace V) -> FunctionSpace

        Copy constructor. 
        """

    def assign(self, *args):
        """assign(self, FunctionSpace V) -> FunctionSpace"""

    def mesh(self):
        """
        mesh(self) -> Mesh

        Return mesh. 
        """

    def element(self):
        """
        element(self) -> FiniteElement

        Return finite element. 
        """

    def dofmap(self):
        """
        dofmap(self) -> GenericDofMap

        Return dofmap. 
        """

    def dim(self):
        """
        dim(self) -> uint

        Return dimension of function space. 
        """

    def interpolate(self, *args):
        """
        interpolate(self, GenericVector expansion_coefficients, GenericFunction v)

        Interpolate function v into function space, returning the vector of
        expansion coefficients 
        """

    def sub(self, *args):
        """sub(self, uint i) -> __dummy_18__"""

    def extract_sub_space(self, *args):
        """
        extract_sub_space(self, std::vector<(dolfin::uint)> component) -> __dummy_18__

        Extract sub space for component. 
        """

    def collapse_sub_space(self, *args):
        """
        collapse_sub_space(self, __dummy_12__ dofmap) -> __dummy_18__

        Return function space with a new dof map. 
        """

    def has_cell(self, *args):
        """
        has_cell(self, Cell cell) -> bool

        Check if function space has given cell. 
        """

    def has_element(self, *args):
        """
        has_element(self, FiniteElement element) -> bool

        Check if function space has given element. 
        """

    def component(self):
        """
        component(self) -> dolfin::Array<(dolfin::uint)>

        Return component (relative to super space). 
        """

    def print_dofmap(self):
        """
        print_dofmap(self)

        Print dofmap (useful for debugging). 
        """

    def str(self,verbose):
        """Return a string representation of it self"""

    def __contains__(self,u):
        """Check whether a function is in the FunctionSpace"""

class SubSpace(FunctionSpace):
    """
    This class represents a subspace (component) of a function space.

    The subspace is specified by an array of indices. For example, the
    array [3, 0, 2] specifies subspace 2 of subspace 0 of subspace 3.

    A typical example is the function space W = V x P for Stokes. Here, V
    = W[0] is the subspace for the velocity component and P = W[1] is the
    subspace for the pressure component. Furthermore, W[0][0] = V[0] is
    the first component of the velocity space etc.

    C++ includes: SubSpace.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, FunctionSpace V, uint component) -> SubSpace
        __init__(self, FunctionSpace V, uint component, uint sub_component) -> SubSpace
        __init__(self, FunctionSpace V, std::vector<(dolfin::uint)> component) -> SubSpace

        Create subspace for given component (n levels). 
        """

def SubSpace_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class Constant(Expression):
    """
    This class represents a constant-valued expression.

    C++ includes: Constant.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, double value) -> Constant
        __init__(self, double value0, double value1) -> Constant
        __init__(self, double value0, double value1, double value2) -> Constant
        __init__(self, std::vector<(double)> values) -> Constant
        __init__(self, std::vector<(dolfin::uint)> value_shape, std::vector<(double)> values) -> Constant
        __init__(self, Constant constant) -> Constant

        Copy constructor. 
        """

    def assign(self, *args):
        """
        assign(self, Constant constant) -> Constant
        assign(self, double constant) -> Constant
        """

    def __float__(self):
        """__float__(self) -> double"""

def Constant_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class MeshCoordinates(Expression):
    """
    This Function represents the mesh coordinates on a given mesh.

    C++ includes: SpecialFunctions.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, Mesh mesh) -> MeshCoordinates

        Constructor. 
        """

def MeshCoordinates_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class CellSize(Expression):
    """
    This Function represents the local cell size on a given mesh.

    C++ includes: SpecialFunctions.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, Mesh mesh) -> CellSize

        Constructor. 
        """

def CellSize_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class FacetArea(Expression):
    """
    This function represents the area/length of a cell facet on a given
    mesh.

    C++ includes: SpecialFunctions.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, Mesh mesh) -> FacetArea

        Constructor. 
        """

def FacetArea_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class FunctionPlotData(Variable):
    """
    This class is used for communicating plot data for functions to and
    from (XML) files. It is used by DOLFIN for plotting Function objects.
    The data is stored as a mesh and a vector of interpolated vertex
    values.

    C++ includes: FunctionPlotData.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, GenericFunction v, Mesh mesh) -> FunctionPlotData
        __init__(self) -> FunctionPlotData

        Create empty data to be read from file. 
        """

    def vertex_values(self):
        """
        vertex_values(self) -> GenericVector

        Return vertex values. 
        """

def dolfin_init(*args):
  """
    dolfin_init(int argc, char argv)

    Initialize DOLFIN (and PETSc) with command-line arguments. This should
    not be needed in most cases since the initialization is otherwise
    handled automatically. 
    """

class MPICommunicator(object):
    """Proxy of C++ dolfin::MPICommunicator class"""

    def __init__(self): 
        """__init__(self) -> MPICommunicator"""

    def __ref__(self):
        """__ref__(self) -> MPI_Comm"""

class MPI(object):
    """
    This class provides utility functions for easy communcation with MPI.

    C++ includes: MPI.h 
    """

    def process_number():
        """process_number() -> uint"""

    def num_processes():
        """num_processes() -> uint"""

    def is_broadcaster():
        """is_broadcaster() -> bool"""

    def is_receiver():
        """is_receiver() -> bool"""

    def barrier():
        """barrier()"""

    def distribute(*args):
        """
        distribute(std::vector<(dolfin::uint)> values, std::vector<(dolfin::uint)> partition)
        distribute(std::vector<(dolfin::uint)> partition)
        """

    def scatter(*args):
        """
        scatter(std::vector<(dolfin::uint)> values, uint sending_process = 0)
        scatter(std::vector<(dolfin::uint)> values)
        scatter(std::vector<(std::vector<(dolfin::uint)>)> values, 
            uint sending_process = 0)
        scatter(std::vector<(std::vector<(dolfin::uint)>)> values)
        scatter(std::vector<(std::vector<(double)>)> values, uint sending_process = 0)
        scatter(std::vector<(std::vector<(double)>)> values)
        """

    def gather(*args):
        """
        gather(uint value) -> std::vector<(dolfin::uint)>
        gather(std::vector<(dolfin::uint)> values)
        gather()
        """

    def global_maximum(*args):
        """global_maximum(uint size) -> uint"""

    def sum(*args):
        """
        sum(double value) -> double
        sum(uint value) -> uint
        """

    def global_offset(*args):
        """global_offset(uint range, bool exclusive) -> uint"""

    def send_recv(*args):
        """
        send_recv(uint send_buffer, uint send_size, uint dest, uint recv_buffer, 
            uint recv_size, uint source) -> uint
        send_recv(double send_buffer, uint send_size, uint dest, double recv_buffer, 
            uint recv_size, uint source) -> uint
        """

    def local_range(*args):
        """
        local_range(uint N) -> std::pair<(dolfin::uint,dolfin::uint)>
        local_range(uint process, uint N) -> std::pair<(dolfin::uint,dolfin::uint)>
        """

    def index_owner(*args):
        """index_owner(uint index, uint N) -> uint"""

    def __init__(self): 
        """__init__(self) -> MPI"""

def MPI_process_number():
  """MPI_process_number() -> uint"""

def MPI_num_processes():
  """MPI_num_processes() -> uint"""

def MPI_is_broadcaster():
  """MPI_is_broadcaster() -> bool"""

def MPI_is_receiver():
  """MPI_is_receiver() -> bool"""

def MPI_barrier():
  """MPI_barrier()"""

def MPI_distribute(*args):
  """
    distribute(std::vector<(dolfin::uint)> values, std::vector<(dolfin::uint)> partition)
    MPI_distribute(std::vector<(dolfin::uint)> partition)
    """

def MPI_scatter(*args):
  """
    scatter(std::vector<(dolfin::uint)> values, uint sending_process = 0)
    scatter(std::vector<(dolfin::uint)> values)
    scatter(std::vector<(std::vector<(dolfin::uint)>)> values, 
        uint sending_process = 0)
    scatter(std::vector<(std::vector<(dolfin::uint)>)> values)
    scatter(std::vector<(std::vector<(double)>)> values, uint sending_process = 0)
    MPI_scatter(std::vector<(std::vector<(double)>)> values)
    """

def MPI_gather(*args):
  """
    gather(uint value) -> std::vector<(dolfin::uint)>
    gather(std::vector<(dolfin::uint)> values)
    MPI_gather()
    """

def MPI_global_maximum(*args):
  """MPI_global_maximum(uint size) -> uint"""

def MPI_sum(*args):
  """
    sum(double value) -> double
    MPI_sum(uint value) -> uint
    """

def MPI_global_offset(*args):
  """MPI_global_offset(uint range, bool exclusive) -> uint"""

def MPI_send_recv(*args):
  """
    send_recv(uint send_buffer, uint send_size, uint dest, uint recv_buffer, 
        uint recv_size, uint source) -> uint
    MPI_send_recv(double send_buffer, uint send_size, uint dest, double recv_buffer, 
        uint recv_size, uint source) -> uint
    """

def MPI_local_range(*args):
  """
    local_range(uint N) -> std::pair<(dolfin::uint,dolfin::uint)>
    MPI_local_range(uint process, uint N) -> std::pair<(dolfin::uint,dolfin::uint)>
    """

def MPI_index_owner(*args):
  """MPI_index_owner(uint index, uint N) -> uint"""

def sqr(*args):
  """
    sqr(double x) -> double

    Return the square of x. 
    """

def ipow(*args):
  """
    ipow(uint a, uint n) -> uint

    Return a to the power n. 
    """

def rand():
  """
    rand() -> double

    Return a random number, uniformly distributed between [0.0, 1.0). 
    """

def seed(*args):
  """
    seed(unsigned int s)

    Seed random number generator. 
    """

class Lagrange(Variable):
    """
    Lagrange polynomial (basis) with given degree q determined by n = q +
    1 nodal points.

    Example: q = 1 (n = 2)

    Lagrange p(1); p.set(0, 0.0); p.set(1, 1.0);

    This creates a Lagrange polynomial (actually two Lagrange
    polynomials):

    p(0,x) = 1 - x (one at x = 0, zero at x = 1) p(1,x) = x (zero at x =
    0, one at x = 1)

    C++ includes: Lagrange.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, unsigned int q) -> Lagrange
        __init__(self, Lagrange p) -> Lagrange

        Copy constructor. 
        """

    def set(self, *args):
        """
        set(self, unsigned int i, real x)

        Specify point. 
        """

    def size(self):
        """
        size(self) -> unsigned int

        Return number of points. 
        """

    def degree(self):
        """
        degree(self) -> unsigned int

        Return degree. 
        """

    def point(self, *args):
        """
        point(self, unsigned int i) -> real

        Return point. 
        """

    def __call__(self, *args):
        """__call__(self, unsigned int i, real x) -> real"""

    def eval(self, *args):
        """
        eval(self, unsigned int i, real x) -> real

        Return value of polynomial i at given point x. 
        """

    def ddx(self, *args):
        """
        ddx(self, unsigned int i, real x) -> real

        Return derivate of polynomial i at given point x. 
        """

    def dqdx(self, *args):
        """
        dqdx(self, unsigned int i) -> real

        Return derivative q (a constant) of polynomial. 
        """

class Legendre(object):
    """
    Legendre polynomial of given degree n on the interval [-1,1].

    P0(x) = 1 P1(x) = x P2(x) = (3x^2 - 1) / 2 ...

    The function values and derivatives are computed using three-term
    recurrence formulas.

    C++ includes: Legendre.h 
    """

    def __init__(self, *args): 
        """__init__(self, uint n) -> Legendre"""

    def __call__(self, *args):
        """__call__(self, real x) -> real"""

    def eval(self, *args):
        """
        eval(self, uint nn, real x) -> real

        Evaluation of arbitrary order, nn <= n (useful ie in RadauQuadrature).

        """

    def ddx(self, *args):
        """
        ddx(self, real x) -> real
        ddx(self, uint n, real x) -> real
        """

    def d2dx(self, *args):
        """
        d2dx(self, real x) -> real
        d2dx(self, uint n, real x) -> real
        """

class Quadrature(Variable):
    """Proxy of C++ dolfin::Quadrature class"""

    def __init__(self, *args): 
        """
        __init__(self, unsigned int n) -> Quadrature

        Constructor. 
        """

    def size(self):
        """
        size(self) -> int

        Return number of quadrature points. 
        """

    def point(self, *args):
        """
        point(self, unsigned int i) -> real

        Return quadrature point. 
        """

    def weight(self, *args):
        """
        weight(self, unsigned int i) -> real

        Return quadrature weight. 
        """

    def measure(self):
        """
        measure(self) -> real

        Return sum of weights (length, area, volume). 
        """

class GaussianQuadrature(Quadrature):
    """
    Gaussian-type quadrature rule on the double line, including Gauss,
    Radau, and Lobatto quadrature.

    Points and weights are computed to be exact within a tolerance of
    DOLFIN_EPS. Comparing with known exact values for n <= 3 shows that we
    obtain full precision (16 digits, error less than 2e-16).

    C++ includes: GaussianQuadrature.h 
    """

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

class GaussQuadrature(GaussianQuadrature):
    """
    Gauss (Gauss-Legendre) quadrature on the interval [-1,1]. The n
    quadrature points are given by the zeros of the n:th Legendre Pn(x).

    The quadrature points are computed using Newton's method, and the
    quadrature weights are computed by solving a linear system determined
    by the condition that Gauss quadrature with n points should be exact
    for polynomials of degree 2n-1.

    C++ includes: GaussQuadrature.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, unsigned int n) -> GaussQuadrature

        Create Gauss quadrature with n points. 
        """

class RadauQuadrature(GaussianQuadrature):
    """
    Radau (Gauss-Radau) quadrature on the interval [-1,1]. The n
    quadrature points are given by the zeros of

    ( Pn-1(x) + Pn(x) ) / (1+x)

    where Pn is the n:th Legendre polynomial.

    The quadrature points are computed using Newton's method, and the
    quadrature weights are computed by solving a linear system determined
    by the condition that Radau quadrature with n points should be exact
    for polynomials of degree 2n-2.

    C++ includes: RadauQuadrature.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, unsigned int n) -> RadauQuadrature

        Create Radau quadrature with n points. 
        """

class LobattoQuadrature(GaussianQuadrature):
    """
    Lobatto (Gauss-Lobatto) quadrature on the interval [-1,1]. The n
    quadrature points are given by the end-points -1 and 1, and the zeros
    of P{n-1}'(x), where P{n-1}(x) is the (n-1):th Legendre polynomial.

    The quadrature points are computed using Newton's method, and the
    quadrature weights are computed by solving a linear system determined
    by the condition that Lobatto quadrature with n points should be exact
    for polynomials of degree 2n-3.

    C++ includes: LobattoQuadrature.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, unsigned int n) -> LobattoQuadrature

        Create Lobatto quadrature with n points. 
        """

class BarycenterQuadrature(object):
    """Proxy of C++ dolfin::BarycenterQuadrature class"""

    def __init__(self, *args): 
        """__init__(self, Nef_polyhedron_3 polyhedron) -> BarycenterQuadrature"""

    def points(self):
        """points(self) -> std::vector<(dolfin::Point)>"""

    def weights(self):
        """weights(self) -> std::vector<(double)>"""

    def size(self):
        """size(self) -> uint"""

class ALE(object):
    """
    This class provides functionality useful for implementation of ALE
    (Arbitrary Lagrangian-Eulerian) methods, in particular moving the
    boundary vertices of a mesh and then interpolating the new coordinates
    for the interior vertices accordingly.

    C++ includes: ALE.h 
    """

    def move(*args):
        """
        move(Mesh mesh, BoundaryMesh new_boundary, ALEType method = lagrange)
        move(Mesh mesh, BoundaryMesh new_boundary)
        move(Mesh mesh0, Mesh mesh1, ALEType method = lagrange)
        move(Mesh mesh0, Mesh mesh1)
        move(Mesh mesh, Function displacement)
        """

    def __init__(self): 
        """__init__(self) -> ALE"""

def ALE_move(*args):
  """
    move(Mesh mesh, BoundaryMesh new_boundary, ALEType method = lagrange)
    move(Mesh mesh, BoundaryMesh new_boundary)
    move(Mesh mesh0, Mesh mesh1, ALEType method = lagrange)
    move(Mesh mesh0, Mesh mesh1)
    ALE_move(Mesh mesh, Function displacement)
    """

class GenericDofMap(Variable):
    """
    This class provides a generic interface for dof maps.

    C++ includes: GenericDofMap.h 
    """

    def __init__(self, *args, **kwargs):
        """No constructor defined - class is abstract"""

    def signature(self):
        """
        signature(self) -> string

        Return a string identifying the dof map. 
        """

    def needs_mesh_entities(self, *args):
        """
        needs_mesh_entities(self, unsigned int d) -> bool

        Return true iff mesh entities of topological dimension d are needed.

        """

    def global_dimension(self):
        """
        global_dimension(self) -> unsigned int

        Return the dimension of the global finite element function space. 
        """

    def local_dimension(self, *args):
        """
        local_dimension(self, cell cell) -> unsigned int

        Return the dimension of the local finite element function space on a
        cell 
        """

    def max_local_dimension(self):
        """
        max_local_dimension(self) -> unsigned int

        Return the maximum dimension of the local finite element function
        space. 
        """

    def geometric_dimension(self):
        """geometric_dimension(self) -> unsigned int"""

    def num_facet_dofs(self):
        """
        num_facet_dofs(self) -> unsigned int

        Return number of facet dofs. 
        """

    def tabulate_dofs(self, *args):
        """
        tabulate_dofs(self, uint dofs, cell ufc_cell, uint cell_index)
        tabulate_dofs(self, uint dofs, Cell cell)

        Tabulate the local-to-global mapping of dofs on a cell (DOLFIN cell
        version) 
        """

    def tabulate_facet_dofs(self, *args):
        """
        tabulate_facet_dofs(self, uint dofs, uint local_facet)

        Tabulate local-local facet dofs. 
        """

    def tabulate_coordinates(self, *args):
        """
        tabulate_coordinates(self, double coordinates, cell ufc_cell)
        tabulate_coordinates(self, double coordinates, Cell cell)

        Tabulate the coordinates of all dofs on a cell (DOLFIN cell version).

        """

    def extract_sub_dofmap(self, *args):
        """
        extract_sub_dofmap(self, std::vector<(dolfin::uint)> component, Mesh dolfin_mesh) -> GenericDofMap

        Extract sub dofmap component. 
        """

    def collapse(self, *args):
        """
        collapse(self, std::map<(dolfin::uint,dolfin::uint)> collapsed_map, 
            Mesh dolfin_mesh) -> GenericDofMap

        "Collapse" a sub dofmap 
        """

    def dofs(self, *args):
        """
        dofs(self, Mesh mesh, bool sort = False) -> dolfin::Set<(dolfin::uint)>
        dofs(self, Mesh mesh) -> dolfin::Set<(dolfin::uint)>

        Return the set of dof indices. 
        """

    def str(self,verbose):
        """Return a string representation of it self"""

class DofMap(GenericDofMap):
    """
    This class handles the mapping of degrees of freedom. It builds a dof
    map based on a ufc::dof_map on a specific mesh. It will reorder the
    dofs when running in parallel.

    If ufc_offset != 0, then the dof map provides a view into a larger dof
    map. A dof map which is a view, can be 'collapsed' such that the dof
    indices are contiguous.

    C++ includes: DofMap.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, __dummy_4__ ufc_dofmap, Mesh dolfin_mesh) -> DofMap

        Create dof map on mesh (const mesh version). 
        """

    def tabulate_dofs(self, *args):
        """
        tabulate_dofs(self, uint dofs, cell ufc_cell, uint cell_index)
        tabulate_dofs(self, uint dofs, Cell cell)

        Tabulate the local-to-global mapping of dofs on a cell (DOLFIN cell
        version). 
        """

    def tabulate_coordinates(self, *args):
        """
        tabulate_coordinates(self, double coordinates, cell ufc_cell)
        tabulate_coordinates(self, double coordinates, Cell cell)

        Tabulate the coordinates of all dofs on a cell (DOLFIN cell version).

        """

    def collapse(self, *args):
        """
        collapse(self, std::map<(dolfin::uint,dolfin::uint)> collapsed_map, 
            Mesh dolfin_mesh) -> DofMap

        "Collapse" a sub dofmap 
        """

    def dofs(self, *args):
        """
        dofs(self, Mesh mesh, bool sort = False) -> dolfin::Set<(dolfin::uint)>
        dofs(self, Mesh mesh) -> dolfin::Set<(dolfin::uint)>

        Return the set of dof indices. 
        """

    def extract_sub_dofmap(*args):
        """
        extract_sub_dofmap(std::vector<(dolfin::uint)> component, Mesh dolfin_mesh) -> DofMap
        extract_sub_dofmap(dof_map ufc_dof_map, uint offset, std::vector<(dolfin::uint)> component, 
            mesh ufc_mesh, Mesh dolfin_mesh) -> dof_map

        Extract sub dofmap component. 
        """

def DofMap_extract_sub_dofmap(*args):
  """
    extract_sub_dofmap(std::vector<(dolfin::uint)> component, Mesh dolfin_mesh) -> DofMap
    DofMap_extract_sub_dofmap(dof_map ufc_dof_map, uint offset, std::vector<(dolfin::uint)> component, 
        mesh ufc_mesh, Mesh dolfin_mesh) -> dof_map

    Extract sub dofmap component. 
    """

def DofMap_SWIGSharedPtrUpcast(*args):
    """Missing docstring"""

class FiniteElement(object):
    """
    This is a wrapper for a UFC finite element (ufc::finite_element).

    C++ includes: FiniteElement.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, __dummy_3__ element) -> FiniteElement

        Create finite element from UFC finite element (data may be shared). 
        """

    def signature(self):
        """signature(self) -> string"""

    def hash(self):
        """
        hash(self) -> uint

        Return simple hash of the signature string. 
        """

    def value_rank(self):
        """value_rank(self) -> uint"""

    def value_dimension(self, *args):
        """value_dimension(self, uint i) -> uint"""

    def num_sub_elements(self):
        """num_sub_elements(self) -> uint"""

    def space_dimension(self):
        """space_dimension(self) -> uint"""

    def interpolate_vertex_values(self, *args):
        """interpolate_vertex_values(self, double vertex_values, double coefficients, cell cell)"""

    def evaluate_basis(self, *args):
        """
        evaluate_basis(self, uint i, double values, double x, cell cell)
        evaluate_basis(self, uint i, double values, double x, Cell cell)
        """

    def evaluate_basis_derivatives(self, *args):
        """
        evaluate_basis_derivatives(self, unsigned int i, unsigned int n, double values, double x, 
            cell cell)
        """

    def evaluate_dof(self, *args):
        """evaluate_dof(self, uint i, function function, cell cell) -> double"""

    def create_sub_element(self, *args):
        """
        create_sub_element(self, uint i) -> __dummy_17__

        Create sub element. 
        """

    def ufc_element(self):
        """
        ufc_element(self) -> __dummy_3__

        Return ufc::finite_element. 
        """

    def extract_sub_element(self, *args):
        """
        extract_sub_element(self, std::vector<(dolfin::uint)> component) -> __dummy_17__

        Extract sub finite element for component. 
        """

class BasisFunction(ufc.function):
    """
    This class represents a finite element basis function. It can be used
    for computation of basis function values and derivatives.

    Evaluation of basis functions is also possible through the use of the
    functions evaluate_basis and evaluate_basis_derivatives available in
    the FiniteElement class. The BasisFunction class relies on these
    functions for evaluation but also implements the ufc::function
    interface which allows evaluate_dof to be evaluated for a basis
    function (on a possibly different element).

    C++ includes: BasisFunction.h 
    """

    def __init__(self, *args): 
        """
        __init__(self, uint index, FiniteElement element, cell cell) -> BasisFunction

        Create basis function with given index on element on given cell. 
        """

    def eval(self, *args):
        """
        eval(self, double values, double x)

        Evaluate basis function at given point. 
        """

    def eval_derivatives(self, *args):
        """
        eval_derivatives(self, double values, double x, uint n)

        Evaluate all order n derivatives at given point. 
        """

