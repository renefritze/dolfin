"""This module handles the Function class in Python.

The Function class needs special handling and is not mapped directly
by SWIG from the C++ interface. Instead, a new Function class is
created which inherits both from the DOLFIN C++ Function class (which
is renamed to cpp_Function in dolfin_function_pre.i) and the form
compiler Function class.

The resulting Function class may thus act both as a variable in a form
expression and as a Function on a mesh that may be evaluated, plotted
and stored to file.

Similarly, this module redefines the special functions defined in
SpecialFunctions.h, such as MeshSize and FacetNormal.

Note that the Function class currently inherits explicitly from the
FFC Function class. In future versions, it will instead inherit from
the UFL Function class, so that DOLFIN may be form compiler agnostic."""

__author__ = "Johan Hake (hake@simula.no)"
__date__ = "2008-11-03 -- 2008-11-19"
__copyright__ = "Copyright (C) 2008 Johan Hake"
__license__  = "GNU LGPL Version 2.1"

# Modified by Anders Logg, 2008.

__all__ = ["Function", "TestFunction", "TrialFunction", "BasisFunction"]
# FIXME: Add "FacetNormal", "MeshSize", "AvgMeshSize", "FacetArea", "InvFacetArea"

import types
import sys
import copy

import ffc
import dolfin

from compile_function import *
from functionspace import *

#--- Define class functions that will be set during class creation ---

def Function_function_space(self):
    " Return the function space."
    return self._V

def Function__str__(self):
    return "Function in %s" % str(self._V)

#--- Define some helper functions ---

def _init_function(cpp_BaseFunction, userdefined_init = None):
    " Help function that return an __init__ function"
    
    if userdefined_init is None:
        def __init__(self, V):
            if not isinstance(V, FunctionSpace):
                raise TypeError, "The argument must be a 'FunctionSpace'"
            self._V = V
            cpp_BaseFunction.__init__(self,V)
            ffc.Function.__init__(self, V.element())
    else:
        def __init__(self, V, *arg, **kwargs):
            if not isinstance(V, FunctionSpace):
                raise TypeError, "The argument must be a 'FunctionSpace'"
            self._V = V
            
            # Calling the user defined_init
            userdefined_init(self, V, *arg, **kwargs)
            
            cpp_BaseFunction.__init__(self,V)
            ffc.Function.__init__(self, V.element())
    
    # Set the doc string of the init function
    if hasattr(userdefined_init,"__doc__"):
        __init__.__doc__ = userdefined_init.__doc__
    else:
        __init__.__doc__ = " Instantiate the Function"
    
    return __init__

def _check_cpp_arguments(cppdict):
    """A help function to check kwargs before sending them to compile functions.

    It returns an argument list that can be passed to compile_function
    """
    if 'cppcode' in cppdict:
        # Check wrong use of cppexp and defaults
        if 'cppexpr' in cppdict:
            print "*** Warning: Both 'cppexp' and 'cppcode' is defined. Only using 'cppcode'."
        if 'deafult' in cppdict:
            print "*** Warning: 'defaults' is defined but not used."
            
        # Check type of cppcode
        if not isinstance(cppdict['cppcode'], (str)):
            raise TypeError, "Provide a 'str' for 'cppcode'."
        
        return cppdict['cppcode'], True, None
    else:
        if not isinstance(cppdict['cppexpr'], (str,tuple, list)):
            raise TypeError, "Provide a 'str', 'tuple' or 'list' for 'cppexpr'."
        # Check for the defaults attribute
        if 'defaults' in cppdict:
            if not isinstance(cppdict['defaults'],dict):
                raise TypeError, "Provide a 'dict' for 'defaults'."
            
            for val in cppdict['defaults'].itervalues():
                if not isinstance(val, (int,float)):
                    raise TypeError, "All values in 'defaults' must be scalars."
        
        return cppdict['cppexpr'], False, cppdict.get('defaults',None)
    
#--- The Function meta class ---

class FunctionCreator(type):
    """Meta class for the Function class.

    This class allows for dynamic creation of Function classes.
    Depending on the attributes in the class, the created Function
    class will inherit either from a cpp_Function (which is a
    dolfin::Function), a user-defined C++ function that inherits
    dolfin::Function or dolfin::cpp_DiscreteFunction, which is a
    Function with an initialized vector.
    
    """
    
    def __new__(cls, name, bases, dictionary):
        """ Return a new Function class object
        
        cls        : The class that is created
        name       : Then name of the class
        bases      : The bases classes of the class
        dictionary : Any attributes of the class
        """

        # Default cpp_BaseFunction class
        cpp_BaseFunction = dolfin.cpp_Function
        
        # Check the cppcode and eval attributes
        if ('cppcode' in dictionary or 'cppexpr' in dictionary) \
               and 'eval' in dictionary:
            raise TypeError, "Cannot create class with both 'eval' and " + \
                  "'cppcode' or 'cppexpr' defined"
        
        # If we define the Function class, as done in this module below.
        if name == "Function":
            # Defining a discrete function
            cpp_BaseFunction = dolfin.cpp_DiscreteFunction
            
            # Define a __new__ function to be able to instantiate compile functions
            # directly with the statement:
            # f = Function(V,cppexpr = "exp(x[0])")
            def __new__(cls,  V, **kwargs):
                # If trying to instantiate one to many, compile functions
                if len(kwargs) > 0:
                    if 'cppcode' in dictionary or 'cppexpr' in kwargs:
                        # Check the handed cpp kwargs
                        args = _check_cpp_arguments(kwargs)

                        # Compile module and get the function classes
                        function_classes = compile_function(*args)

                        # Check type of V
                        assert(isinstance(V, (list, tuple, FunctionSpace)), "Provide a single 'FunctionSpace' or a 'list' or a 'tuple' with 'FunctionSpaces'")
                        if isinstance(V, (list, tuple)):
                            assert(len(V)==len(function_classes),"The number of provided 'FunctionSpaces' must be the same as the number of compiled 'Function classes'")
                        else:
                            V = [V]*len(function_classes)
                        
                        # Create the function classes and instantiate them
                        funcs = []
                        for i, Func in enumerate(function_classes):
                            class Function(ffc.Function,Func):
                                __init__        = _init_function(Func)
                                __str__        = Function__str__
                                function_space = Function_function_space
                            funcs.append(Function(V[i]))
                    else:
                        raise TypeError, "Valid 'kwargs' are 'cppcode' and 'cppexpr' together with 'defaults'"
                    if len(funcs) == 1:
                        return funcs[0]
                    return tuple(funcs)
                
                # Instantiate one of each base class.
                cpp_func = cpp_BaseFunction.__new__(cls,V)
                ffc_func = ffc.Function.__new__(cls, V.element())

                # Update the dict of cpp_func with the attributes from ffc_func
                cpp_func.__dict__.update(copy.deepcopy(ffc_func.__dict__))
                
                # Return the cpp_func object with the updated __dict__
                return cpp_func
            
            dictionary['__new__'] = __new__
            
        # If the Function class is a user defined python class
        elif 'eval' in dictionary:
            # Check type of eval
            if not isinstance(dictionary['eval'],types.FunctionType):
                raise TypeError, "'eval' must be a 'function'"
        
        # If cppcode or cppexpr is provided send it to compile_function
        elif 'cppcode' in dictionary or 'cppexpr' in dictionary:
            # Check the handed attributes and return an args tuple
            args = _check_cpp_arguments(dictionary)
            
            # Compile the expr and assume only one function class is returned
            cpp_BaseFunction = compile_function(*args)[0]
            
            # Remove any surpluss attributes
            dictionary.pop('cppcode',None)
            dictionary.pop('cppexpr',None)
            dictionary.pop('defaults',None)
            
        else:
            raise TypeError, "Some error..."
        
        # Extend the bases with the cpp_BaseFunction and ffc.Function
        bases = (ffc.Function,cpp_BaseFunction)
        
        # Attach the init function to the dictionary
        dictionary['__init__'] = _init_function(cpp_BaseFunction,\
                                                dictionary.get('__init__',None))

        return type.__new__(cls, name, bases, dictionary)

#--- The user interface ---

class Function(object):
    """Function represents a function in a finite element function space.

    Function is a versatile class that can be used either for coefficients
    in forms or for solutions of partial differential equations.

    A Function must always be instantiated with a FunctionSpace V but
    takes a variable number of additional arguments depending on the
    situation, leading to different representations of the Function.
    We describe these different options below.

    1. Discrete function
    --------------------

    If only a FunctionSpace V is given to the constructor, the Function
    will be represented as a finite element function in the FunctionSpace
    V defined by a Vector of degrees of freedom:
    
    >>> f = Function(V)

    One may access the Vector of degrees of freedom as follows:
    
    >>> x = f.vector()
    
    2. Simple user-defined JIT-compiled functions
    ---------------------------------------------

    One may alternatively specify a C++ code for evaluation of the Function
    as follows:

    >>> f0 = Function(V0, cppexpr='sin(x[0]) + cos(x[1]')
    >>> f1 = Function(V1, cppexpr=('cos(x[0])', 'sin(x[1]'))
    
    Here, f0 is is scalar and f1 is vector-valued. The corresponding
    FunctionSpaces need to be of matching rank.
    
    Tensor functions of rank 2 (matrices) may also be created:
    
    >>> f2 = Function(V2, cppexpr=(('exp(x[0])','sin(x[1]'),
                                   ('sin(x[0])','tan(x[1]')))

    In general, a single string expression will be interpreted as a
    scalar, a tuple of strings as a tensor of rank 1 (a vector) and a
    tuple of tuples of strings as a tensor of rank 2 (a matrix).
    
    The expressions may depend on x[0], x[1], and x[2] which carry
    information about the coordinates where the function is
    evaluated. All math functions defined in <cmath> are available to
    the user.

    Function parameters can be included as follows:
    
    >>> f = Function(V, cppexpr='A*sin(x[0]) + B*cos(x[1]')
    >>> f.A = 2.0
    >>> f.B = 4.0

    The parameters can only be scalars, and are all initialized to 0.0. The
    parameters can also be given default values, using the argument 'defaults':
    
    >>> f = Function(V, cppexpr='A*sin(x[0]) + B*cos(x[1])',
                        defaults={'A': 2.0,'B': 4.0})

    3. Complex user-defined JIT-compiled functions
    ----------------------------------------------

    One may also define a Function using more complicated logic with
    the argument 'cppcode'. This argument should be a string of C++
    code that implements a class that inherits from dolfin::Function.

    The following code illustrates how to define a Function that depends
    on material properties of the cells in a Mesh. A MeshFunction is
    used to mark cells with different properties.
    
    >>> code = '''
    class MyFunc : public Function
    {
    public:
    
      MeshFunction<uint> *cell_data;
      
      MyFunc(FunctionSpace& V) : Function(V), cell_data(0) {}
      
      void eval(double* values, const double* x)
      {
        dolfin_assert(cell_data);
        switch ((*cell_data)(data.cell()))
        {
        case 0:
          values[0] = exp(-x[0]);
          break;
        case 1:
          values[0] = exp(-x[2]);
          break;
        default:
          values[0] = 0.0;
        }
      }
    
    };'''
    
    >>> cell_data = MeshFunction('uint', V.mesh(), 2)
    >>> f = Function(V, cppcode=code)
    >>> f.cell_data = cell_data

    4. Batch-processed user-defined JIT-compiled functions
    ------------------------------------------------------
    
    By specifying a list of expressions for the argument 'cppexpr', one may
    compile several functions at a time. These may either be instantiated
    using a single function space common for all functions, or with a separate
    function space for each function:

    >>> f0, f1 = Function(V, cppexpr=['sin(x[0]) + cos(x[1]', 'exp([1])'])
    
    >>> f0, f1, f2 = Function([V0, V1, V2], cppexpr=['sin(x[0]) + cos(x[1]',
                                                     ('cos(x[0])','sin(x[1]'),
                                                    (('cos(x[0])','sin(x[1]'),
                                                     ('sin(x[0])','cos(x[1]'))])

    Batch-processing of JIT-compiled functions may significantly speed up
    JIT-compilation at run-time.
    
    5. User-defined functions by subclassing
    ----------------------------------------

    The user can subclass Function and overload the 'eval' function. The subclass
    must then instantiated using a FunctionSpace:
    
    >>> class MyFunction(Function):
            def eval(self, value, x):
                dx = x[0] - 0.5
                dy = x[1] - 0.5
                values[0] = 500.0*exp(-(dx*dx + dy*dy)/0.02)
    >>> f = MyFunction(V)

    Note that subclassing may be significantly slower than using JIT-compiled
    functions. This is because a callback from C++ to Python will be involved
    each time a Function needs to be evaluated.
    
    6. User-defined JIT-compiled functions by subclassing
    -----------------------------------------------------

    The user can also subclass Function and define the same attributes as described
    above for JIT-compiled functions: 'cppexpr', 'defaults' and 'cppcode'.
    
    >>> class MyFunction0(Function):
            cppexpr = 'A*exp(-(pow(x[0]-0.5,2) + pow(x[1]-0.5,2))/B)'
            defaults = {"A": 500.0, "B": 0.02}
    >>> f0 = MyFunction0(V)
    
    >>> class MyFunction1(Function):
            cppcode = code # See above for an example code.
    >>> f1 = MyFunction1(V)
    >>> f1.mf = mf

    This is useful for example when the Function needs to initialize or
    precompute data, that is, when it behaves like a "functor".

    """

    # Set the meta class
    __metaclass__ = FunctionCreator

    # Set function attributes
    function_space = Function_function_space
    __str__        = Function__str__

#--- Helper functions for defining the interface of {Basis,Trial,Test}Function ---

def BasisFunction__str__(self):
    return "%s in %s"%(type(self).__name__,str(self._V))

def BasisFunction__init__(Base):
    def __init__(self,V):
        if not isinstance(V,FunctionSpace):
            raise TypeError, "Provide a 'FunctionSpace'."
        Base.__init__(self, V.element())
        # We need to attach the FunctionSpace after calling
        # Base.__init__()
        self.data = V
    
    return __init__

#--- Subclassing of ffc.{Basis,Trial,Test}Function ---

class BasisFunction(ffc.BasisFunction):
    __init__ = BasisFunction__init__(ffc.BasisFunction)

class TrialFunction(ffc.TrialFunction):
    __init__ = BasisFunction__init__(ffc.TrialFunction)

class TestFunction(ffc.TestFunction):
    __init__ = BasisFunction__init__(ffc.TestFunction)

## Create new class inheriting from both FFC and DOLFIN FacetNormal
## (FFC FacetNormal is a function that returns a FFC Function object)
#class FacetNormal(ffc.Function, dolfin.cpp_FacetNormal):
#
#    def __init__(self, shape, mesh):
#        "Create FacetNormal"
#
#        element = ffc.VectorElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_FacetNormal.__init__(self, mesh)
#
## Create new class inheriting from FFC MeshSize and DOLFIN MeshSize
## (FFC MeshSize is a function that returns a FFC Function object)
#class MeshSize(ffc.Function, dolfin.cpp_MeshSize):
#
#    def __init__(self, shape, mesh):
#        "Create MeshSize"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_MeshSize.__init__(self, mesh)
#
## Create new class inheriting from FFC MeshSize and DOLFIN AvgMeshSize
## (FFC MeshSize is a function that returns a FFC Function object)
#class AvgMeshSize(ffc.Function, dolfin.cpp_AvgMeshSize):
#
#    def __init__(self, shape, mesh):
#        "Create AvgMeshSize"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_AvgMeshSize.__init__(self, mesh)
#
## Create new class inheriting from FFC FacetArea and DOLFIN FacetArea
## (FFC FacetArea is a function that returns a FFC Function object)
#class FacetArea(ffc.Function, dolfin.cpp_FacetArea):
#
#    def __init__(self, shape, mesh):
#        "Create FacetArea"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_FacetArea.__init__(self, mesh)
#
## Create new class inheriting from FFC InvFacetArea and DOLFIN InvFacetArea
## (FFC InvFacetArea is a function that returns a FFC Function object)
#class InvFacetArea(ffc.Function, dolfin.cpp_InvFacetArea):
#
#    def __init__(self, shape, mesh):
#        "Create InvFacetArea"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_InvFacetArea.__init__(self, mesh)
