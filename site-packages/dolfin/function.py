"""This module handles the Function class in Python.

The Function class needs special handling and is not mapped directly
by SWIG from C++ interface. Instead, a new Function class is created
which inherits both from the DOLFIN C++ Function (which is renamed to
cpp_Function in dolfin_function_pre.i) and the form compiler Function.

The resulting Function class may thus act both as a variable in a form
expression and as a Function on a mesh that may be evaluated, plotted
and stored to file.

Similarly, this module redefines the special functions defined in
SpecialFunctions.h, such as MeshSize and FacetNormal.

Note that the Function class currently inherits explicitly from the FFC
Function class. In future versions, it will instead inherit from the UFL
Function class, so that DOLFIN may be form compiler agnostic."""

__author__ = "Anders Logg (logg@simula.no)"
__date__ = "2007-08-15 -- 2008-11-03"
__copyright__ = "Copyright (C) 2007-2008 Anders Logg"
__license__  = "GNU LGPL Version 2.1"

__all__ = ["FunctionSpace","Function"]#, "FacetNormal", "MeshSize", "AvgMeshSize", "FacetArea", "InvFacetArea"]

import types
import ffc
import dolfin
import sys
from compile_function import *

def _init_function(cpp_BaseFunction, userdefined_init = None):
    " Help function that return an __init__ function"
    
    if userdefined_init is None:
        def __init__(self, V):
            if not isinstance(V,FunctionSpace):
                raise TypeError, "The argument must be a 'FunctionSpace'"
            self._V = V
            cpp_BaseFunction.__init__(self,V)
            ffc.Function.__init__(self,V.ffc_element())
    else:
        def __init__(self,V,*arg,**kwarg):
            if not isinstance(V,FunctionSpace):
                raise TypeError, "The argument must be a 'FunctionSpace'"
            self._V = V
            
            # Calling the user defined_init
            userdefined_init(self,V,*arg,**kwarg)
            
            cpp_BaseFunction.__init__(self,V)
            ffc.Function.__init__(self,V.ffc_element())
    
    # Set the doc string of the init function
    if hasattr(userdefined_init,"__doc__"):
        __init__.__doc__ = userdefined_init.__doc__
    else:
        __init__.__doc__ = " Instantiate the Function"
    
    return __init__

class FunctionSpace(dolfin.cpp_FunctionSpace):
    """ FunctionSpace represents a finite element function space
  
    A FunctionSpace is defined by a mesh, a finite element, and a
    local-to-global mapping of the degrees of freedom (dofmap).
    """
    def __init__(self, mesh, element):
        """ Create FunctionSpace
        
        mesh    : An instance of a DOLFIN Mesh
        element : A FiniteElement
        """
        assert(isinstance(mesh, dolfin.Mesh), "Invalid mesh type.")
        assert(isinstance(element, (ffc.FiniteElement,ffc.MixedElement)), \
               "Invalid element type.")
        
        # jit compile the ufc_element and ufc_dofmap and store the
        # element so python won't destroy it.
        self.__ufc_element, self.__ufc_dofmap = ffc.jit(element)
        
        self.__dofmap = dolfin.DofMap(self.__ufc_dofmap,mesh)
        self.__element = dolfin.FiniteElement(self.__ufc_element)
        
        # Initialize the cpp_FunctionSpace
        dolfin.cpp_FunctionSpace.__init__(self, mesh,self.__element,self.__dofmap)
        
        self._ffc_element = element
        
    def ffc_element(self):
        return self._ffc_element
    
    def __str__(self):
        return "%s function space"%(self._ffc_element.__class__.__name__,)

class FunctionCreator(type):
    """ Metaclass for Function

    This class allow for dynamic creation of Function classes.
    Dependent on the provided attributes in the class the created
    Function class will inherit either a cpp_Function which is a
    dolfin::Function, a user defined c++ function that inherits
    dolfin::Function or dolfin::cpp_DiscreteFunction, which is a
    function with an initialized vector.
    
    """
    def __new__(cls, name, bases, dictionary):
        """ Return a new Function class object
        
        cls        : The class that is created
        name       : Then name of the class
        bases      : The bases classes of the class
        dictionary : Any attributes of the class
        """

        # Default cpp_BaseFunction class
        cpp_BaseFunction = dolfin.cpp_Function
        
        # Check the cppcode and eval attributes
        if ('cppcode' in dictionary or 'cppexpr' in dictionary) \
               and 'eval' in dictionary:
            raise TypeError, "Cannot create class with both 'eval' and " + \
                  "'cppcode' or 'cppexpr' defined"
        
        # If the Function class is a user defined python class
        if 'eval' in dictionary:
            # Check type of eval
            if not isinstance(dictionary['eval'],types.FunctionType):
                raise TypeError, "'eval' must be a 'function'"
        
        # If cppcode or cppexpr is provided send it to compile_function
        elif 'cppcode' in dictionary or 'cppexpr' in dictionary:

            # If cppcode is defined then check attributes and send it
            # to compile_function
            if 'cppcode' in dictionary:
                # Check wrong use of cppexp and default
                if 'cppexpr' in dictionary:
                    print "*** Warning: Both 'cppexp' and 'cppcode' is defined. Only using 'cppcode'."
                if 'deafult' in dictionary:
                    print "*** Warning: 'default' is defined but not used."
                    
                # Check type of cppcode
                if not isinstance(dictionary['cppcode'],(str)):
                    raise TypeError, "Provide a 'str' as 'cppcode' attribute."
                
                # Compile the cppcode and get the compiled class
                cpp_BaseFunction = compile_function(dictionary['cppcode'],\
                                                    cppcode = True)
                # Remove the cppcode attribute
                dictionary.pop('cppcode')
            else:
                if not isinstance(dictionary['cppexpr'],(str,tuple)):
                    raise TypeError, "Provide a 'str' or 'tuple' as 'cppexpr' attribute."
                # Check for the default attribute
                if 'default' in dictionary:
                    if not isinstance(dictionary['default'],dict):
                        raise TypeError, "Provide a 'dict' for the default attribute."
                    
                    for val in dictionary['default'].itervalues():
                        if not isinstance(val,(int,float)):
                            raise TypeError, "All values in 'default' must be scalars."
                
                # Compile the cppexpr and get the compiled class
                cpp_BaseFunction = compile_function(dictionary['cppexpr'],\
                                     default = dictionary.get('default',None))
                
                # Remove the cppexpr attribute
                dictionary.pop('cppexpr')
        
        elif name == "Function":
            # Defining a discrete function
            cpp_BaseFunction = dolfin.cpp_DiscreteFunction
        else:
            raise TypeError, "Some error..."
        
        # Extend the bases with the cpp_BaseFunction and ffc.Function
        bases = (ffc.Function,cpp_BaseFunction)
        
        # Attach the init function to the dictionary
        dictionary['__init__'] = _init_function(cpp_BaseFunction,\
                                                dictionary.get('__init__',None))

        return type.__new__(cls, name, bases, dictionary)

class Function(object):
    """ A coefficient Function class
    
    Function is a class that can be used in 2 different ways:
    1) As a discrete function
    >>> u = Function(V)
    >>> vec = u.vector() # The coeffisients
    
    2) Subclassed as a userdefined coefficient function using:
    a) a python Functor
    >>> class MyFunction1(Function):
            def eval(self,value,x):
                dx = x[0] - 0.5
                dy = x[1] - 0.5
                values[0] = 500.0*exp(-(dx*dx + dy*dy)/0.02)
        f1 = MyFunction1(V)
    
    b) a jit compiled c++ Functor using the attributes cppexpr and default (optional)
    >>> class MyFunction2(Function):
            cppexpr = ("A*exp(-(pow(x[0]-0.5,2) + pow(x[1]-0.5,2))/B)")
            default = {"A":500.0,"B":0.02} # 'default' is optional. If not provided
                                           # 'A' and 'B' would have beed initialized to
                                           # 0.0
    >>> f2 = MyFunction2(V)
    
    or a jit compiled c++ Functor using the attribute cppcode. This should be a str of
    c++ code that implements a class that inherits from dolfin::Function,
    >>> class MyFunction3(Function):
            cppcode = '''
                class MyFunc : public Function
                {
                  MeshFunction<uint> *mf;
                  MyFunc(FunctionSpace & V) : Function(V), mf(0) {}
                  void eval(double* val, const Data& data) {
                    dolfin_assert(mf);
                    switch ( (*mf)(data.cell())){
                    case 0: val[0] = exp(-data.x[0]); break;
                    case 1: val[0] = exp(-data.x[2]); break;
                    defalt: val[0] = 0.0;
                    }
                  }
                };
                '''
    
    >>> mf = MeshFunction('uint',V.mesh(),2)
    >>> f3 = MyFunction3(V)
    >>> f3.mf = mf

    """
    __metaclass__ = FunctionCreator
    
    def function_space(self):
        " Return the function space" 
        return self._V

    def __str__(self):
        return "Function in %s"%str(self._V)

## Create new class inheriting from both FFC and DOLFIN FacetNormal
## (FFC FacetNormal is a function that returns a FFC Function object)
#class FacetNormal(ffc.Function, dolfin.cpp_FacetNormal):
#
#    def __init__(self, shape, mesh):
#        "Create FacetNormal"
#
#        element = ffc.VectorElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_FacetNormal.__init__(self, mesh)
#
## Create new class inheriting from FFC MeshSize and DOLFIN MeshSize
## (FFC MeshSize is a function that returns a FFC Function object)
#class MeshSize(ffc.Function, dolfin.cpp_MeshSize):
#
#    def __init__(self, shape, mesh):
#        "Create MeshSize"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_MeshSize.__init__(self, mesh)
#
## Create new class inheriting from FFC MeshSize and DOLFIN AvgMeshSize
## (FFC MeshSize is a function that returns a FFC Function object)
#class AvgMeshSize(ffc.Function, dolfin.cpp_AvgMeshSize):
#
#    def __init__(self, shape, mesh):
#        "Create AvgMeshSize"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_AvgMeshSize.__init__(self, mesh)
#
## Create new class inheriting from FFC FacetArea and DOLFIN FacetArea
## (FFC FacetArea is a function that returns a FFC Function object)
#class FacetArea(ffc.Function, dolfin.cpp_FacetArea):
#
#    def __init__(self, shape, mesh):
#        "Create FacetArea"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_FacetArea.__init__(self, mesh)
#
## Create new class inheriting from FFC InvFacetArea and DOLFIN InvFacetArea
## (FFC InvFacetArea is a function that returns a FFC Function object)
#class InvFacetArea(ffc.Function, dolfin.cpp_InvFacetArea):
#
#    def __init__(self, shape, mesh):
#        "Create InvFacetArea"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_InvFacetArea.__init__(self, mesh)
