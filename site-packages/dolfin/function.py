"""This module handles the Function class in Python.

The Function class needs special handling and is not mapped directly
by SWIG from the C++ interface. Instead, a new Function class is
created which inherits both from the DOLFIN C++ Function class (which
is renamed to cpp_Function in dolfin_function_pre.i) and the form
compiler Function class.

The resulting Function class may thus act both as a variable in a form
expression and as a Function on a mesh that may be evaluated, plotted
and stored to file.

Similarly, this module redefines the special functions defined in
SpecialFunctions.h, such as MeshSize and FacetNormal.

Note that the Function class currently inherits explicitly from the
FFC Function class. In future versions, it will instead inherit from
the UFL Function class, so that DOLFIN may be form compiler agnostic.

This module make heavy use of creation of Function classes and
instantiation of these dynamically during runtime.

The whole logic behind this somewhat magic behaviour is confined by the:

  1) function __new__ in the Function class
  2) meta class FunctionMetaClass
  3) function compile_function from the module with the same name
  4) function Function_factory

The __new__ function in the Function class take care of the logics
when the class Function is used to create an instance of Function,
see user case 1-4 in the docstring of Function.

The meta class FunctionMetaClass take care of the logic when a user
subclass Function to create a userdefined Function, see user case 5
and 6 in the docstring of Function.

The function compile_function is a Jit compiler. It compiles and returns
different kinds of cpp.Function classes, depending on the arguments. These
classes is sent to the Function_factory. 

The Function_factory is called when the different dynamically created
Function classes actually are created. It takes a name, and a compiled
cpp.Function and returns a dolfin.Function class. This class inherits
ffc.Function, cpp.Function and dolfin.Function.
"""

__author__ = "Johan Hake (hake@simula.no)"
__date__ = "2008-11-03 -- 2008-11-19"
__copyright__ = "Copyright (C) 2008 Johan Hake"
__license__  = "GNU LGPL Version 2.1"

# Modified by Anders Logg, 2008.

__all__ = ["Function", "TestFunction", "TrialFunction", "BasisFunction"]
# FIXME: Add "FacetNormal", "MeshSize", "AvgMeshSize", "FacetArea", "InvFacetArea"

import types
import sys
import copy

# Importing ffc and the swig generated extension module of dolfin, cpp.
import ffc
import cpp

from compile_function import *
from functionspace import *

def Function_factory(name, cpp_base, user_eval = None, user_init = None):
    """ Return a Function class

    This function is used to create all the dynamically created Function 
    classes. It takes a name, and a compiled cpp.Function and returns
    a dolfin.Function class. In addition to cpp.Function and dolfin.Function
    it also inherits from ffc.Function.
    
    @params name      : The name of the class
    @params cpp_base  : The cpp.Function base class which the created
                        Function class shall inherit.
    @params user_eval : Optional user specified eval function
    @params user_init : Optional user specified __init__ function
    """
    
    #--- Define class functions that will be set during class creation ---
    
    def Function_function_space(self):
        " Return the function space."
        return self._V
    
    def Function__str__(self):
        return "Function in %s" % str(self._V)

    def Function__repr__(self):
        return ffc.Function.__repr__(self)
    
    #--- Define helper functions that returns class functions ---
    
    def construct__new__(cpp_base):
        " Help function that return an __new__ function"
        def __new__(cls,V):
            """ Instantiate a new Function
            
            @param V : A FunctionSpace
            """
            # Instantiate one of each base class.
            ret_func = cpp_base.__new__(cls,V)
            ffc_func = ffc.Function.__new__(cls,V.element())
            
            # Update the dict of the ret_func with the attributes from ffc_func
            ret_func.__dict__.update(copy.deepcopy(ffc_func.__dict__))
            
            # Return the cpp_func object with the updated __dict__
            return ret_func
        
        return __new__

    def construct__init__(cpp_base, user_init = None):
        " Help function that return an __init__ function"

        # If not an user defined init function is provided
        if user_init is None:
            def __init__(self, V, *args, **kwargs):
                # Check if the Function already is initialized
                if hasattr(self,"__init_called"):
                    return

                # Check type of FunctionSpace
                if not isinstance(V, FunctionSpace):
                    raise TypeError, "The argument must be a 'FunctionSpace'"
                self._V = V

                # Initialize base classes
                cpp_base.__init__(self,V)
                ffc.Function.__init__(self, V.element())
                
                # Set a flag to prevent additional calls to init
                self.__init_called = True
                
        # If an user defined init function is provided
        else:
            def __init__(self, V, *arg, **kwargs):
                # Check if the Function already is initialized
                if hasattr(self,"__init_called"):
                    return

                # Check type of FunctionSpace
                if not isinstance(V, FunctionSpace):
                    raise TypeError, "The argument must be a 'FunctionSpace'"
                self._V = V
                
                # Calling the user defined_init
                user_init(self, V, *arg, **kwargs)
                
                # Initialize base classes
                cpp_base.__init__(self,V)
                ffc.Function.__init__(self, V.element())
                
                # Set a flag to prevent additional calls to init
                self.__init_called = True
                
        # Set the doc string of the init function
        if hasattr(user_init,"__doc__"):
            __init__.__doc__ = user_init.__doc__
        else:
            __init__.__doc__ = """ Instantiate the Function

            @param V : FunctionSpace
            """
        
        return __init__

    # Define the bases
    bases = (ffc.Function,cpp_base,Function)
    
    # Define the dictionary of the class
    dict_ = {}
    dict_["function_space"] = Function_function_space
    dict_["__str__"]        = Function__str__
    dict_["__repr__"]       = Function__repr__
    dict_["__init__"]       = construct__init__(cpp_base,user_init)
    dict_["__new__"]        = construct__new__(cpp_base)

    # If a user defined eval function is provided
    if not user_eval is None:
        # Check type of user_eval
        if not isinstance(user_eval,types.FunctionType):
            raise TypeError, "'eval' attribute must be a 'function'"
        dict_["eval"] = user_eval
    
    # Create the class and return it
    return type(name,bases,dict_)
    
class FunctionMetaClass(type):
    def __new__(cls, name, bases, dict_):
        """ Return a new Function class """
        assert(isinstance(name,str)), "Expecting a 'str'"
        assert(isinstance(bases,tuple)), "Expecting a 'tuple'"
        assert(isinstance(dict_,dict)), "Expecting a 'dict'"
        
        # First check if we are creating the Function class
        if name == "Function":
            # Assert that the class is _not_ a subclass of Function,
            # i.e., a user have tried to:
            #
            #    class Function(Function):
            #        ...
            if len(bases) > 1 and bases[0] != object:
                raise TypeError, "Cannot name a subclass of Function: 'Function'"
            
            # Return the new class, which just is the original Function defined in
            # this module
            return type.__new__(cls,name, bases, dict_)
        
        # If subclassing Function through the Function_factory function above
        if len(bases) == 3 and bases[0] == ffc.Function and issubclass(bases[1],cpp.Function) and bases[2] == Function:
            # Return the instantiated class
            return type.__new__(cls,name,bases,dict_)
        
        # Check the cppcode and eval attributes
        if ('cppcode' in dict_ or 'cppexpr' in dict_) and 'eval' in dict_:
            raise TypeError, "Cannot create class with both 'eval' and 'cppcode' or 'cppexpr' attributes defined."
        
        # If the Function class is a user defined python class, case 5. from docstring
        if 'eval' in dict_:
            user_init = dict_.get("__init__",None)
            return Function_factory(name, cpp.Function, dict_["eval"], user_init)

        # If cppcode or cppexpr is provided, case 6. from docstring
        if 'cppcode' in dict_ or 'cppexpr' in dict_:
            
            # Check the handed attributes and return an args tuple
            args = _check_cpp_arguments(dict_)
            
            # Compile the expr and assume only one function class is returned
            cpp_base = compile_function(*args)[0]

            return Function_factory(name,cpp_base)

        # If we have reached this stage raise error
        raise TypeError, "Error in subclassing Function. For correct usage see 5. and 6. in Function docstring."
         

#--- The user interface ---

class Function(object):
    """Function represents a function in a finite element function space.

    Function is a versatile class that can be used either for coefficients
    in forms or for solutions of partial differential equations.

    A Function must always be instantiated with a FunctionSpace V but
    takes a variable number of additional arguments depending on the
    situation, leading to different representations of the Function.
    We describe these different options below.

    1. Discrete function
    --------------------

    If only a FunctionSpace V is given to the constructor, the Function
    will be represented as a finite element function in the FunctionSpace
    V defined by a Vector of degrees of freedom:
    
    >>> f = Function(V)

    One may access the Vector of degrees of freedom as follows:
    
    >>> x = f.vector()
    
    2. Simple user-defined JIT-compiled functions
    ---------------------------------------------

    One may alternatively specify a C++ code for evaluation of the Function
    as follows:

    >>> f0 = Function(V0, cppexpr='sin(x[0]) + cos(x[1]')
    >>> f1 = Function(V1, cppexpr=('cos(x[0])', 'sin(x[1]'))
    
    Here, f0 is is scalar and f1 is vector-valued. The corresponding
    FunctionSpaces need to be of matching rank.
    
    Tensor functions of rank 2 (matrices) may also be created:
    
    >>> f2 = Function(V2, cppexpr=(('exp(x[0])','sin(x[1]'),
                                   ('sin(x[0])','tan(x[1]')))

    In general, a single string expression will be interpreted as a
    scalar, a tuple of strings as a tensor of rank 1 (a vector) and a
    tuple of tuples of strings as a tensor of rank 2 (a matrix).
    
    The expressions may depend on x[0], x[1], and x[2] which carry
    information about the coordinates where the function is
    evaluated. All math functions defined in <cmath> are available to
    the user.

    Function parameters can be included as follows:
    
    >>> f = Function(V, cppexpr='A*sin(x[0]) + B*cos(x[1]')
    >>> f.A = 2.0
    >>> f.B = 4.0

    The parameters can only be scalars, and are all initialized to 0.0. The
    parameters can also be given default values, using the argument 'defaults':
    
    >>> f = Function(V, cppexpr='A*sin(x[0]) + B*cos(x[1])',
                        defaults={'A': 2.0,'B': 4.0})

    3. Complex user-defined JIT-compiled functions
    ----------------------------------------------

    One may also define a Function using more complicated logic with
    the argument 'cppcode'. This argument should be a string of C++
    code that implements a class that inherits from dolfin::Function.

    The following code illustrates how to define a Function that depends
    on material properties of the cells in a Mesh. A MeshFunction is
    used to mark cells with different properties.
    
    >>> code = '''
    class MyFunc : public Function
    {
    public:
    
      MeshFunction<uint> *cell_data;
      
      MyFunc(FunctionSpace& V) : Function(V), cell_data(0) {}
      
      void eval(double* values, const double* x)
      {
        dolfin_assert(cell_data);
        switch ((*cell_data)(data.cell()))
        {
        case 0:
          values[0] = exp(-x[0]);
          break;
        case 1:
          values[0] = exp(-x[2]);
          break;
        default:
          values[0] = 0.0;
        }
      }
    
    };'''
    
    >>> cell_data = MeshFunction('uint', V.mesh(), 2)
    >>> f = Function(V, cppcode=code)
    >>> f.cell_data = cell_data

    4. Batch-processed user-defined JIT-compiled functions
    ------------------------------------------------------
    
    By specifying a list of expressions for the argument 'cppexpr', one may
    compile several functions at a time. These may either be instantiated
    using a single function space common for all functions, or with a separate
    function space for each function:

    >>> f0, f1 = Function(V, cppexpr=['sin(x[0]) + cos(x[1]', 'exp([1])'])
    
    >>> f0, f1, f2 = Function([V0, V1, V2], cppexpr=['sin(x[0]) + cos(x[1]',
                                                     ('cos(x[0])','sin(x[1]'),
                                                    (('cos(x[0])','sin(x[1]'),
                                                     ('sin(x[0])','cos(x[1]'))])

    Batch-processing of JIT-compiled functions may significantly speed up
    JIT-compilation at run-time.
    
    5. User-defined functions by subclassing
    ----------------------------------------

    The user can subclass Function and overload the 'eval' function. The subclass
    must then instantiated using a FunctionSpace:
    
    >>> class MyFunction(Function):
            def eval(self, value, x):
                dx = x[0] - 0.5
                dy = x[1] - 0.5
                values[0] = 500.0*exp(-(dx*dx + dy*dy)/0.02)
    >>> f = MyFunction(V)

    Note that subclassing may be significantly slower than using JIT-compiled
    functions. This is because a callback from C++ to Python will be involved
    each time a Function needs to be evaluated.
    
    6. User-defined JIT-compiled functions by subclassing
    -----------------------------------------------------

    The user can also subclass Function and define the same attributes as described
    above for JIT-compiled functions: 'cppexpr', 'defaults' and 'cppcode'.
    
    >>> class MyFunction0(Function):
            cppexpr = 'A*exp(-(pow(x[0]-0.5,2) + pow(x[1]-0.5,2))/B)'
            defaults = {"A": 500.0, "B": 0.02}
    >>> f0 = MyFunction0(V)
    
    >>> class MyFunction1(Function):
            cppcode = code # See above for an example code.
    >>> f1 = MyFunction1(V)
    >>> f1.mf = mf

    This is useful for example when the Function needs to initialize or
    precompute data, that is, when it behaves like a "functor".

    """
    
    # Set the meta class
    #__metaclass__ = FunctionCreator
    __metaclass__ = FunctionMetaClass

    def __new__(cls, V, **kwargs):
        """ Instantiate a new Function
        
        @param V        : The Function Space
        @param cppexpr  : Optional argument, see docstring of the class
        @param defaults : Optional argument, see docstring of the class
        @param cppcode  : Optional argument, see docstring of the class 
        """
        # Check passed kwargs
        allowed_kwargs = ['cppcode','cppexpr','defaults']
        if not all(s in allowed_kwargs for s in kwargs.iterkeys()):
            raise TypeError, "Wrong kwargs passed to Function."
        
        # If no kwargs is provided, return an instantiated DiscreteFunction
        # 1. in Function docstring
        if len(kwargs) == 0:
            return Function_factory("DiscreteFunction",cpp.DiscreteFunction)(V)

        # The user instantiate one to many compiled functions.
        # 2., 3. or 4. from Function docstring
        
        # Check the handed cpp kwargs
        args = _check_cpp_arguments(kwargs)
        
        # Compile module and get the cpp.Function classes
        cpp_bases = compile_function(*args)
                
        # Check type of V
        if not isinstance(V, (list, tuple, FunctionSpace)):
            raise TypeErro, "Provide a single 'FunctionSpace' or a 'list' or a 'tuple' with 'FunctionSpaces'"

        # Check if a list of FunctionSpaces is provided
        if isinstance(V, (list, tuple)):
            # Check length of list of FunctionSpaces
            if not len(V)==len(cpp_bases):
                    raise TypeError, "The number of provided 'FunctionSpaces' must be the same as the number of compiled 'Function classes'"
        # If only one FunctionSpace is provided
        else:
            V = [V]*len(cpp_bases)
                        
        # Create the function classes and instantiate them
        return_functions = []
        for i, cpp_base in enumerate(cpp_bases):
            return_functions.append(Function_factory("CompiledFunction",cpp_base)(V[i]))
        
        if len(return_functions) == 1:
            return return_functions[0]
        return tuple(return_functions)
                
            
    # Set function attributes
    #function_space = Function_function_space
    #__str__        = Function__str__

#--- Helper functions for defining the interface of {Basis,Trial,Test}Function ---

def BasisFunction__str__(self):
    return "%s in %s"%(type(self).__name__,str(self._V))

def BasisFunction__init__(Base):
    def __init__(self,V):
        if not isinstance(V,FunctionSpace):
            raise TypeError, "Provide a 'FunctionSpace'."
        Base.__init__(self, V.element())
        # We need to attach the FunctionSpace after calling
        # Base.__init__()
        self.data = V
    
    return __init__

#--- Subclassing of ffc.{Basis,Trial,Test}Function ---

class BasisFunction(ffc.BasisFunction):
    __init__ = BasisFunction__init__(ffc.BasisFunction)

class TrialFunction(ffc.TrialFunction):
    __init__ = BasisFunction__init__(ffc.TrialFunction)

class TestFunction(ffc.TestFunction):
    __init__ = BasisFunction__init__(ffc.TestFunction)

# --- Help function ---

def _check_cpp_arguments(cppdict):
    """A helper function to check kwargs before sending them to compile functions.
    It returns an argument list that can be passed to compile_function.
    """

    if 'cppcode' in cppdict:

        # Check wrong use of cppexp and defaults
        if 'cppexpr' in cppdict:
            print cpp.warning("Both 'cppexp' and 'cppcode' are defined. Only using 'cppcode'.")
        if 'default' in cppdict:
            print cpp.warning("Attribute 'defaults' is defined but not used.")
            
        # Check type of cppcode
        if not isinstance(cppdict['cppcode'], (str)):
            raise TypeError, "Provide a 'str' for 'cppcode'."
        
        return cppdict['cppcode'], True, None
    
    else:

        # Check type of cppexpr
        if not isinstance(cppdict['cppexpr'], (str, tuple, list)):
            raise TypeError, "Provide a 'str', 'tuple' or 'list' for 'cppexpr'."
        
        # Check for the defaults attribute
        if 'defaults' in cppdict:
            
            if not isinstance(cppdict['defaults'], dict):
                raise TypeError, "Provide a 'dict' for 'defaults'."
            
            for val in cppdict['defaults'].itervalues():
                if not isinstance(val, (int, float)):
                    raise TypeError, "All values in 'defaults' must be scalars."
        
        return cppdict['cppexpr'], False, cppdict.get('defaults', None)
    

## Create new class inheriting from both FFC and DOLFIN FacetNormal
## (FFC FacetNormal is a function that returns a FFC Function object)
#class FacetNormal(ffc.Function, dolfin.cpp_FacetNormal):
#
#    def __init__(self, shape, mesh):
#        "Create FacetNormal"
#
#        element = ffc.VectorElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_FacetNormal.__init__(self, mesh)
#
## Create new class inheriting from FFC MeshSize and DOLFIN MeshSize
## (FFC MeshSize is a function that returns a FFC Function object)#class MeshSize(ffc.Function, dolfin.cpp_MeshSize):
#
#    def __init__(self, shape, mesh):
#        "Create MeshSize"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_MeshSize.__init__(self, mesh)
#
## Create new class inheriting from FFC MeshSize and DOLFIN AvgMeshSize
## (FFC MeshSize is a function that returns a FFC Function object)
#class AvgMeshSize(ffc.Function, dolfin.cpp_AvgMeshSize):
#
#    def __init__(self, shape, mesh):
#        "Create AvgMeshSize"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_AvgMeshSize.__init__(self, mesh)
#
## Create new class inheriting from FFC FacetArea and DOLFIN FacetArea
## (FFC FacetArea is a function that returns a FFC Function object)
#class FacetArea(ffc.Function, dolfin.cpp_FacetArea):
#
#    def __init__(self, shape, mesh):
#        "Create FacetArea"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_FacetArea.__init__(self, mesh)
#
## Create new class inheriting from FFC InvFacetArea and DOLFIN InvFacetArea
## (FFC InvFacetArea is a function that returns a FFC Function object)
#class InvFacetArea(ffc.Function, dolfin.cpp_InvFacetArea):
#
#    def __init__(self, shape, mesh):
#        "Create InvFacetArea"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_InvFacetArea.__init__(self, mesh)
