"""This module handles the Function class in Python.

The Function class needs special handling and is not mapped directly
by SWIG from C++ interface. Instead, a new Function class is created
which inherits both from the DOLFIN C++ Function (which is renamed to
cpp_Function in dolfin_function_pre.i) and the form compiler Function.

The resulting Function class may thus act both as a variable in a form
expression and as a Function on a mesh that may be evaluated, plotted
and stored to file.

Similarly, this module redefines the special functions defined in
SpecialFunctions.h, such as MeshSize and FacetNormal.

Note that the Function class currently inherits explicitly from the FFC
Function class. In future versions, it will instead inherit from the UFL
Function class, so that DOLFIN may be form compiler agnostic."""

__author__ = "Anders Logg (logg@simula.no)"
__date__ = "2007-08-15 -- 2008-11-03"
__copyright__ = "Copyright (C) 2007-2008 Anders Logg"
__license__  = "GNU LGPL Version 2.1"

__all__ = ["FunctionSpace","Function"]#, "FacetNormal", "MeshSize", "AvgMeshSize", "FacetArea", "InvFacetArea"]

import types
import ffc
import dolfin
import sys

dim_to_string = {1: "interval", 2: "triangle", 3: "tetrahedron"}

class FunctionSpace(dolfin.cpp_FunctionSpace,ffc.FiniteElement):
    """ FunctionSpace represents a finite element function space
  
    A FunctionSpace is defined by a mesh, a finite element, and a
    local-to-global mapping of the degrees of freedom (dofmap).
    """
    def __init__(self, mesh, family, degree):
        """ Create FunctionSpace
        
        mesh   : An instance of a DOLFIN Mesh
        family : "Lagrange", "Hermite", ...
        degree : 0, 1, 2, ...
        """
        assert(isinstance(family, str), "Invalid family type.")
        assert(isinstance(mesh, dolfin.Mesh), "Invalid mesh type.")
        assert(isinstance(degree, int), "Invalid degree type.")
        
        # Initialize the ffc.FiniteElement
        ffc.FiniteElement.__init__(self,family,
                                   dim_to_string[mesh.geometry().dim()],
                                   degree)
        
        # jit compile the ufc_element and ufc_dofmap
        ufc_element, ufc_dofmap = ffc.jit(self)
        
        # Initialize the cpp_FuncitonSpace
        dolfin.cpp_FunctionSpace.__init__(self, mesh,
                                          dolfin.FiniteElement(ufc_element),
                                          dolfin.DofMap(ufc_dofmap,mesh))

    def __str__(self):
        return "%s finite element function space of degree %d"%(self.family(),self.degree())

    def __repr__(self):
        return "FunctionSpace(mesh,'%s',%d)"%(self.family(),self.degree())

class FunctionCreator(type):
    """ Metaclass for Function

    This class allow for dynamic creation of Function classes.
    Dependent on the provided attributes in the class the created
    Function class will inherit either a cpp_Function which is a
    dolfin::Function or a user defined function that inherits
    dolfin::Function.
    
    """
    def __new__(cls, name, bases, dictionary):
        """ Return a new class object

        cls        : The class that is created
        name       : Then name of the class
        bases      : The bases classes of the class
        dictionary : Any attributes of the class
        """
        #print "class name:",name
        #print "Bases on entry:", bases
        #print "Dictionary on entry:",dictionary

        # If we are creating the Function class exit without doing anything
        if name == "Function":
            return type.__new__(cls, name, bases, dictionary)
        
        # Default cpp_BaseFunction class
        cpp_BaseFunction = dolfin.cpp_Function
        
        # Check the cppcode and eval attribute
        if 'cppcode' in dictionary and 'eval' in dictionary:
            raise TypeError, "Cannot create class with both 'eval' and " + \
                  "'cppcode' attributes"
        if not ('cppcode' in dictionary or 'eval' in dictionary):
            raise TypeError, "The class must define either the 'cppcode' " + \
                  "attribute or the 'eval' function"
        
        # If cppcode is provided send it to compile_function
        # FIXME: Make this work
        if 'cppcode' in dictionary:
            print "Calling instant to compile code and return class"
            cpp_BaseFunction = dolfin.compile_function(dictionary['cppcode'])
            # Remove the cppcode attribute
            dictionary.pop('cppcode')
        
        # If the Function class is a user defined python class
        else:
            # check type of eval
            if not isinstance(dictionary['eval'],types.FunctionType):
                raise TypeError, "'eval' must be a 'function'"
        
            # Check if dim and rank are attributes
            if not ('dim' in dictionary and 'rank' in dictionary):
                raise TypeError, "The class '%s' must implement both 'dim' and 'rank'"%name
            
            # Check the type of the dim and rank attributes
            if not isinstance(dictionary['dim'],types.FunctionType):
                raise "The attribute 'dim' must be a 'function'"
            
            # Check the type of the rank attribute
            if not isinstance(dictionary['rank'],types.FunctionType):
                raise "The attribute 'rank' must be a 'function'"
        
        # Extend the bases with the cpp_BaseFunction and ffc.Function
        bases = (Function,cpp_BaseFunction,ffc.Function)

        # Defining the init function
        
        # If a user defined __init__ function is provided store it and call it
        # inside the created __init__ function.
        if '__init__' in dictionary:
            userdefined_init = dictionary['__init__']
            def __init__(self,V,*arg,**kwarg):
                #print "Initializing %s"%name

                if not isinstance(V,FunctionSpace):
                    raise TypeError, "The argument must be a 'FunctionSpace'"
                
                # Calling the user defined_init
                userdefined_init(self,V,*arg,**kwarg)
                
                self._V = V
                cpp_BaseFunction.__init__(self,V)
                ffc.Function.__init__(self,V)
                
        else:
            def __init__(self,V):
                #print "Initializing %s"%name
                if not isinstance(V,FunctionSpace):
                    raise TypeError, "The argument must be a 'FunctionSpace'"
                self._V = V
                cpp_BaseFunction.__init__(self,V)
                ffc.Function.__init__(self,V)
        
        # Attach the init function to the dictionary
        dictionary['__init__'] = __init__

        #print "Bases on leaving:", bases
        #print "Dictionary on leaving:",dictionary
        return type.__new__(cls, name, bases, dictionary)

class Function(object):
    __metaclass__ = FunctionCreator
    def __init__(self,V):
        if type(self) == Function:
            raise TypeError, "Can only instantiate subclasses of 'Function'"
        raise RuntimeError, "Do not initialize the 'Function' base class"
    
    def function_space(self):
        " Return the function space" 
        return self._V

    def __str__(self):
        return "Function in %s"%str(self._V)

    def __repr__(self):
        return "%s(%s)"%(type(self).__name__,repr(self._V))

# Create new class inheriting from both FFC and DOLFIN Function
#class Function(ffc.Function, dolfin.cpp_Function):
#    
#    def __init__(self, element, *others):
#        "Create Function"
#
#        # Special case, Function(element, mesh, x), need to create simple form to get arguments
#        if isinstance(element, (ffc.FiniteElement, ffc.MixedElement)) and \
#                len(others) == 2 and \
#                isinstance(others[0], dolfin.Mesh) and \
#                isinstance(others[1], (dolfin.Vector, dolfin.GenericVector)):
#            mesh = others[0]
#            # Create simplest possible form
#            if element.value_dimension(0) > 1:
#                form = ffc.TestFunction(element)[0]*ffc.dx
#            else:
#                form = ffc.TestFunction(element)*ffc.dx
#            # Compile form and create dof map
#            (compiled_form, module, form_data) = jit(form)
#            self.dof_maps = dolfin.DofMapSet(compiled_form, mesh)
#            # Initialize FFC and DOLFIN Function
#            ffc.Function.__init__(self, element)
#            dolfin.cpp_Function.__init__(self, mesh, self.dof_maps.sub(0), compiled_form, 0)
#        # If we have an element, then give element to FFC and the rest to DOLFIN
#        elif isinstance(element, (ffc.FiniteElement, ffc.MixedElement)):
#            ffc.Function.__init__(self, element)
#            dolfin.cpp_Function.__init__(self, *others)
#        # Otherwise give all to DOLFIN
#        else:
#            dolfin.cpp_Function.__init__(self, *((element,) + others))
#
#    def split(self):
#        "Extract subfunctions"
#        return tuple([Function(self.e0.sub_element(i), self.sub(i)) for i in range(self.numSubFunctions())])
#
## Create new class inheriting from both FFC and DOLFIN FacetNormal
## (FFC FacetNormal is a function that returns a FFC Function object)
#class FacetNormal(ffc.Function, dolfin.cpp_FacetNormal):
#
#    def __init__(self, shape, mesh):
#        "Create FacetNormal"
#
#        element = ffc.VectorElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_FacetNormal.__init__(self, mesh)
#
## Create new class inheriting from FFC MeshSize and DOLFIN MeshSize
## (FFC MeshSize is a function that returns a FFC Function object)
#class MeshSize(ffc.Function, dolfin.cpp_MeshSize):
#
#    def __init__(self, shape, mesh):
#        "Create MeshSize"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_MeshSize.__init__(self, mesh)
#
## Create new class inheriting from FFC MeshSize and DOLFIN AvgMeshSize
## (FFC MeshSize is a function that returns a FFC Function object)
#class AvgMeshSize(ffc.Function, dolfin.cpp_AvgMeshSize):
#
#    def __init__(self, shape, mesh):
#        "Create AvgMeshSize"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_AvgMeshSize.__init__(self, mesh)
#
## Create new class inheriting from FFC FacetArea and DOLFIN FacetArea
## (FFC FacetArea is a function that returns a FFC Function object)
#class FacetArea(ffc.Function, dolfin.cpp_FacetArea):
#
#    def __init__(self, shape, mesh):
#        "Create FacetArea"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_FacetArea.__init__(self, mesh)
#
## Create new class inheriting from FFC InvFacetArea and DOLFIN InvFacetArea
## (FFC InvFacetArea is a function that returns a FFC Function object)
#class InvFacetArea(ffc.Function, dolfin.cpp_InvFacetArea):
#
#    def __init__(self, shape, mesh):
#        "Create InvFacetArea"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_InvFacetArea.__init__(self, mesh)
