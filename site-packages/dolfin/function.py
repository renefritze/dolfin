"""This module handles the Function class in Python.

The Function class needs special handling and is not mapped directly
by SWIG from C++ interface. Instead, a new Function class is created
which inherits both from the DOLFIN C++ Function (which is renamed to
cpp_Function in dolfin_function_pre.i) and the form compiler Function.

The resulting Function class may thus act both as a variable in a form
expression and as a Function on a mesh that may be evaluated, plotted
and stored to file.

Similarly, this module redefines the special functions defined in
SpecialFunctions.h, such as MeshSize and FacetNormal.

Note that the Function class currently inherits explicitly from the FFC
Function class. In future versions, it will instead inherit from the UFL
Function class, so that DOLFIN may be form compiler agnostic."""

__author__ = "Johan Hake (hake@simula.no)"
__date__ = "2008-11-03 -- 2008-11-19"
__copyright__ = "Copyright (C) 2008 Johan Hake"
__license__  = "GNU LGPL Version 2.1"

__all__ = ["FunctionSpace","Function","TestFunction","TrialFunction","BasisFunction"]#, "FacetNormal", "MeshSize", "AvgMeshSize", "FacetArea", "InvFacetArea"]

import types
import ffc
import dolfin
import sys
import copy

from compile_function import *

# Define class functions that will be set during class creation
def Function_function_space(self):
    " Return the function space" 
    return self._V

def Function__str__(self):
    return "Function in %s"%str(self._V)

# Define some help functions
def _init_function(cpp_BaseFunction, userdefined_init = None):
    " Help function that return an __init__ function"
    
    if userdefined_init is None:
        def __init__(self, V):
            if not isinstance(V,FunctionSpace):
                raise TypeError, "The argument must be a 'FunctionSpace'"
            self._V = V
            cpp_BaseFunction.__init__(self,V)
            ffc.Function.__init__(self,V.ffc_element())
    else:
        def __init__(self,V,*arg,**kwargs):
            if not isinstance(V,FunctionSpace):
                raise TypeError, "The argument must be a 'FunctionSpace'"
            self._V = V
            
            # Calling the user defined_init
            userdefined_init(self,V,*arg,**kwargs)
            
            cpp_BaseFunction.__init__(self,V)
            ffc.Function.__init__(self,V.ffc_element())
    
    # Set the doc string of the init function
    if hasattr(userdefined_init,"__doc__"):
        __init__.__doc__ = userdefined_init.__doc__
    else:
        __init__.__doc__ = " Instantiate the Function"
    
    return __init__

def _check_cpp_arguments(cppdict):
    """ A help function to check kwargs before sending them to compile functions.

    It returns an argument list that can be passed to compile_function
    """
    if 'cppcode' in cppdict:
        # Check wrong use of cppexp and defaults
        if 'cppexpr' in cppdict:
            print "*** Warning: Both 'cppexp' and 'cppcode' is defined. Only using 'cppcode'."
        if 'deafult' in cppdict:
            print "*** Warning: 'defaults' is defined but not used."
            
        # Check type of cppcode
        if not isinstance(cppdict['cppcode'],(str)):
            raise TypeError, "Provide a 'str' for 'cppcode'."
        
        return cppdict['cppcode'], True, None
    else:
        if not isinstance(cppdict['cppexpr'],(str,tuple, list)):
            raise TypeError, "Provide a 'str', 'tuple' or 'list' for 'cppexpr'."
        # Check for the defaults attribute
        if 'defaults' in cppdict:
            if not isinstance(cppdict['defaults'],dict):
                raise TypeError, "Provide a 'dict' for 'defaults'."
            
            for val in cppdict['defaults'].itervalues():
                if not isinstance(val,(int,float)):
                    raise TypeError, "All values in 'defaults' must be scalars."
        
        return cppdict['cppexpr'], False, cppdict.get('defaults',None)
    
##################### The Function meta class ##################### 
class FunctionCreator(type):
    """ Metaclass for Function

    This class allow for dynamic creation of Function classes. Dependent
    on the provided attributes in the class the created Function class will
    inherit either a cpp_Function which is a dolfin::Function, a user
    defined c++ function that inherits dolfin::Function or
    dolfin::cpp_DiscreteFunction, which is a function with an initialized
    vector.
    
    """
    def __new__(cls, name, bases, dictionary):
        """ Return a new Function class object
        
        cls        : The class that is created
        name       : Then name of the class
        bases      : The bases classes of the class
        dictionary : Any attributes of the class
        """

        # Default cpp_BaseFunction class
        cpp_BaseFunction = dolfin.cpp_Function
        
        # Check the cppcode and eval attributes
        if ('cppcode' in dictionary or 'cppexpr' in dictionary) \
               and 'eval' in dictionary:
            raise TypeError, "Cannot create class with both 'eval' and " + \
                  "'cppcode' or 'cppexpr' defined"
        
        # If we define the Function class, as done in this module below.
        if name == "Function":
            # Defining a discrete function
            cpp_BaseFunction = dolfin.cpp_DiscreteFunction
            
            # Define a __new__ function to be able to instantiate compile functions
            # directly with the statement:
            # f = Function(V,cppexpr = "exp(x[0])")
            def __new__(cls,  V, **kwargs):
                # If trying to instantiate one to many, compile functions
                if len(kwargs) > 0:
                    if 'cppcode' in dictionary or 'cppexpr' in kwargs:
                        # Check the handed cpp kwargs
                        args = _check_cpp_arguments(kwargs)

                        # Compile module and get the function classes
                        function_classes = compile_function(*args)

                        # Check type of V
                        assert(isinstance(V,(list,tuple,FunctionSpace)),"Provide a single 'FunctionSpace' or a 'list' or a 'tuple' with 'FunctionSpaces'")
                        if isinstance(V,(list,tuple)):
                            assert(len(V)==len(function_classes),"The number of provided 'FunctionSpaces' must be the same as the number of compiled 'Function classes'")
                        else:
                            V = [V]*len(function_classes)
                        
                        # Create the function classes and instantiate them
                        funcs = []
                        for i, Func in enumerate(function_classes):
                            class Function(ffc.Function,Func):
                                __init__        = _init_function(Func)
                                __str__        = Function__str__
                                function_space = Function_function_space
                            funcs.append(Function(V[i]))
                    else:
                        raise TypeError, "Valid 'kwargs' are 'cppcode' and 'cppexpr' together with 'defaults'"
                    if len(funcs) == 1:
                        return funcs[0]
                    return tuple(funcs)
                
                # Instantiate one of each base class.
                cpp_func = cpp_BaseFunction.__new__(cls,V)
                ffc_func = ffc.Function.__new__(cls,V.ffc_element())

                # Update the dict of cpp_func with the attributes from ffc_func
                cpp_func.__dict__.update(copy.deepcopy(ffc_func.__dict__))
                
                # Return the cpp_func object with the updated __dict__
                return cpp_func
            
            dictionary['__new__'] = __new__
            
        # If the Function class is a user defined python class
        elif 'eval' in dictionary:
            # Check type of eval
            if not isinstance(dictionary['eval'],types.FunctionType):
                raise TypeError, "'eval' must be a 'function'"
        
        # If cppcode or cppexpr is provided send it to compile_function
        elif 'cppcode' in dictionary or 'cppexpr' in dictionary:
            # Check the handed attributes and return an args tuple
            args = _check_cpp_arguments(dictionary)
            
            # Compile the expr and assume only one function class is returned
            cpp_BaseFunction = compile_function(*args)[0]
            
            # Remove any surpluss attributes
            dictionary.pop('cppcode',None)
            dictionary.pop('cppexpr',None)
            dictionary.pop('defaults',None)
            
        else:
            raise TypeError, "Some error..."
        
        # Extend the bases with the cpp_BaseFunction and ffc.Function
        bases = (ffc.Function,cpp_BaseFunction)
        
        # Attach the init function to the dictionary
        dictionary['__init__'] = _init_function(cpp_BaseFunction,\
                                                dictionary.get('__init__',None))

        return type.__new__(cls, name, bases, dictionary)

####################### The User interface ##################### 
class FunctionSpace(dolfin.cpp_FunctionSpace):
    """ FunctionSpace represents a finite element function space
  
    A FunctionSpace is defined by a mesh, a finite element, and a
    local-to-global mapping of the degrees of freedom (dofmap).
    """
    def __init__(self, mesh, element):
        """ Create FunctionSpace
        
        mesh    : An instance of a DOLFIN Mesh
        element : A FiniteElement
        """
        assert(isinstance(mesh, dolfin.Mesh), "Invalid mesh type.")
        assert(isinstance(element, (ffc.FiniteElement,ffc.MixedElement)), \
               "Invalid element type.")
        
        # jit compile the ufc_element and ufc_dofmap and store the
        # element so python won't garbage collect it.
        self.__ufc_element, self.__ufc_dofmap = ffc.jit(element)
        
        self.__dolfin_element = dolfin.FiniteElement(self.__ufc_element)
        self.__dolfin_dofmap  = dolfin.DofMap(self.__ufc_dofmap,mesh)
        
        # Initialize the cpp_FunctionSpace
        dolfin.cpp_FunctionSpace.__init__(self, mesh,self.__dolfin_element,
                                          self.__dolfin_dofmap)
        
        self._ffc_element = element
        
    def ffc_element(self):
        " Return the form compiler element"
        return self._ffc_element
    
    def __str__(self):
        return "%s function space"%(self._ffc_element.__class__.__name__,)

class Function(object):
    """ A coefficient Function class
    
    Function is a versatile class that defines Functions that can be used
    as coefficient functions in forms.

    A Function or any baseclasses of Function, is always instanstiated with
    a FunctionSpace, V. 

    The class can be used to instantiate a function directly. This can
    either be a discrete function, see 1 below, or a user defined jit-
    compiled function(s), see 2, 3 and 4 below.

    By subclassing Function the user can create user defined function classes.
    These classes can either be pure python functions, which will be slow to
    use in assemble, see 5 below or jit-compiled functions, see 2, 3, 4 and 6
    below.

    1) Discrete function
    -------------------------------------------------------------------------
    
    >>> u = Function(V)
    >>> vec = u.vector() # The coeffisients
    
    2a) User defined jit-compiled functions
    -------------------------------------------------------------------------

    >>> fs = Function(Vs,cppexpr = 'sin(x[0]) + cos(x[1]')
    >>> fv = Function(Vv,cppexpr = ('cos(x[0])','sin(x[1]'))
    
    Here f1 is a scalar function and f2 is vector valued. The corresponding
    function spaces need to be of the same rank. 
    
    Tensor function with rank 2 can also be created:
    
    >>> ft = Function(Vv,cppexpr = (('exp(x[0])','sin(x[1]'),
                                    ('sin(x[0])','tan(x[1]')))

    In general will a single string expression be interpreted as a scalar,
    a tuple of strings as a tensor of rank 1 and a tuple of tuples ot strings
    as a tensor of rank 2.
    
    In the string expressions will, x[0], x[1] and x[2] carries the information
    of the coordinates the function is evaluated in. All math functions defined
    in <cmath> is available for the user.

    Function parameter can be included as:
    
    >>> fs = Function(Vs,cppexpr = 'A*sin(x[0]) + B*cos(x[1]')
    >>> fs.A = 2.0
    >>> fs.B = 4.0

    The parameters can only be scalars, and are all initialized to 0.0. The
    parameters can also be given default values, using the kwarg 'defaults'.
    
    >>> fs = Function(Vs,cppexpr = 'A*sin(x[0]) + B*cos(x[1]',
                         defaults={'A':2.0,'B':4.0})

    3) Complex user defined jit-compiled functions
    -------------------------------------------------------------------------

    The user can define a function using more complicated logic with the kwarg
    'cppcode'. This argument should be a string of c++ code that implements a
    class that inherits from dolfin::Function.
    
    >>> code = '''
              class MyFunc : public Function
                {
                  MeshFunction<uint> *mf;
                  MyFunc(FunctionSpace & V) : Function(V), mf(0) {}
                  void eval(double* val, const Data& data) {
                    dolfin_assert(mf);
                    switch ( (*mf)(data.cell())){
                    case 0: val[0] = exp(-data.x[0]); break;
                    case 1: val[0] = exp(-data.x[2]); break;
                    defalt: val[0] = 0.0;
                    }
                  }
                };
                '''
    >>> mf = MeshFunction('uint',V.mesh(),2)
    >>> fs = Function(Vs,cppcode = code)
    >>> fs.mf = mf
    
    4) User defined jit-compiled functions using batch processing
    -------------------------------------------------------------------------
    
    By handing a list of the functions expressions to 'cppexpr', the user can
    compile several function at a time. These can either be instantiated using
    a single function space, which will be used to instantiate all functions.
    A list of function spaces  can also be handed, where each function space
    corresponds to the function expressions in the list handed to 'cppexpr'. 

    >>> fs1, fs2 = Function(Vs,cppexpr = ['sin(x[0]) + cos(x[1]','exp([1])'])
    >>> fs,fv,ft = Function([Vs,Vv,Vt],cppexpr = ['sin(x[0]) + cos(x[1]',
                                                 ('cos(x[0])','sin(x[1]'),
                                                 (('cos(x[0])','sin(x[1]'),
                                                 ('sin(x[0])','cos(x[1]'))])
    
    5) Subclassed as a userdefined python function
    -------------------------------------------------------------------------

    The user can subclass Function and overload the 'eval' function. The subclass
    is then instantiated using a function space.
    
    >>> class MyFunction1(Function):
            def eval(self,value,x):
                dx = x[0] - 0.5
                dy = x[1] - 0.5
                values[0] = 500.0*exp(-(dx*dx + dy*dy)/0.02)
    >>> fs = MyFunction1(Vs)
    
    6) Subclassed as a jit-compiled userdefined function
    -------------------------------------------------------------------------

    The user can subclass Function and define the same attributes as described
    above for jit-compiled functions: 'cppexpr', 'defaults' and 'cppcode'.
    
    >>> class MyFunction2(Function):
            cppexpr = 'A*exp(-(pow(x[0]-0.5,2) + pow(x[1]-0.5,2))/B)'
            defaults = {"A":500.0,"B":0.02}
    >>> fv = MyFunction2(Vv)
    >>> class MyFunction3(Function):
            cppcode = code # See above for an example code.
    
    >>> fs = MyFunction3(V)
    >>> fs.mf = mf

    """
    # Set the meta class
    __metaclass__  = FunctionCreator

    # Set function attributes
    function_space = Function_function_space
    __str__        = Function__str__

# Help functions for defining the interface of {Basis,Trial,Test}Function
def BasisFunction__str__(self):
    return "%s in %s"%(type(self).__name__,str(self._V))

def BasisFunction__init__(Base):
    def __init__(self,V):
        if not isinstance(V,FunctionSpace):
            raise TypeError, "Provide a 'FunctionSpace'."
        Base.__init__(self,V.ffc_element())
        # We need to attach the FunctionSpace after calling
        # Base.__init__()
        self.data = V
    
    return __init__

# Subclassing of ffc.{Basis,Trial,Test}Function
class BasisFunction(ffc.BasisFunction):
    __init__ = BasisFunction__init__(ffc.BasisFunction)

class TrialFunction(ffc.TrialFunction):
    __init__ = BasisFunction__init__(ffc.TrialFunction)

class TestFunction(ffc.TestFunction):
    __init__ = BasisFunction__init__(ffc.TestFunction)

## Create new class inheriting from both FFC and DOLFIN FacetNormal
## (FFC FacetNormal is a function that returns a FFC Function object)
#class FacetNormal(ffc.Function, dolfin.cpp_FacetNormal):
#
#    def __init__(self, shape, mesh):
#        "Create FacetNormal"
#
#        element = ffc.VectorElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_FacetNormal.__init__(self, mesh)
#
## Create new class inheriting from FFC MeshSize and DOLFIN MeshSize
## (FFC MeshSize is a function that returns a FFC Function object)
#class MeshSize(ffc.Function, dolfin.cpp_MeshSize):
#
#    def __init__(self, shape, mesh):
#        "Create MeshSize"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_MeshSize.__init__(self, mesh)
#
## Create new class inheriting from FFC MeshSize and DOLFIN AvgMeshSize
## (FFC MeshSize is a function that returns a FFC Function object)
#class AvgMeshSize(ffc.Function, dolfin.cpp_AvgMeshSize):
#
#    def __init__(self, shape, mesh):
#        "Create AvgMeshSize"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_AvgMeshSize.__init__(self, mesh)
#
## Create new class inheriting from FFC FacetArea and DOLFIN FacetArea
## (FFC FacetArea is a function that returns a FFC Function object)
#class FacetArea(ffc.Function, dolfin.cpp_FacetArea):
#
#    def __init__(self, shape, mesh):
#        "Create FacetArea"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_FacetArea.__init__(self, mesh)
#
## Create new class inheriting from FFC InvFacetArea and DOLFIN InvFacetArea
## (FFC InvFacetArea is a function that returns a FFC Function object)
#class InvFacetArea(ffc.Function, dolfin.cpp_InvFacetArea):
#
#    def __init__(self, shape, mesh):
#        "Create InvFacetArea"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_InvFacetArea.__init__(self, mesh)
