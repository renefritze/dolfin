"""This module handles the Function class in Python.

The Function class needs special handling and is not mapped directly
by SWIG from the C++ interface. Instead, a new Function class is
created which inherits both from the DOLFIN C++ Function class (which
is renamed to cpp_Function in dolfin_function_pre.i) and the form
compiler Function class.

The resulting Function class may thus act both as a variable in a form
expression and as a Function on a mesh that may be evaluated, plotted
and stored to file.

This module make heavy use of creation of Function classes and
instantiation of these dynamically during runtime.

The whole logic behind this somewhat magic behaviour is confined by the:

  1) function __new__ in the Function class
  2) meta class FunctionMetaClass
  3) function compile_function from the module with the same name
  4) function Function_factory

The __new__ function in the Function class take care of the logics
when the class Function is used to create an instance of Function,
see user case 1-4 in the docstring of Function.

The meta class FunctionMetaClass take care of the logic when a user
subclass Function to create a userdefined Function, see user case 4
and 5 in the docstring of Function.

The function compile_function is a Jit compiler. It compiles and returns
different kinds of cpp.Function classes, depending on the arguments. These
classes is sent to the Function_factory.

The Function_factory is called when the different dynamically created
Function classes actually are created. It takes a name, and a compiled
cpp.Function and returns a dolfin.Function class. This class inherits
ufl.Function, cpp.Function and dolfin.Function.
"""

__author__ = "Johan Hake (hake@simula.no)"
__date__ = "2008-11-03 -- 2009-08-11"
__copyright__ = "Copyright (C) 2008 Johan Hake"
__license__  = "GNU LGPL Version 2.1"

# Modified by Anders Logg, 2008.

__all__ = ["Function", "Functions", "TestFunction", "TrialFunction", "TestFunctions", "TrialFunctions"]
# FIXME: Make all error messages uniform according to the following template:
#
# if not isinstance(foo, Foo):
#     raise TypeError, "Illegal argument for creation of Bar, not a Foo: " + str(foo)

import types
import sys

# Import UFL and SWIG-generated extension module (DOLFIN C++)
import ufl
import cpp

from compile_function import compile_function
from functionspace import *

def Function_factory(name,
                     cpp_base,
                     user_bases=None,
                     user_eval=None,
                     user_eval_data=None,
                     user_init=None,
                     user_dict=None,
                     from_subfunc=False):
    """ Return a Function class

    This function is used to create all the dynamically created Function
    classes. It takes a name, and a compiled cpp.Function and returns
    a dolfin.Function class. In addition to cpp.Function and dolfin.Function
    it also inherits from ufl.Function.

    @param name           : The name of the class
    @param cpp_base       : The cpp.Function base class which the created
                            Function class shall inherit.
    @param user_bases     : Optional user defined bases
    @param user_eval      : Optional user specified eval function
    @param user_eval_data : Optional user specified eval_data function
    @param user_init      : Optional user specified __init__ function
    @param user_dict      : Optional user specified function or attributes
    @param from_subfunc   : If true, create a Function taking a SubFunction in __init__
    """

    #--- Define class functions that will be set during class creation ---

    def Function_function_space(self):
        " Return the function space."
        return self._V

    def Function__str__(self):
        return "<Function in %s>" % str(self._V)

    def Function__repr__(self):
        return ufl.Function.__repr__(self)

    def Function_sub(self,i):
        """ Return a sub function

        A sub function can be extracted from a discrete function that is in a
        a MixedFunctionSpace or in a VectorFunctionSpace. The sub function is a
        function that resides in a sub space of the mixed space.

        The sub functions are numbered from i = 0..N-1, where N is the total number
        of sub spaces.

        @param i : The number of the sub function
        """
        if not isinstance(self._V, MixedFunctionSpace):
            raise RuntimeError, "No subfunctions to extract"
        if not i < len(self._V.spaces):
            raise RuntimeError, "Can only extract subfunctions with i = 0..%d"%len(self._V.spaces)

        # Create and instantiate the Function
        return Function_factory("DiscreteSubFunction", cpp.DiscreteFunction, \
                                from_subfunc = True)(self._V.spaces[i], subfunc=self._sub(i))

    def Function_split(self):
        " Extract any sub functions"
        if not isinstance(self._V, MixedFunctionSpace):
            raise RuntimeError, "No subfunctions to extract"
        return tuple(self.sub(i) for i in range(len(self._V.spaces)))

    #--- Define helper functions that returns class functions ---

    def construct__init__(cpp_base, user_init=None,
                          from_subfunc=False):
        " Help function that return an __init__ function"

        # If not an user defined init function is provided
        if user_init is None:
            # Define a dummy user_init
            def user_init(self, V, *arg, **kwargs):pass

        if from_subfunc:
            def __init__(self, V, *args, **kwargs):
                # Check if the Function already is initialized
                assert("subfunc" in kwargs)
                # Check type of FunctionSpace
                if not isinstance(V, FunctionSpaceBase):
                    raise TypeError, "The argument must be a 'FunctionSpace'"

                # Initialize base classes
                ufl.Function.__init__(self,V.element())
                cpp_base.__init__(self,kwargs["subfunc"])

                self._V = V


        else:
            def __init__(self, V, *arg, **kwargs):
                # Check type of FunctionSpace
                if not isinstance(V, FunctionSpaceBase):
                    raise TypeError, "The argument must be a 'FunctionSpace'"
                # Initialize base classes
                ufl.Function.__init__(self, V.element())

                # First check if the user want to initialize a DiscreteFunction using
                # vector that is stored to file
                if (cpp_base == cpp.DiscreteFunction) and \
                       (len(arg) > 0) and isinstance(arg[0],str) and \
                       ("xml" in arg[0] or "xml.gz" in arg[0]):

                    cpp_base.__init__(self, V, arg[0])
                else:
                    cpp_base.__init__(self, V)

                self._V = V

                # Calling the user defined_init
                user_init(self, V, *arg, **kwargs)

        # Set the doc string of the init function
        if hasattr(user_init, "__doc__"):
            __init__.__doc__ = user_init.__doc__
        else:
            __init__.__doc__ = """ Initialize the Function

            @param V : FunctionSpace
            """

        return __init__

    # Check the name
    assert(isinstance(name,str))
    assert(name != "Function"), "Cannot create a sub class of Function with the same name as Function"

    # Define the bases
    user_bases = user_bases or []
    bases = tuple([ufl.Function, cpp_base, Function] + user_bases)

    # Define the dictionary of the class
    dict_ = user_dict or {}

    # NOTE: Do not prevent the user to overload attributes "reserved" by PyDOLFIN

    ## Collect reserved attributes from both cpp.Function and ufl.Function
    #reserved_attr = dir(ufl.Function)
    #reserved_attr.extend(dir(cpp.Function))
    #
    ## Remove attributes that will be set by python
    #for attr in ["__module__"]:
    #    while attr in reserved_attr:
    #        reserved_attr.remove(attr)
    #
    ## Check the dict_ for reserved attributes
    #for attr in reserved_attr:
    #    if attr in dict_:
    #        raise TypeError, "The Function attribute '%s' is reserved by PyDOLFIN."%attr

    # Fill the dict_ with constructed functions
    dict_["function_space"] = Function_function_space
    dict_["split"]          = Function_split
    dict_["sub"]            = Function_sub
    dict_["__str__"]        = Function__str__
    dict_["__repr__"]       = Function__repr__
    dict_["__init__"]       = construct__init__(cpp_base, user_init,\
                                                from_subfunc)

    # If a user defined eval function is provided
    if not user_eval is None:
        # Check type of user_eval
        if not isinstance(user_eval, types.FunctionType):
            raise TypeError, "'eval' attribute must be a 'function'"
        if not user_eval.func_code.co_argcount == 3:
            raise TypeError, "The overloaded 'eval' function must use three arguments"
        dict_["eval"] = user_eval

    # If a user defined eval function is provided
    if not user_eval_data is None:
        # Check type of user_eval
        if not isinstance(user_eval_data, types.FunctionType):
            raise TypeError, "'eval_data' attribute must be a 'function'"
        if not user_eval_data.func_code.co_argcount == 3:
            raise TypeError, "The overloaded 'eval_data' function must use three arguments"
        dict_["eval_data"] = user_eval_data

    # Create the class and return it
    return type(name, bases, dict_)

class FunctionMetaClass(type):
    def __new__(cls, name, bases, dict_):
        """ Return a new Function class """
        assert(isinstance(name, str)), "Expecting a 'str'"
        assert(isinstance(bases, tuple)), "Expecting a 'tuple'"
        assert(isinstance(dict_, dict)), "Expecting a 'dict'"

        # First check if we are creating the Function class
        if name == "Function":
            # Assert that the class is _not_ a subclass of Function,
            # i.e., a user have tried to:
            #
            #    class Function(Function):
            #        ...
            if len(bases) > 1 and bases[0] != object:
                raise TypeError, "Cannot name a subclass of Function: 'Function'"

            # Return the new class, which just is the original Function defined in
            # this module
            return type.__new__(cls, name, bases, dict_)

        # If subclassing Function through the Function_factory function above
        if len(bases) >= 3 and bases[0] == ufl.Function and \
               issubclass(bases[1], cpp.Function) and bases[2] == Function:
            # Return the instantiated class
            return type.__new__(cls, name, bases,dict_)

        # Handle any user provided base classes
        user_bases = list(bases)
        user_bases.remove(Function)

        # Check the cppcode and eval attributes
        if 'cpparg' in dict_  and ('eval' in dict_ or 'eval_data' in dict_) :
            raise TypeError, "Cannot create class with both 'eval'/'eval_data' and 'cpparg' attributes defined."

        # If the Function class is a user defined python class, case 4. from docstring
        if 'eval' in dict_:
            user_init = dict_.pop("__init__", None)
            user_eval = dict_.pop("eval")
            return Function_factory(name, cpp.Function, user_bases, user_eval, None, user_init, dict_)

        # If the Function class is a user defined python class, case 4. from docstring
        if 'eval_data' in dict_:
            user_init = dict_.pop("__init__", None)
            user_eval_data = dict_.pop("eval_data")
            return Function_factory(name, cpp.Function, user_bases, None, user_eval_data, user_init, dict_)

        # If cpparg is provided, case 5. from docstring
        if 'cpparg' in dict_:

            # Check the handed attributes and return an args tuple
            cpparg   = dict_.pop('cpparg')
            defaults = dict_.pop("defaults",None)

            # Check that the user has not provide any other attributes
            # than the allowed ones.
            if len(dict_) > 1:
                dict_.pop('__module__',None)
                raise TypeError, "Not allowed to provide user defined attributes to a sub class of Function when the compiled function interface is used. Found: %s"%\
                      (", ".join(["'%s'"%key for key in dict_.iterkeys()]))

            _check_cpp_arguments(cpparg, defaults)

            # Compile the cppargs
            cpp_base = compile_function([cpparg], [defaults])[0]

            # Create the Function class and return it
            return Function_factory(name, cpp_base, user_bases)

        # If we have reached this stage raise error
        raise TypeError, "Error in subclassing Function. For correct usage see 4. and 5. in Function docstring."

#--- The user interface ---

class Function(object):
    """Function represents a function in a finite element function space.

    Function is a versatile class that can be used either for coefficients
    in forms or for solutions of partial differential equations.

    A Function must always be instantiated with a FunctionSpace V, or a
    filename but takes a variable number of additional arguments depending
    on the situation, leading to different representations of the Function.

    These options are described below.

    Arguments
    ---------
    V : Function Space argument
    cpparg : Optional C++ argument, see below
    defaults: Optional C++ argument, see below

    0. Initialized from a stored Vector
    -----------------------------------

    If the unknown of a discrete function previously has been stored in a '.xml'
    or a 'xml.gz' file it can be retreived by:

    >>> f = Function(V, 'myvec.xml')

    or

    >>> f = Function(V, 'myvec.xml.gz')

    1. Discrete function
    --------------------

    If only a FunctionSpace V is given to the constructor, the Function
    will be represented as a finite element function in the FunctionSpace
    V defined by a Vector of degrees of freedom:

    >>> f = Function(V)

    One may access the Vector of degrees of freedom as follows:

    >>> x = f.vector()

    2. Simple user-defined JIT-compiled functions
    ---------------------------------------------

    One may alternatively specify a C++ code for evaluation of the Function
    as follows:

    >>> f0 = Function(V0, 'sin(x[0]) + cos(x[1])')
    >>> f1 = Function(V1, ('cos(x[0])', 'sin(x[1]'))

    Here, f0 is is scalar and f1 is vector-valued. The corresponding
    FunctionSpaces need to be of matching rank.

    Tensor functions of rank 2 (matrices) may also be created:

    >>> f2 = Function(V2, (('exp(x[0])','sin(x[1])'),
                          ('sin(x[0])','tan(x[1])')))

    In general, a single string expression will be interpreted as a
    scalar, a tuple of strings as a tensor of rank 1 (a vector) and a
    tuple of tuples of strings as a tensor of rank 2 (a matrix).

    The expressions may depend on x[0], x[1], and x[2] which carry
    information about the coordinates where the function is
    evaluated. All math functions defined in <cmath> are available to
    the user.

    Function parameters can be included as follows:

    >>> f = Function(V, 'A*sin(x[0]) + B*cos(x[1])')
    >>> f.A = 2.0
    >>> f.B = 4.0

    The parameters can only be scalars, and are all initialized to 0.0. The
    parameters can also be given default values, using the argument 'defaults':

    >>> f = Function(V, 'A*sin(x[0]) + B*cos(x[1])',
                        {'A': 2.0,'B': 4.0})

    3. Complex user-defined JIT-compiled functions
    ----------------------------------------------

    One may also define a Function using more complicated logic with
    the 'cpparg'. This argument should be a string of C++
    code that implements a class that inherits from dolfin::Function.

    The following code illustrates how to define a Function that depends
    on material properties of the cells in a Mesh. A MeshFunction is
    used to mark cells with different properties.

    Note the use of the 'data' parameter.

    >>> code = '''
    class MyFunc : public Function
    {
    public:

      MeshFunction<uint> *cell_data;

      MyFunc(FunctionSpace& V) : Function(V), cell_data(0) {}

      void eval(double* values, const Data& data) const
      {
        assert(cell_data);
        switch ((*cell_data)(data.cell()))
        {
        case 0:
          values[0] = exp(-data.x[0]);
          break;
        case 1:
          values[0] = exp(-data.x[2]);
          break;
        default:
          values[0] = 0.0;
        }
      }

    };'''

    >>> cell_data = MeshFunction('uint', V.mesh(), 2)
    >>> f = Function(V, code)
    >>> f.cell_data = cell_data

    4. User-defined functions by subclassing
    ----------------------------------------

    The user can subclass Function and overload the 'eval' function. The subclass
    must then instantiated using a FunctionSpace:

    >>> class MyFunction0(Function):
            def eval(self, value, x):
                dx = x[0] - 0.5
                dy = x[1] - 0.5
                value[0] = 500.0*exp(-(dx*dx + dy*dy)/0.02)
    >>> f0 = MyFunction0(V)

    The user can also subclass Function overloading the eval_data function. By
    this the user get access to the more powerfull Data structure, with e.g., cell,
    facet and normal information, during assemble.

    >>> class MyFunction1(Function):
            def eval_data(self, value, data):
                if data.cell().index() > 10:
                    value[0] = 1.0
                else:
                    value[0] = -1.0

    >>> f1 = MyFunction1(V)

    Note that subclassing may be significantly slower than using JIT-compiled
    functions. This is because a callback from C++ to Python will be involved
    each time a Function needs to be evaluated.

    5. User-defined JIT-compiled functions by subclassing
    -----------------------------------------------------

    The user can also subclass Function and define the same attributes as described
    above for JIT-compiled functions: 'cppexpr', 'defaults' and 'cppcode'.

    >>> class MyFunction0(Function):
            cpparg = 'A*exp(-(pow(x[0]-0.5,2) + pow(x[1]-0.5,2))/B)'
            defaults = {"A": 500.0, "B": 0.02}
    >>> f0 = MyFunction0(V)

    >>> class MyFunction1(Function):
            cpparg = code # See above for an example code.
    >>> f1 = MyFunction1(V)
    >>> f1.cell_data = mf

    This is useful for example when the Function needs to initialize or
    precompute data, that is, when it behaves like a "functor".

    """

    # Set the meta class
    __metaclass__ = FunctionMetaClass

    def __new__(cls, V, cpparg=None, defaults=None, **kwargs):
        """ Instantiate a new Function

        Arguments:
        ----------
        @param V:
          Function Space argument.
        @param cpparg:
          C++ argument.
          Optional.
        @param defaults:
          C++ argument.
          Optional.

        """
        # If the __new__ function is called because we are instantiating a sub class
        # of Function. Instantiate the class directly using objects __new__
        if cls.__name__ != "Function":
            return object.__new__(cls)

        # If the user must pass a FunctionSpace as the first argument
        if not isinstance(V,cpp.FunctionSpace):
            raise TypeError, "The first argument must be a 'cpp.FunctionSpace'"

        # If the user has passed a cpp.FunctionSpace
        if isinstance(V,FunctionSpaceBase):
            only_cpp = False
        else:
            only_cpp = True

        # If loading vector from file
        if isinstance(cpparg,str) and ("xml" in cpparg or "xml.gz" in cpparg):
            if only_cpp:
                return cpp.DiscreteFunction(V,cpparg)
            return object.__new__(Function_factory("FunctionFromFile", cpp.DiscreteFunction))

        # If only the FunctionSpace is provided, return a DiscreteFunction
        # 1. in Function docstring
        if cpparg is None:
            if only_cpp:
                return cpp.DiscreteFunction(V)
            return object.__new__(Function_factory("DiscreteFunction", cpp.DiscreteFunction))

        # The user instantiate a compiled function.
        # 2., or 3. from Function docstring

        # Check the handed cpp kwargs
        _check_cpp_arguments(cpparg,defaults)

        # Compile module and get the cpp.Function class
        cpp_base = compile_function([cpparg],[defaults])[0]

        if only_cpp:
            return cpp_base(V)

        return object.__new__(Function_factory("CompiledFunction", cpp_base))


def Functions(*args,**kwargs):
    """ Batch-processed user-defined JIT-compiled functions
    -------------------------------------------------------

    By specifying several cppargs one may compile more than one function
    at a time. These may either be instantiated using a single function
    space common for all functions, using the optional kwarg 'V', or with
    a separate function space for each cpparg:

    >>> f0, f1 = Functions('sin(x[0]) + cos(x[1])', 'exp(x[1])', V=V0)

    >>> f0, f1, f2 = Functions(V0, 'A*sin(x[0]) + B*cos(x[1])', {'A':2.0,'B':3.0},
                               V1, code,
                               V2, (('cos(x[0])','sin(x[1])'),
                                    ('sin(x[0])','cos(x[1])')))

    Here cppcode is a code snippet, which should be a string of C++
    code that implements a class that inherits from dolfin::Function,
    see user case 3. in Function docstring

    Batch-processing of JIT-compiled functions may significantly speed up
    JIT-compilation at run-time.

"""
    # Check the V kwarg
    only_cpp = None
    common_space = True
    V = kwargs.pop("V",None)
    if len(kwargs) > 1:
        raise TypeError, "Can only define one kwargs and that can only be 'V'."
    if V is None:
        common_space = False
    elif not isinstance(V,cpp.FunctionSpace):
        raise TypeError, "Illegal argument for creation of Function, not a FunctionSpace: " + str(V)
    elif isinstance(V,FunctionSpaceBase):
        only_cpp = False
    else:
        only_cpp = True

    # Check the number of args
    nargs = len(args)
    if (common_space and nargs == 0) or (not common_space and nargs < 2):
        raise TypeError, "To few arguments. Pass at least a FunctionSpace and one cpparg."

    # Iterate over the *args and collect input to compile_function
    spaces = []; cppargs = []; defaults = []; i = 0;
    while i < nargs:
        # If common FunctionSpace
        if common_space:
            spaces.append(V)
        else:
            # If not common FunctionSpace, check that next arg is a FunctionSpace
            if not isinstance(args[i],cpp.FunctionSpace):
                raise TypeError, "Expected a FunctionSpace as argument %d"%i
            # If we got a FunctionSpace, check whether we got a cpp.FunctionSpace or a dolfin.FunctionSpace
            elif isinstance(args[i],FunctionSpaceBase):
                _only_cpp = False
            else:
                _only_cpp = True

            # If only_cpp is not set
            if only_cpp is None:
                only_cpp = _only_cpp
            # If it is already set, check that _only_cpp is the same
            elif _only_cpp != only_cpp:
                raise TypeError, "Pass the same type of FunctionSpace"
            spaces.append(args[i])
            i += 1

        # Check that we are not at the end of the args tuple
        if not i < nargs:
            raise TypeError, "Expected a cpparg as argument %d"%i
        # Check type of cppargs
        if not isinstance(args[i],(tuple,list,str)):
            raise TypeError, "Expected either a 'list', 'tuple' or 'str' for argument %d"%i
        cppargs.append(args[i])
        i += 1

        # If we have more args and the next is a dict
        if i < nargs and isinstance(args[i],dict):
            # Append the dict to defaults
            _check_cpp_arguments(defaults=args[i])
            defaults.append(args[i])
            i += 1
        else:
            # If not append None
            defaults.append(None)

    # Compile the cpp.Functions
    cpp_bases = compile_function(cppargs,defaults)

    # Instantiate the return arguments
    return_functions = []
    for i, cpp_base in enumerate(cpp_bases):
        # If we only wnat the cpp.Function
        if only_cpp:
            return_functions.append(cpp_base(spaces[i]))
        else:
            return_functions.append(Function_factory("CompiledFunction", cpp_base)(spaces[i]))

    # Return the instantiated Functions
    return tuple(return_functions)

#--- Subclassing of ufl.{Basis, Trial, Test}Function ---

class BasisFunction(ufl.BasisFunction):
    """A BasisFunction represents a possibly differentiated component
    of a basis function on the reference cell.

    """
    def __init__(self, V, index=None):
        if not isinstance(V, FunctionSpaceBase):
            raise TypeError, "Illegal argument for creation of BasisFunction, not a FunctionSpace: " + str(V)
        ufl.BasisFunction.__init__(self, V.element(), index)
        self._V = V

    def function_space(self):
        " Return the FunctionSpace"
        return self._V

def TrialFunction(V):
    """A TrialFunction is the BasisFunction with the next lowest primary
    index. We simply pick an index lower than almost all others (-1).
    """
    return BasisFunction(V,-1)

def TestFunction(V):
    """A TestFunction is the BasisFunction with the lowest primary
    index. We simply pick an index lower than all others (-2).
    """
    return BasisFunction(V,-2)

#--- TestFunctions and TrialFunctions ---

def TestFunctions(V):
    "Create test functions from mixed function space."
    return ufl.split(TestFunction(V))

def TrialFunctions(V):
    "Create trial functions from mixed function space."
    return ufl.split(TrialFunction(V))

# --- Help function ---

def _check_cpp_arguments(cpparg=None,defaults=None):
    """A helper function to check cpparg and defaults that are sent to
    compile_function.
    """

    # Check type of cpparg
    if not cpparg is None:
        if not isinstance(cpparg, (str, tuple, list)):
            raise TypeError, "Provide a 'str', 'tuple' or 'list' the 'cpparg' kwarg."

    # If no defaults
    if defaults is None:
        return

    # Check for the defaults attribute
    if not isinstance(defaults, dict):
        raise TypeError, "Provide a 'dict' for the 'defaults' kwarg."

    # Check types of the values in the dict
    for key, val in defaults.iteritems():
        if not isinstance(key,str):
            raise TypeError, "All keys in 'defaults' must be 'str'."
        if not isinstance(val, (int, float)):
            raise TypeError, "All values in 'defaults' must be scalars."

