"""This module handles the Function class in Python.

"""

__author__ = "Johan Hake (hake@simula.no)"
__date__ = "2009-10-06 -- 2009-10-07"
__copyright__ = "Copyright (C) 2009 Johan Hake"
__license__  = "GNU LGPL Version 2.1"

__all__ = ["Function","TestFunction", "TrialFunction", "TestFunctions", "TrialFunctions"]

import types

# Import UFL and SWIG-generated extension module (DOLFIN C++)
import ufl
import cpp

from functionspace import *
from expression import expression__call__

class Function(ufl.Function, cpp.Function):
    """This class represents a function u_h in a finite element
   
    function space V_h, given by
  
      u_h = sum_i U_i phi_i
   
    where {phi_i}_i is a basis for V_h, and U is a vector of
    expansion coefficients for u_h.

    Initialize Function
    -------------------

    Create a Function:

    - from a FunctionSpace
   
      >>> f = Function(V)
   
    - from another Function

      >>> g = Function(f)

    - from a FunctionSpace and a GenericVector

      >>> g = Function(V, v)

    - from a FunctionSpace and a filename containing a GenericVector

      >>> g = Function(V, 'MyVectorValues.xml')"""

    def __init__(self, *args):
        """ Initialize Function"""
        # Check arguments
        if len(args) == 0:
            raise TypeError, "expected 1 or more arguments"

        if not isinstance(args[0], (FunctionSpaceBase, Function)):
            raise TypeError, "expected a FunctionSpace or a Function as argument 1"

        # If using the copy constuctor
        if isinstance(args[0], Function):
            other = args[0]
            # If using the copy constuctor
            if len(args) == 1:
                # Instantiate base classes
                cpp.Function.__init__(self, other)
                ufl.Function.__init__(self, other._V.ufl_element())
                self._V = other._V
                return
            
            # If using sub-function constructor
            elif len(args) == 2 and isinstance(args[1], int):
                i = args[1]
                V = other.function_space()
                if not isinstance(V, MixedFunctionSpace):
                    raise RuntimeError, "No subfunctions to extract"
                if not i < len(V.spaces):
                    raise RuntimeError, "Can only extract subfunctions with i = 0..%d"%len(V.spaces)
                self._V = V.spaces[i]
                cpp.Function.__init__(self, other, i)
                ufl.Function.__init__(self, self._V.ufl_element())
                return
            else:
                raise TypeError, "expected one or two arguments when instantiating from another Function"
    
        # Assign the FunctionSpace
        self._V = args[0]
            
        # Instantiate ufl base class
        ufl.Function.__init__(self, self._V.ufl_element())

        # Passing only the FunctionSpace
        if len(args) == 1:
            # Instantiate cpp base classes
            cpp.Function.__init__(self, self._V)
        elif len(args) == 2:
            # If passing FunctionSpace together with cpp.Function
            # Attached passed FunctionSpace and initialize the cpp.Function
            # using the passed Function
            if isinstance(args[1], cpp.Function):
                if args[1].function_space().dim() != self._V.dim():
                    raise ValueError, "non matching dimensions on passed FunctionSpaces"
                
                cpp.Function.__init__(self,args[1])
            else:
                cpp.Function.__init__(self,*args)
        else:
            raise TypeError, "too many argument"
        
    def function_space(self):
        " Return the function space."
        return self._V

    def _sub(self, i, deepcopy = False):
        """ Return a sub function

        The sub functions are numbered from i = 0..N-1, where N is the total number
        of sub spaces.

        @param i :
             The number of the sub function
        """
        if not isinstance(self._V, MixedFunctionSpace):
            raise RuntimeError, "No subfunctions to extract"
        if not isinstance(i,int):
            raise TypeError, "expects an 'int' as first argument"
        if not i < len(self._V.spaces):
            raise RuntimeError, "Can only extract subfunctions with i = 0..%d"%len(self._V.spaces)

        # Create and instantiate the Function
        if deepcopy:
            return Function(self._V.spaces[i], cpp.Function._sub(self, i))
        else:
            return Function(self,i)

    def split(self, deepcopy = False):
        """ Extract any sub functions

        A sub function can be extracted from a discrete function that is in a
        a MixedFunctionSpace or in a VectorFunctionSpace. The sub function is a
        function that resides in a sub space of the mixed space.

        @param deepcopy :
             Copy sub function vector instead of sharing
        
        """
        if not isinstance(self._V, MixedFunctionSpace):
            raise RuntimeError, "No subfunctions to extract"
        return tuple(self._sub(i,deepcopy) for i in xrange(len(self._V.spaces)))

    def __str__(self):
        # FIXME: We might change this using rank and dimension instead
        return "<Function in %s>" % str(self._V)

    def __repr__(self):
        return ufl.Function.__repr__(self)

expression__call__.__doc__ = """ Evaluate the Function by interpolation

    Example of use:
    1) Using an iterable as x:

    >>> Vs = FunctionSpace(mesh,"CG",1)
    >>> fs = Function(Vs)
    >>> x0 = (1.,0.5,0.5)
    >>> x1 = [1.,0.5,0.5]
    >>> x2 = numpy.array([1.,0.5,0.5])
    >>> v0 = fs(x0)
    >>> v1 = fs(x1)
    >>> v2 = fs(x2)
    
    2) Using multiple scalar args for x, interpreted as a point coordinate 
    >>> v0 = f(1.,0.5,0.5)

    3) Passing return array
    >>> Vv = VectorFunctionSpace(mesh,"CG",1)
    >>> fv = Function(Vv)
    >>> x0 = numpy.array([1.,0.5,0.5])
    >>> v0 = numpy.zeros(3)
    >>> fv(x0, values = v0)

    Note: A longer values array may be passed. In this way one can fast fill up
          an array with different evaluations.
    >>> values = numpy.zeros(9)
    >>> for i in xrange(0,10,3):
            fv(x[i:i+3], values = values[i:i+3])
        
    """

Function.__call__ = types.MethodType(expression__call__, None, Function)

#--- Subclassing of ufl.{Basis, Trial, Test}Function ---

class BasisFunction(ufl.BasisFunction):
    """A BasisFunction represents a possibly differentiated component
    of a basis function on the reference cell.

    """
    def __init__(self, V, index=None):
        if not isinstance(V, FunctionSpaceBase):
            raise TypeError, "Illegal argument for creation of BasisFunction, not a FunctionSpace: " + str(V)
        ufl.BasisFunction.__init__(self, V.ufl_element(), index)
        self._V = V

    def function_space(self):
        " Return the FunctionSpace"
        return self._V

def TrialFunction(V):
    """A TrialFunction is the BasisFunction with the next lowest primary
    index. We simply pick an index lower than almost all others (-1).
    """
    return BasisFunction(V,-1)

def TestFunction(V):
    """A TestFunction is the BasisFunction with the lowest primary
    index. We simply pick an index lower than all others (-2).
    """
    return BasisFunction(V,-2)

#--- TestFunctions and TrialFunctions ---

def TestFunctions(V):
    "Create test functions from mixed function space."
    return ufl.split(TestFunction(V))

def TrialFunctions(V):
    "Create trial functions from mixed function space."
    return ufl.split(TrialFunction(V))

