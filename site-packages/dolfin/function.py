"""This module handles the Function class in Python.

The Function class needs special handling and is not mapped directly
by SWIG from C++ interface. Instead, a new Function class is created
which inherits both from the DOLFIN C++ Function (which is renamed to
cpp_Function in dolfin_function_pre.i) and the form compiler Function.

The resulting Function class may thus act both as a variable in a form
expression and as a Function on a mesh that may be evaluated, plotted
and stored to file.

Similarly, this module redefines the special functions defined in
SpecialFunctions.h, such as MeshSize and FacetNormal.

Note that the Function class currently inherits explicitly from the FFC
Function class. In future versions, it will instead inherit from the UFL
Function class, so that DOLFIN may be form compiler agnostic."""

__author__ = "Johan Hake (hake@simula.no)"
__date__ = "2008-11-03 -- 2008-11-19"
__copyright__ = "Copyright (C) 2008 Johan Hake"
__license__  = "GNU LGPL Version 2.1"

# Modified by Anders Logg, 2008.

__all__ = ["Function", "TestFunction", "TrialFunction", "BasisFunction"]
# FIXME: Add "FacetNormal", "MeshSize", "AvgMeshSize", "FacetArea", "InvFacetArea"

import types
import ffc
import dolfin
import sys
import copy

from compile_function import *
from functionspace import *

# Define class functions that will be set during class creation
def Function_function_space(self):
    " Return the function space" 
    return self._V

def Function__str__(self):
    return "Function in %s"%str(self._V)

# Define some help functions
def _init_function(cpp_BaseFunction, userdefined_init = None):
    " Help function that return an __init__ function"
    
    if userdefined_init is None:
        def __init__(self, V):
            if not isinstance(V, FunctionSpace):
                raise TypeError, "The argument must be a 'FunctionSpace'"
            self._V = V
            cpp_BaseFunction.__init__(self,V)
            ffc.Function.__init__(self, V.element())
    else:
        def __init__(self, V, *arg, **kwargs):
            if not isinstance(V, FunctionSpace):
                raise TypeError, "The argument must be a 'FunctionSpace'"
            self._V = V
            
            # Calling the user defined_init
            userdefined_init(self, V, *arg, **kwargs)
            
            cpp_BaseFunction.__init__(self,V)
            ffc.Function.__init__(self, V.element())
    
    # Set the doc string of the init function
    if hasattr(userdefined_init,"__doc__"):
        __init__.__doc__ = userdefined_init.__doc__
    else:
        __init__.__doc__ = " Instantiate the Function"
    
    return __init__

def _check_cpp_arguments(cppdict):
    """A help function to check kwargs before sending them to compile functions.

    It returns an argument list that can be passed to compile_function
    """
    if 'cppcode' in cppdict:
        # Check wrong use of cppexp and defaults
        if 'cppexpr' in cppdict:
            print "*** Warning: Both 'cppexp' and 'cppcode' is defined. Only using 'cppcode'."
        if 'deafult' in cppdict:
            print "*** Warning: 'defaults' is defined but not used."
            
        # Check type of cppcode
        if not isinstance(cppdict['cppcode'], (str)):
            raise TypeError, "Provide a 'str' for 'cppcode'."
        
        return cppdict['cppcode'], True, None
    else:
        if not isinstance(cppdict['cppexpr'], (str,tuple, list)):
            raise TypeError, "Provide a 'str', 'tuple' or 'list' for 'cppexpr'."
        # Check for the defaults attribute
        if 'defaults' in cppdict:
            if not isinstance(cppdict['defaults'],dict):
                raise TypeError, "Provide a 'dict' for 'defaults'."
            
            for val in cppdict['defaults'].itervalues():
                if not isinstance(val, (int,float)):
                    raise TypeError, "All values in 'defaults' must be scalars."
        
        return cppdict['cppexpr'], False, cppdict.get('defaults',None)
    
##################### The Function meta class ##################### 
class FunctionCreator(type):
    """Metaclass for Function

    This class allow for dynamic creation of Function classes. Dependent
    on the provided attributes in the class the created Function class will
    inherit either a cpp_Function which is a dolfin::Function, a user
    defined c++ function that inherits dolfin::Function or
    dolfin::cpp_DiscreteFunction, which is a function with an initialized
    vector.
    
    """
    def __new__(cls, name, bases, dictionary):
        """ Return a new Function class object
        
        cls        : The class that is created
        name       : Then name of the class
        bases      : The bases classes of the class
        dictionary : Any attributes of the class
        """

        # Default cpp_BaseFunction class
        cpp_BaseFunction = dolfin.cpp_Function
        
        # Check the cppcode and eval attributes
        if ('cppcode' in dictionary or 'cppexpr' in dictionary) \
               and 'eval' in dictionary:
            raise TypeError, "Cannot create class with both 'eval' and " + \
                  "'cppcode' or 'cppexpr' defined"
        
        # If we define the Function class, as done in this module below.
        if name == "Function":
            # Defining a discrete function
            cpp_BaseFunction = dolfin.cpp_DiscreteFunction
            
            # Define a __new__ function to be able to instantiate compile functions
            # directly with the statement:
            # f = Function(V,cppexpr = "exp(x[0])")
            def __new__(cls,  V, **kwargs):
                # If trying to instantiate one to many, compile functions
                if len(kwargs) > 0:
                    if 'cppcode' in dictionary or 'cppexpr' in kwargs:
                        # Check the handed cpp kwargs
                        args = _check_cpp_arguments(kwargs)

                        # Compile module and get the function classes
                        function_classes = compile_function(*args)

                        # Check type of V
                        assert(isinstance(V, (list, tuple, FunctionSpace)), "Provide a single 'FunctionSpace' or a 'list' or a 'tuple' with 'FunctionSpaces'")
                        if isinstance(V, (list, tuple)):
                            assert(len(V)==len(function_classes),"The number of provided 'FunctionSpaces' must be the same as the number of compiled 'Function classes'")
                        else:
                            V = [V]*len(function_classes)
                        
                        # Create the function classes and instantiate them
                        funcs = []
                        for i, Func in enumerate(function_classes):
                            class Function(ffc.Function,Func):
                                __init__        = _init_function(Func)
                                __str__        = Function__str__
                                function_space = Function_function_space
                            funcs.append(Function(V[i]))
                    else:
                        raise TypeError, "Valid 'kwargs' are 'cppcode' and 'cppexpr' together with 'defaults'"
                    if len(funcs) == 1:
                        return funcs[0]
                    return tuple(funcs)
                
                # Instantiate one of each base class.
                cpp_func = cpp_BaseFunction.__new__(cls,V)
                ffc_func = ffc.Function.__new__(cls, V.element())

                # Update the dict of cpp_func with the attributes from ffc_func
                cpp_func.__dict__.update(copy.deepcopy(ffc_func.__dict__))
                
                # Return the cpp_func object with the updated __dict__
                return cpp_func
            
            dictionary['__new__'] = __new__
            
        # If the Function class is a user defined python class
        elif 'eval' in dictionary:
            # Check type of eval
            if not isinstance(dictionary['eval'],types.FunctionType):
                raise TypeError, "'eval' must be a 'function'"
        
        # If cppcode or cppexpr is provided send it to compile_function
        elif 'cppcode' in dictionary or 'cppexpr' in dictionary:
            # Check the handed attributes and return an args tuple
            args = _check_cpp_arguments(dictionary)
            
            # Compile the expr and assume only one function class is returned
            cpp_BaseFunction = compile_function(*args)[0]
            
            # Remove any surpluss attributes
            dictionary.pop('cppcode',None)
            dictionary.pop('cppexpr',None)
            dictionary.pop('defaults',None)
            
        else:
            raise TypeError, "Some error..."
        
        # Extend the bases with the cpp_BaseFunction and ffc.Function
        bases = (ffc.Function,cpp_BaseFunction)
        
        # Attach the init function to the dictionary
        dictionary['__init__'] = _init_function(cpp_BaseFunction,\
                                                dictionary.get('__init__',None))

        return type.__new__(cls, name, bases, dictionary)

####################### The User interface ##################### 

class Function(object):
    """Function represents a function in a finite element function space.

    Function is a versatile class that can be used either for coefficients
    in forms or for solutions of partial differential equations.

    A Function must always be instanstiated with a FunctionSpace V but
    takes a variable number of additional arguments depending on the
    situation, leading to different representations of the Function.
    We describe these different options below.

    1. Discrete function
    --------------------

    If only a FunctionSpace V is given to the constructor, the Function
    will be represented as a finite element function in the function space
    V defined by a vector of degrees of freedom:
    
    >>> u = Function(V)

    One may access the vector of degrees of freedom as follows:
    
    >>> x = u.vector()
    
    2. Simple user-defined JIT-compiled functions
    ---------------------------------------------

    One may alternatively specify a C++ code for evaluation of the Function
    as follows:

    >>> f0 = Function(V0, cppexpr = 'sin(x[0]) + cos(x[1]')
    >>> f1 = Function(V1, cppexpr = ('cos(x[0])','sin(x[1]'))
    
    Here f0 is a scalar function and f1 is vector-valued. The corresponding
    function spaces need to be of matching rank.
    
    Tensor functions of rank 2 (matrices) may also be created:
    
    >>> f3 = Function(V3, cppexpr = (('exp(x[0])','sin(x[1]'),
                                     ('sin(x[0])','tan(x[1]')))

    In general, a single string expression will be interpreted as a
    scalar, a tuple of strings as a tensor of rank 1 (a vector) and a
    tuple of tuples of strings as a tensor of rank 2 (a matrix).
    
    The expressions may depend on x[0], x[1] and x[2] which carry
    information about the coordinates where the function is
    evaluated. All math functions defined in <cmath> are available to
    the user.

    Function parameters can be included as follows:
    
    >>> f0 = Function(V0, cppexpr = 'A*sin(x[0]) + B*cos(x[1]')
    >>> f0.A = 2.0
    >>> f0.B = 4.0

    The parameters can only be scalars, and are all initialized to 0.0. The
    parameters can also be given default values, using the argument 'defaults':
    
    >>> f0 = Function(V0, cppexpr = 'A*sin(x[0]) + B*cos(x[1])',
                          defaults = {'A': 2.0,'B': 4.0})

    3. Complex user-defined JIT-compiled functions
    ----------------------------------------------

    The user can define a function using more complicated logic with
    the argument 'cppcode'. This argument should be a string of C++
    code that implements a class that inherits from dolfin::Function:
    
    >>> code = '''
    class MyFunc : public Function
    {
    public:
    
      MeshFunction<uint> *cell_data;
      
      MyFunc(FunctionSpace & V) : Function(V), cell_data(0) {}
      
      void eval(double* val, const double* x)
      {
        dolfin_assert(cell_data);
        switch ((*cell_data)(data.cell()))
        {
        case 0:
          val[0] = exp(-x[0]);
          break;
        case 1:
          val[0] = exp(-x[2]);
          break;
        default:
          val[0] = 0.0;
        }
      }
    
    };'''
    
    >>> cell_data = MeshFunction('uint', V.mesh(), 2)
    >>> f = Function(V, cppcode = code)
    >>> f.cell_data = cell_data
    
    4) User defined jit-compiled functions using batch processing
    -------------------------------------------------------------------------
    
    By handing a list of the functions expressions to 'cppexpr', the user can
    compile several function at a time. These can either be instantiated using
    a single function space, which will be used to instantiate all functions.
    A list of function spaces  can also be handed, where each function space
    corresponds to the function expressions in the list handed to 'cppexpr'. 

    >>> fs1, fs2 = Function(Vs,cppexpr = ['sin(x[0]) + cos(x[1]','exp([1])'])
    >>> fs,fv,ft = Function([Vs,Vv,Vt],cppexpr = ['sin(x[0]) + cos(x[1]',
                                                 ('cos(x[0])','sin(x[1]'),
                                                 (('cos(x[0])','sin(x[1]'),
                                                 ('sin(x[0])','cos(x[1]'))])
    
    5) Subclassed as a userdefined python function
    -------------------------------------------------------------------------

    The user can subclass Function and overload the 'eval' function. The subclass
    is then instantiated using a function space.
    
    >>> class MyFunction1(Function):
            def eval(self,value,x):
                dx = x[0] - 0.5
                dy = x[1] - 0.5
                values[0] = 500.0*exp(-(dx*dx + dy*dy)/0.02)
    >>> fs = MyFunction1(Vs)
    
    6) Subclassed as a jit-compiled userdefined function
    -------------------------------------------------------------------------

    The user can subclass Function and define the same attributes as described
    above for jit-compiled functions: 'cppexpr', 'defaults' and 'cppcode'.
    
    >>> class MyFunction2(Function):
            cppexpr = 'A*exp(-(pow(x[0]-0.5,2) + pow(x[1]-0.5,2))/B)'
            defaults = {"A":500.0,"B":0.02}
    >>> fv = MyFunction2(Vv)
    >>> class MyFunction3(Function):
            cppcode = code # See above for an example code.
    
    >>> fs = MyFunction3(V)
    >>> fs.mf = mf

    """
    # Set the meta class
    __metaclass__  = FunctionCreator

    # Set function attributes
    function_space = Function_function_space
    __str__        = Function__str__

# Help functions for defining the interface of {Basis,Trial,Test}Function
def BasisFunction__str__(self):
    return "%s in %s"%(type(self).__name__,str(self._V))

def BasisFunction__init__(Base):
    def __init__(self,V):
        if not isinstance(V,FunctionSpace):
            raise TypeError, "Provide a 'FunctionSpace'."
        Base.__init__(self, V.element())
        # We need to attach the FunctionSpace after calling
        # Base.__init__()
        self.data = V
    
    return __init__

# Subclassing of ffc.{Basis,Trial,Test}Function
class BasisFunction(ffc.BasisFunction):
    __init__ = BasisFunction__init__(ffc.BasisFunction)

class TrialFunction(ffc.TrialFunction):
    __init__ = BasisFunction__init__(ffc.TrialFunction)

class TestFunction(ffc.TestFunction):
    __init__ = BasisFunction__init__(ffc.TestFunction)

## Create new class inheriting from both FFC and DOLFIN FacetNormal
## (FFC FacetNormal is a function that returns a FFC Function object)
#class FacetNormal(ffc.Function, dolfin.cpp_FacetNormal):
#
#    def __init__(self, shape, mesh):
#        "Create FacetNormal"
#
#        element = ffc.VectorElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_FacetNormal.__init__(self, mesh)
#
## Create new class inheriting from FFC MeshSize and DOLFIN MeshSize
## (FFC MeshSize is a function that returns a FFC Function object)
#class MeshSize(ffc.Function, dolfin.cpp_MeshSize):
#
#    def __init__(self, shape, mesh):
#        "Create MeshSize"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_MeshSize.__init__(self, mesh)
#
## Create new class inheriting from FFC MeshSize and DOLFIN AvgMeshSize
## (FFC MeshSize is a function that returns a FFC Function object)
#class AvgMeshSize(ffc.Function, dolfin.cpp_AvgMeshSize):
#
#    def __init__(self, shape, mesh):
#        "Create AvgMeshSize"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_AvgMeshSize.__init__(self, mesh)
#
## Create new class inheriting from FFC FacetArea and DOLFIN FacetArea
## (FFC FacetArea is a function that returns a FFC Function object)
#class FacetArea(ffc.Function, dolfin.cpp_FacetArea):
#
#    def __init__(self, shape, mesh):
#        "Create FacetArea"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_FacetArea.__init__(self, mesh)
#
## Create new class inheriting from FFC InvFacetArea and DOLFIN InvFacetArea
## (FFC InvFacetArea is a function that returns a FFC Function object)
#class InvFacetArea(ffc.Function, dolfin.cpp_InvFacetArea):
#
#    def __init__(self, shape, mesh):
#        "Create InvFacetArea"
#
#        element = ffc.FiniteElement("Discontinuous Lagrange", shape, 0)
#        ffc.Function.__init__(self, element)
#        dolfin.cpp_InvFacetArea.__init__(self, mesh)
