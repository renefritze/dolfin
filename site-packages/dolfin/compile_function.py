"This module provides functionality for compilation of strings as dolfin Functions."

__author__ = "Martin Sandve Alnes (martinal@simula.no)"
__date__ = "2008-06-04 -- 2009-08-11"
__copyright__ = "Copyright (C) 2008-2008 Martin Sandve Alnes"
__license__  = "GNU LGPL Version 2.1"

# Modified by Johan Hake 2008-2009

import re
import os
import sys
import hashlib
import numpy
import instant
import types

# Import PyDOLFIN
import dolfin

__all__ = ["compile_function"]

# FIXME: Extend this list, needed to autodetect variable names that are not builtins
_builtins = [
             # local symbols:
             "pi",
             # cmath funcions:
             "cos", "sin", "tan", "acos", "asin", "atan", "atan2",
             "cosh", "sinh", "tanh",
             "exp", "frexp", "ldexp", "log", "log10", "modf",
             "pow", "sqrt", "ceil", "fabs", "floor", "fmod",
            ]

_eval_args = ["v", "x"]

_cpp_keywords = ["auto","const","double","float","int","short","struct","unsigned",
                 "break","continue","else","for","long","signed","switch","void",
                 "case","default","enum","goto","register","sizeof","typedef","volatile",
                 "char","do","extern","if","return","static","union","while",
                 "asm","dynamic_cast","namespace","reinterpret_cast","try",
                 "bool","explicit","new","static_cast","typeid",
                 "catch","false","operator","template","typename",
                 "class","friend","private","this","using",
                 "const_cast","inline","public","throw","virtual",
                 "delete","mutable","protected","true","wchar_t"]

# Add utility code here
_header = """
// cmath functions
using std::cos;
using std::sin;
using std::tan;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;

const double pi = acos(-1.0);

namespace dolfin
{

"""


_function_template = """
class %(classname)s: public Function
{
public:
%(members)s

  %(classname)s(boost::shared_ptr<FunctionSpace> V):
    Function(V)
  {
%(constructor)s
  }

  void eval(double* values, const double* x) const
  {
%(eval)s
  }
};
"""

hash_collection = []
def expression_to_function(expr, defaults):
    "Generates code for a dolfin::Function subclass for a single expression."
    global hash_collection

    tmp_hash = hashlib.md5(repr(expr)).hexdigest()
    if tmp_hash in hash_collection:
        raise TypeError,"The batch-compiled expressions must be unique: %s"%str(hash_collection+[expr])
    hash_collection.append(tmp_hash)
    classname = "function_%s" % tmp_hash

    # Get shape from expr and make e a flat tuple of strings
    if isinstance(expr, str):
        expr = (expr,)
        shape = ()
    elif isinstance(expr, (tuple,list)):
        if isinstance(expr[0], str):
            shape = (len(expr),)
        elif isinstance(expr[0], (tuple,list)):
            shape = (len(expr),len(expr[0]))
            assert isinstance(expr[0][0], str)
            expr = sum(expr, ())
    else:
        raise RuntimeError("Invalid expression %s" % expr)

    # Autodetect variables from function strings
    variables = set()
    expr = list(expr)
    for i, c in enumerate(expr):
        # Find groups of connected alphanumeric letters
        symbols = re.findall(r"([a-zA-Z_][\w]*)", c)
        assert isinstance(symbols, list)
        variables.update(symbols)
        # Replace all x data with data.x
        # (No need with the eval(double*, double*) interface)
        #c = c.replace("x[","data.x[")
        # FIXME: A hack to get around an ambiguous overloading of
        #        dolfin::pow(double,int)
        for sym in symbols:
            if sym in _cpp_keywords:
                raise TypeError, "The c++ keyword '%s' was detected in 'cpparg'. \nA Function expression that use c++ keywords cannot be compiled."%sym
        if "pow" in symbols:
            c = c.replace("pow","std::pow")
        expr[i] = c

    variables.difference_update(_builtins)
    variables.difference_update(_eval_args)
    numerals = [v for v in variables if v[0] in "0123456789"]
    variables.difference_update(numerals)

    # Generate code for member variables
    memberscode = "\n".join("  double %s;" % name for name in variables)

    # Assert that all values in defaults are scalars
    assert(all(isinstance(val,(int,float)) for val in defaults.itervalues()))

    # Generate constructor code for initialization of member variables
    constructorcode = "\n".join("    %s = %s;" %(name,str(defaults.get(name,0.0)))
                                for name in variables)

    # Generate code for the actual function evaluation
    evalcode = "\n".join("    values[%d] = %s;" % (i, c) for (i,c) in enumerate(expr))

    # Connect the code fragments using the function template code
    fragments = {}
    fragments["classname"]   = classname
    fragments["members"]     = memberscode
    fragments["eval"]        = evalcode
    fragments["constructor"] = constructorcode
    code = _function_template % fragments
    return classname, code

# NB! This code is highly dependent on the dolfin swig setup!
_additional_declarations = r"""
%init%{
import_array();
%}

%include exception.i

// Typemap check
%typecheck(SWIG_TYPECHECK_DOUBLE_ARRAY) double* {
    // General typemap
    $1 = PyArray_Check($input) ? 1 : 0;
}

// A greedy and non checking Typemap for double*
%typemap(in) double* {
    if PyArray_Check($input) {
        PyArrayObject *xa = reinterpret_cast<PyArrayObject*>($input);
        if ( PyArray_TYPE(xa) == NPY_DOUBLE )
            $1  = static_cast<double*>(PyArray_DATA(xa));
        else
            SWIG_exception(SWIG_ValueError, "numpy array of doubles expected");
    } else
        SWIG_exception(SWIG_ValueError, "numpy array expected");
}

// Uncomment these lines to use std::tr1 shared_ptr instead of boost shared_ptr
//#define SWIG_SHARED_PTR_NAMESPACE std
//#define SWIG_SHARED_PTR_SUBNAMESPACE tr1

%include <boost_shared_ptr.i>

%pythoncode %{
import dolfin.cpp
'''
A hack to get passed a bug in swig.
This is fixed in swig version 1.3.37
%}
%import(module="dolfin.cpp") "dolfin/function/Function.h"
%pythoncode %{
'''
%}

"""

def compile_function_code(code, classnames = None, module_name = None):

    # Create unique module name for this application run
    global _header, _additional_declarations
    if module_name is None:
        module_name = "dolfin_compile_function_%s" % hashlib.md5(repr(code) +
                                                                 repr(classnames) +
                                                                 instant.get_swig_version() +
                                                                 dolfin.__version__).hexdigest()

    # Autodetect classnames:
    _classnames = re.findall(r"class[ ]+([\w]+).*", code)
    # Just a little assertion for safety:
    if classnames is None:
        classnames = _classnames
    else:
        assert all(a == b for (a,b) in zip(classnames, _classnames))

    # Check cache
    compiled_module = instant.import_module(module_name)
    if compiled_module:
        # Get the compiled class
        function_classes = [getattr(compiled_module, name) for name in classnames]
        return function_classes

    print "Calling DOLFIN Function just-in-time (JIT) compiler, this may take some time...",
    sys.stdout.flush()

    instant_kwargs = configure_instant()

    # Declare shared_ptr interface
    shared_ptr_declarations = "\n".join("SWIG_SHARED_PTR_DERIVED(%s,dolfin::Function,dolfin::%s)"%(c,c)
                                        for c in classnames)

    _code = _header + code + "\n}\n"
    # Compile extension module with instant
    compiled_module = instant.build_module(\
             code              = _code,
             additional_declarations = _additional_declarations + \
                                       shared_ptr_declarations,
             signature         = module_name,
             **instant_kwargs
             #swigargs          = ['-c++','-I.'],
             #cppargs           = cppargs,
             #system_headers    = sysheaders,
             #include_dirs      = includes,
             #library_dirs      = libdirs,
             #libraries         = libraries,
             #swig_include_dirs = swig_include_dirs,
             )

    print "done"
    sys.stdout.flush()

    # Get the compiled class
    function_classes = [getattr(compiled_module, name) for name in classnames]
    return function_classes

def configure_instant():
    """Check system requirements

    Returns a dict with kwargs that can be passed to instant.build_module.
    """
    instant_kwargs = {}
    # Get system configuration
    (instant_kwargs['include_dirs'],
     flags,
     instant_kwargs['libraries'],
     instant_kwargs['library_dirs']) = instant.header_and_libs_from_pkgconfig("dolfin")

    # Let swig see the installed dolfin swig files
    swig_include_dirs = []
    dolfin_include_found = False
    ufc_include_found = False
    for inc_dir in instant_kwargs['include_dirs']:
        # Check if dolfin is installed in inc_dir
        if os.path.exists(os.path.join(inc_dir, "dolfin", "swig", "dolfin.i")):
            dolfin_include_found = True
            if inc_dir not in swig_include_dirs:
                swig_include_dirs.append(inc_dir)

        # Check if ufc is installed in inc_dir
        if os.path.exists(os.path.join(inc_dir, "swig", "ufc.i")):
            ufc_include_found = True
            if inc_dir not in swig_include_dirs:
                swig_include_dirs.append(inc_dir)

    if not dolfin_include_found:
        raise OSError, """Didn't find dolfin.i in include paths returned from pkg-config.
Please make sure that your DOLFIN installation corresponds with the one returned by pkg-config"""

    if not ufc_include_found:
        raise OSError, """Didn't find ufc.i in include paths returned from pkg-config.
Please make sure that your UFC installation corresponds with the one returned by pkg-config"""

    # Check if UFC is importable and what version of swig was used to
    # create the UFC extension module
    try: import ufc
    except: raise OSError, "Please install the python extenstion module of UFC on your system.\n"

    # Check that the form compiler will use the same swig version
    # that UFC was compiled with
    if not instant.check_swig_version(ufc.__swigversion__,same=True):
        raise OSError, """The python extension module of UFC was not compiled with the present version of swig.
Install swig version %s or recompiled UFC with present swig
"""%ufc.__swigversion__

    # Check that the form compiler will use the same swig version
    # that PyDOLFIN was compiled with
    if not instant.check_swig_version(dolfin.cpp.__swigversion__,same=True):
        raise OSError, """PyDOLFIN was not compiled with the present version of swig.
Install swig version %s or recompiled PyDOLFIN with present swig
"""%dolfin.cpp.__swigversion__

    # Check for boost installation
    # Set a default directory for the boost installation
    if sys.platform == "darwin":
        # use fink as default
        default = os.path.join(os.path.sep,"sw")
    else:
        default = os.path.join(os.path.sep,"usr")

    # If BOOST_DIR is not set use default directory
    boost_dir = os.getenv("BOOST_DIR", default)
    boost_is_found = False
    for inc_dir in ["", "include"]:
        if os.path.isfile(os.path.join(boost_dir, inc_dir, "boost", "version.hpp")):
            boost_include_dir = os.path.join(boost_dir, inc_dir)
            boost_is_found = True
            break

    if not boost_is_found:
        raise OSError, """The Boost library was not found.
If Boost is installed in a nonstandard location,
set the environment variable BOOST_DIR.
"""

    instant_kwargs['swig_include_dirs'] = swig_include_dirs
    instant_kwargs['include_dirs'].append(numpy.get_include())
    instant_kwargs['include_dirs'].append(boost_include_dir)
    instant_kwargs['system_headers'] = ["cmath", "iostream", "stdexcept","numpy/arrayobject.h",
                                        "dolfin.h","boost/shared_ptr.hpp"]
    instant_kwargs['swigargs'] =['-c++','-I.']

    instant_kwargs['cppargs'] = []

    return instant_kwargs


def compile_function(cppargs, defaults_list):
    """Compiles a tuple of C++ expressions into a dolfin::Function class.

    If 'cppexpr' is True, 'expression' is interpreted as c++ expressions, that
    will be used to construct a Function class.

    The expression can either be a str in which case it is
    interpreted as a scalar expression and a scalar Function is generated.

    If the expression is a tuple consisting of more than one str it is
    interpreted as a vector expression, and a rank 1 Function is generated.

    A tuple of tuples of str objects is interpreted as a matrix
    expression, and a rank 2 Function is generated.

    If an expression string contains a name, it is assumed to be a scalar
    parameter name, and is added as a public member of the generated function.
    The names of these parameters are then returned in a list together with the
    compiled function class.

    If 'cppexpr' is True, 'expression' is interpreted as c++ code with complete
    implementations of a subclasses of dolfin::Function.

    The exceptions are set in the variable dolfin.compile_function._builtins."""
    #, which contains:
    #    %s
    #""" % "\n".join("        " + b for b in _builtins)
    # FIXME: Hook up this to a more general debug mechanism
    global hash_collection
    sys.stdout.flush()
    assert(isinstance(cppargs,list))
    assert(isinstance(defaults_list,list))
    assert(len(cppargs)==len(defaults_list))
    code_snippets = []; classnames = []
    for cpparg, defaults in zip(cppargs,defaults_list):
        assert(isinstance(cpparg,(str,tuple,list)))
        assert(isinstance(defaults,dict) or defaults is None)
        # If the cpparg includes the word 'class' and 'Function', assume it is a c++ code snippet
        if isinstance(cpparg,str) and "class" in cpparg and "Function" in cpparg:
            # Assume that a code snippet is passed as cpparg
            code = cpparg

            # Get the class name
            classname = re.findall(r"class[ ]+([\w]+).*", code)[0]
        else:
            defaults = defaults or {}
            classname, code  = expression_to_function(cpparg,defaults)

        code_snippets.append(code)
        classnames.append(classname)

    # Clear the hash_collection
    hash_collection = []
    function_classes = compile_function_code("\n\n".join(code_snippets),classnames)

    return function_classes


if __name__ == "__main__":
    cn1, code1 = expression_to_function("exp(alpha)",{'alpha':1.5})
    cn2, code2 = expression_to_function(("sin(x[0])", "cos(x[1])", "0.0"),{})
    cn3, code3 = expression_to_function((("sin(x[0])", "cos(x[1])"), ("0.0", "1.0")),{})

    print code1
    print cn1

    print code2
    print cn2

    print code3
    print cn3
