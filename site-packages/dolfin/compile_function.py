"This module provides functionality for compilation of strings as dolfin Functions."

__author__ = "Martin Sandve Alnes (martinal@simula.no)"
__date__ = "2008-06-04 -- 2008-08-07"
__copyright__ = "Copyright (C) 2008-2008 Martin Sandve Alnes"
__license__  = "GNU LGPL Version 2.1"

import re
import os
import hashlib
import numpy
import instant

__all__ = ["compile_function"]

# FIXME: Extend this list, needed to autodetect variable names that are not builtins
_builtins = [
             # local symbols:
             "pi",
             # cmath funcions:
             "cos", "sin", "tan", "acos", "asin", "atan", "atan2",
             "cosh", "sinh", "tanh",
             "exp", "frexp", "ldexp", "log", "log10", "modf",
             "pow", "sqrt", "ceil", "fabs", "floor", "fmod",
            ]
_eval_args = ["v", "x"]

# Add utility code here
_header = """
// cmath functions
using std::cos;
using std::sin;
using std::tan;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;

const double pi = acos(-1.0);

namespace dolfin
{

"""


_function_template = """
class %(classname)s: public Function
{
public:
%(members)s

  %(classname)s(FunctionSpace & V):
    Function(V)
  {
%(constructor)s
  }

  void eval(double* v, const Data& data) const
  {
%(eval)s
  }
};
"""

def expression_to_function(e, default):
    "Generates code for a dolfin::Function subclass for a single expression."
    
    default = default or {}
    assert(isinstance(default,dict))
    
    classname = "function_%s" % hashlib.md5(repr(e)).hexdigest()
    
    # Get shape from e and make e a flat tuple of strings
    if isinstance(e, str):
        e = (e,)
        shape = ()
    elif isinstance(e, tuple):
        if isinstance(e[0], str):
            shape = (len(e),)
        elif isinstance(e[0], tuple):
            shape = (len(e),len(e[0]))
            assert isinstance(e[0][0], str)
            e = sum(e, ())
    else:
        raise RuntimeError("Invalid expression %s" % e)
    
    # Autodetect variables from function strings
    variables = set()
    e = list(e)
    for i, c in enumerate(e):
        # Find groups of connected alphanumeric letters
        symbols = re.findall(r"([a-zA-Z_][\w]*)", c)
        assert isinstance(symbols, list)
        variables.update(symbols)
        # Replace all x data with data.x
        c = c.replace("x[","data.x[")
        # FIXME: A hack to get around an ambiguous overloading of
        #        dolfin::pow(double,int)
        if "pow" in symbols:
            c = c.replace("pow","std::pow")
        e[i] = c
        
    variables.difference_update(_builtins)
    variables.difference_update(_eval_args)
    numerals = [v for v in variables if v[0] in "0123456789"]
    variables.difference_update(numerals)
    
    # Generate code for member variables
    memberscode = "\n".join("  double %s;" % name for name in variables)

    # Assert that all values in default are scalars
    assert(all(isinstance(val,(int,float)) for val in default.itervalues()))
    
    # Generate constructor code for initialization of member variables
    constructorcode = "\n".join("    %s = %s;" %(name,str(default.get(name,0.0)))
                                for name in variables)
    
    # Generate code for the actual function evaluation
    evalcode = "\n".join("    v[%d] = %s;" % (i, c) for (i,c) in enumerate(e))
    
    # Connect the code fragments using the function template code
    fragments = {}
    fragments["classname"]   = classname
    fragments["members"]     = memberscode
    fragments["eval"]        = evalcode
    fragments["constructor"] = constructorcode
    code = _function_template % fragments
    return code, classname


# NB! This code is highly dependent on the dolfin swig setup!
_additional_declarations = r"""
%rename(cpp_Function) Function;
%include exception.i
%include cpointer.i
%pointer_class(int, intp);
%pointer_class(double, doublep);
%include std_vector.i
%template(STLVectorFunctionPtr) std::vector<dolfin::Function *>;
%import dolfin.i
"""

_additional_definitions  = """
#include <dolfin.h>
#include <numpy/arrayobject.h>
"""

def compile_function_code(code, classname = None, module_name = None):
    # Create unique module name for this application run
    global _header, _additional_definitions, _additional_declarations
    if module_name is None:
        module_name = "dolfin_compile_function_%s" % hashlib.md5(repr(code) + repr(classname)).hexdigest()

    # Autodetect the classname:
    _classname = re.findall(r"class[ ]+([\w]+).*", code)
    if _classname:
        _classname = _classname[0]
    else:
        raise RuntimeError, "class name not defined in the cpp code"

    # Just a little assertion for safety:
    if classname is None:
        classname = _classname
    else:
        assert classname == _classname

    # Get system configuration   
    (includes, flags, libraries, libdirs) = instant.header_and_libs_from_pkgconfig("dolfin")
    
    # Let swig see the installed dolfin swig files
    swigargs = "-c++"
    found = False
    for inc_dir in includes:
        if os.path.exists(os.path.join(inc_dir, "dolfin", "swig", "dolfin.i")):
            found = True
            swigargs += " -I%s -I%s/dolfin/swig" % (inc_dir, inc_dir)
    if not found:
        print "WARNING: Didn't find dolfin.i in include paths returned from pkg-config."
    
    numpy_dir = numpy.get_include()
    includes.append(numpy_dir)
    
    sysheaders = ["cmath", "iostream", "stdexcept",
                  "dolfin.h", "dolfin/mesh/Mesh.h", "dolfin/function/Function.h"]
    
    #cppargs = flags
    cppargs = []
    
    # Compile extension module with instant
    compiled_module = instant.build_module(\
             code           = _header + code + "\n}\n",
             additional_definitions  = _additional_definitions,
             additional_declarations = _additional_declarations,
             system_headers = sysheaders,
             include_dirs   = includes,
             library_dirs   = libdirs,
             libraries      = libraries,
             swigargs       = swigargs,
             cppargs        = cppargs,
             signature      = module_name
             )
    
    # Get the compiled class
    function_class = getattr(compiled_module, classname)
    return function_class

def compile_function(expression, cppcode = False, default = None):
    """Compiles a tuple of C++ expressions into a dolfin::Function class.

    If 'cppexpr' is True, 'expression' is interpreted as c++ expressions, that
    will be used to construct a Function class.

    The expression can either be a str in which case it is
    interpreted as a scalar expression and a scalar Function is generated.
    
    If the expression is a tuple consisting of more than one str it is
    interpreted as a vector expression, and a rank 1 Function is generated.
    
    A tuple of tuples of str objects is interpreted as a matrix
    expression, and a rank 2 Function is generated.

    If an expression string contains a name, it is assumed to be a scalar
    parameter name, and is added as a public member of the generated function.
    The names of these parameters are then returned in a list together with the
    compiled function class.

    If 'cppexpr' is True, 'expression' is interpreted as c++ code with complete
    implementations of a subclasses of dolfin::Function.
    
    The exceptions are set in the variable dolfin.compile_functions._builtins."""
    #, which contains:
    #    %s
    #""" % "\n".join("        " + b for b in _builtins)
    # FIXME: Hook up this to a more general debug mechanism
    import sys
    print "Calling just-in-time (JIT) compiler, this may take some time...",
    sys.stdout.flush()
    if cppcode:
        assert(expression,str)
        function_class = compile_function_code(expression)
    else:
        assert(expression,(str,tuple))
        code, classname= expression_to_function(expression, default)
        function_class = compile_function_code(code, classname)
    print "done"
    sys.stdout.flush()
    return function_class


if __name__ == "__main__":
    code1, cn1 = expression_to_function("exp(alpha)",{'alpha':1.5})
    code2, cn2 = expression_to_function(("sin(x[0])", "cos(x[1])", "0.0"),None)
    code3, cn3 = expression_to_function((("sin(x[0])", "cos(x[1])"), ("0.0", "1.0")),None)
    
    print code1
    print cn1
    
    print code2
    print cn2
    
    print code3
    print cn3


