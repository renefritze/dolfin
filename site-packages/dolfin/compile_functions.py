"This module provides functionality for compilation of strings as dolfin Functions."

__author__ = "Martin Sandve Alnes (martinal@simula.no)"
__date__ = "2008-06-04 -- 2009-08-17"
__copyright__ = "Copyright (C) 2008-2008 Martin Sandve Alnes"
__license__  = "GNU LGPL Version 2.1"

# Modified by Johan Hake 2008-2009

import re
import sys
import hashlib
import instant

# Import PyDOLFIN
import dolfin 

from compile_extension_module import (compile_extension_module,
                                      expression_to_code_fragments,
                                      math_header)

__all__ = ["compile_functions"]

_function_template = """
class %(classname)s: public Function
{
public:
%(members)s

  %(classname)s(boost::shared_ptr<FunctionSpace> V):
    Function(V)
  {
%(constructor)s
  }

  void eval(double* values, const double* x) const
  {
%(evalcode)s
  }
};
"""

def flatten_and_check_expression(expr):
    # Convert expr to a flat tuple of strings
    if isinstance(expr, str):
        return (expr,)
    elif isinstance(expr, tuple):
        if all(isinstance(e,tuple) for e in expr):
            expr = sum(expr, ())
        if all(isinstance(e,str) for e in expr):
            return expr
    else:
        raise TypeError, "Wrong type of expressions. Provide a 'str', a 'tuple' of 'str' or a 'tuple' of 'tuple' of 'str': %s" % str(expr)

def expression_to_function(expr, defaults, expr_num):
    "Generates code for a dolfin::Function subclass for a single expression."

    # Check and flattern provided expression
    expr = list(flatten_and_check_expression(expr))

    # Extract code fragments from the expr and defaults
    fragments = expression_to_code_fragments(expr, defaults, ["v","x"])
    
    # Generate code for the actual function evaluation
    evalcode = "\n".join("    values[%d] = %s;" % (i, c) for (i,c) in enumerate(expr))

    # Assign classname
    classname = "function_%d" % expr_num
    
    # Connect the code fragments using the function template code
    fragments["classname"] = classname
    fragments["evalcode"]  = evalcode

    # Produce the C++ code for the function class
    code = _function_template % fragments
    return classname, code

# NB! This code is highly dependent on the dolfin swig setup!
_numpy_typemaps = r"""
// Typemap check
%typecheck(SWIG_TYPECHECK_DOUBLE_ARRAY) double* {
    // General typemap
    $1 = PyArray_Check($input) ? 1 : 0;
}

// A greedy and non checking Typemap for double*
%typemap(in) double* {
    if PyArray_Check($input) {
        PyArrayObject *xa = reinterpret_cast<PyArrayObject*>($input);
        if ( PyArray_TYPE(xa) == NPY_DOUBLE )
            $1  = static_cast<double*>(PyArray_DATA(xa));
        else
            SWIG_exception(SWIG_ValueError, "numpy array of doubles expected");
    } else
        SWIG_exception(SWIG_ValueError, "numpy array expected");
}
"""

def compile_function_code(code, classnames = None, module_name = None):
    # Autodetect classnames:
    _classnames = re.findall(r"class[ ]+([\w]+).*", code)
    
    # Just a little assertion for safety:
    if classnames is None:
        classnames = _classnames
    else:
        assert all(a == b for (a,b) in zip(classnames, _classnames))

    # Complete the code
    code = math_header + \
"""
namespace dolfin
{
""" + code + \
"""
}
"""
    
    # Compile the extension module
    compiled_module = dolfin.compile_extension_module(
                                code,
                                dolfin_import_files=["function/Function.h"],
                                additional_declarations=_numpy_typemaps,
                                use_numpy_typemaps=False)
    
    # Get the compiled class
    function_classes = [getattr(compiled_module, name) for name in classnames]
    return function_classes

def compile_functions(cppargs, defaults_list):
    """Compiles a tuple of C++ expressions into a dolfin::Function class.

    If 'cppexpr' is True, 'expression' is interpreted as c++ expressions, that
    will be used to construct a Function class.

    The expression can either be a str in which case it is
    interpreted as a scalar expression and a scalar Function is generated.

    If the expression is a tuple consisting of more than one str it is
    interpreted as a vector expression, and a rank 1 Function is generated.

    A tuple of tuples of str objects is interpreted as a matrix
    expression, and a rank 2 Function is generated.

    If an expression string contains a name, it is assumed to be a scalar
    parameter name, and is added as a public member of the generated function.
    The names of these parameters are then returned in a list together with the
    compiled function class.

    If 'cppexpr' is True, 'expression' is interpreted as c++ code with complete
    implementations of a subclasses of dolfin::Function.

    The exceptions are set in the variable dolfin.compile_function._builtins."""
    #, which contains:
    #    %s
    #""" % "\n".join("        " + b for b in _builtins)
    # FIXME: Hook up this to a more general debug mechanism
    assert(isinstance(cppargs,list))
    assert(isinstance(defaults_list,list))
    assert(len(cppargs)==len(defaults_list))
    
    # Check for uniq sub expressions
    if len (set(hashlib.md5(repr(expr)+repr(default)).hexdigest()\
                for expr, default in zip(cppargs,defaults_list))) != len(cppargs):
        raise TypeError,"The batch-compiled expressions must be unique."
    
    # Collect code and classnames
    code_snippets = []; classnames = []
    expr_num = 0
    for cpparg, defaults in zip(cppargs,defaults_list):
        assert(isinstance(cpparg,(str,tuple,list)))
        assert(isinstance(defaults,dict) or defaults is None)
        # If the cpparg includes the word 'class' and 'Function', assume it is a c++ code snippet
        if isinstance(cpparg,str) and "class" in cpparg and "Function" in cpparg:
            # Assume that a code snippet is passed as cpparg
            code = cpparg
            
            # Get the class name
            classname = re.findall(r"class[ ]+([\w]+).*", code)[0]
        else:
            defaults = defaults or {}
            classname, code= expression_to_function(cpparg, defaults, expr_num)
            expr_num += 1
            
        code_snippets.append(code)
        classnames.append(classname)

    # Clear the hash_collection
    hash_collection = []
    function_classes = compile_function_code("\n\n".join(code_snippets),classnames)

    return function_classes


if __name__ == "__main__":
    cn1, code1 = expression_to_function("exp(alpha)",{'alpha':1.5})
    cn2, code2 = expression_to_function(("sin(x[0])", "cos(x[1])", "0.0"),{})
    cn3, code3 = expression_to_function((("sin(x[0])", "cos(x[1])"), ("0.0", "1.0")),{})

    print code1
    print cn1

    print code2
    print cn2

    print code3
    print cn3
