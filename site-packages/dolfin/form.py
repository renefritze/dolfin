"""This module defines a Form class that wraps FFC forms and UFC forms
into a cpp.Form (dolfin::Form)."""

__author__ = "Johan Hake (hake@simula.no)"
__date__ = "2008-12-04 -- 2008-12-04"
__copyright__ = "Copyright (C) 2008 Johan Hake"
__license__  = "GNU LGPL Version 2.1"

# Modified by Anders Logg, 2008

__all__ = ["Form"]

# Import FFC and SWIG-generated extension module (DOLFIN C++)
import ffc
import cpp

# Import JIT compiler
from jit import jit

# Temporary storage for compiled coefficient functions preventing
# Python from deleting our function objects before assembly!
_compiled_coefficients = []

class Form(cpp.Form):

    def __init__(self, form, test_spaces=None, coefficients=None, options=None):
        "Create JIT-compiled form from any given form (compiled or not)."

        # Compile form if necessary
        if not hasattr(form, "create_cell_integral"):
            (self._compiled_form, module, form_data) = jit(form, options)
            
        else:
            self._compiled_form = form
            form_data     = None

        # Extract test spaces and coefficients
        _test_spaces  = _extract_test_spaces(form_data, test_spaces)
        _coefficients = _extract_coefficients(form_data, coefficients)

        # Initialize base class
        cpp.Form.__init__(self, _test_spaces, _coefficients, self._compiled_form)

def _extract_test_spaces(form_data, test_spaces):
    "Extract list of test spaces."

    test_space_error = "Error while extracting test and/or trial spaces."
    _test_spaces = cpp.STLVectorFunctionSpacePtr()
    
    if test_spaces is None:
        if not hasattr(form_data, "basisfunction_data"):
            raise TypeError, test_space_error + \
                  "Missing data about basis functions in form data."
        for V in form_data.basisfunction_data:
            if not isinstance(V, cpp.FunctionSpace):
                raise TypeError, test_space_error
            _test_spaces.push_back(V)
    else:
        if not isinstance(test_spaces, (list, cpp.FunctionSpaces)):
            raise TypeError, test_space_error
        if isinstance(test_spaces, list):
            if len(test_spaces) != form_data.rank:
                raise ValueError, test_space_error + \
                      " Wrong number of test spaces (should be %d)." % form_data.rank
            for V in test_spaces:
                _test_spaces.push_back(V)
        else:
            for i in xrange(form_data.rank):
                _test_spaces.push_back(test_spaces)

    return _test_spaces

def _extract_coefficients(form_data, coefficients):
    "Extract list of coefficients."

    coefficient_error = "Error while extracting coefficients. "
    _coefficients = cpp.STLVectorFunctionPtr()

    if coefficients is None:
        if not hasattr(form_data, "coefficients"):
            raise TypeError, coefficient_error + \
                  "Missing data about coefficients in form data."
        for c in form_data.coefficients:
            if not isinstance(c.f, cpp.Function):
                raise TypeError, coefficient_error + \
                      "Either provide a dict of cpp.Functions, or use Function to define your form."
            _coefficients.push_back(c.f)
    else:
        # FIXME: I have disabled compiled_functions based on strings for now
        #       We could ofcourse add it back, but they need a FunctionSpace to
        #       be initialized.
        ## Compile all strings as dolfin::Function
        #string_expressions = []
        #for c in coefficients:
        #    # Note: To allow tuples of floats or ints below, this logic becomes more involved...
        #    if isinstance(c, (tuple, str)):
        #        string_expressions.append(c)
        #if string_expressions:
        #    compiled_functions = compile_functions(string_expressions, mesh)
        #    compiled_functions.reverse()
        #
        # Build list of coefficients
        error_info = "Provide a 'dict' with cpp.Functions, with the corresponding ffc.Function as key."
        if not isinstance(coefficients,dict):
            raise TypeError, coefficient_error + error_info
        for f, c in coefficients.iteritems():
            # FIXME: I have turned of these for now. Should probably add something for
            #       at least constant functions
            # Note: We could generalize this to support more objects 
            # like sympy expressions, tuples for constant vectors, etc...
            #if isinstance(c, (float, int)):
            #    c = cpp.Function(mesh, float(c))
            #elif isinstance(c, (tuple, str)):
            #    c = compiled_functions.pop()
            if not isinstance(f, ffc.Function) or not isinstance(c, cpp.Function):
                raise TypeError, coefficient_error
            _coefficients.push_back(c)
            _compiled_coefficients.append(c)

    return _coefficients
