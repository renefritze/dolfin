"""This module defines different MultiStageScheme classes which can be
passed to a RKSolver"""

# Copyright (C) 2013 Johan Hake
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.
#
# Modified by Patrick Farrell, 2013
#
# First added:  2013-02-22
# Last changed: 2013-06-18

import numpy as np
import functools

# Import SWIG-generated extension module (DOLFIN C++)
import dolfin.cpp as cpp

# Import ufl
import ufl

# Import classes from dolfin python layer
from dolfin.functions.constant import Constant
from dolfin.functions.expression import Expression
from dolfin.functions.function import Function
from dolfin.fem.formmanipulations import derivative, adjoint
from ufl import action as ufl_action
from dolfin.fem.form import Form
import ufl.algorithms

# FIXME: Add support for algebraic parts (at least for implicit)
# FIXME: Add support for implicit/explicit split ala IMEX schemes

def safe_adjoint(x):
    return adjoint(x, reordered_arguments=x.arguments())

def safe_action(x, y):
    x = ufl.algorithms.expand_derivatives(x)
    if x.integrals() == ():
        return x # form is empty, return anyway
    else:
        return ufl_action(x, y)

def _check_abc(a, b, c):
    if not (isinstance(a, np.ndarray) and (len(a) == 1 or \
            (len(a.shape)==2 and a.shape[0] == a.shape[1]))):
        raise TypeError("Expected an m x m numpy array as the first argument")
    if not (isinstance(b, np.ndarray) and len(b.shape) in [1,2]):
        raise TypeError("Expected a 1 or 2 dimensional numpy array as the second argument")
    if not (isinstance(c, np.ndarray) and len(c.shape) == 1):
        raise TypeError("Expected a 1 dimensional numpy array as the third argument")

    # Make sure a is a "matrix"
    if len(a) == 1:
        a.shape = (1, 1)

    # Get size of system
    size = a.shape[0]

    # If b is a matrix we expect it to have two rows
    if len(b.shape) == 2:
        if not (b.shape[0] == 2 and b.shape[1] == size):
            raise ValueError("Expected a 2 row matrix with the same number "\
                             "of collumns as the first dimension of the a matrix.")
    elif len(b) != size:
        raise ValueError("Expected the length of the b vector to have the "\
                         "same size as the first dimension of the a matrix.")

    if len(c) != size:
        raise ValueError("Expected the length of the c vector to have the "\
                         "same size as the first dimension of the a matrix.")

    # Check if the method is singly diagonally implicit
    sigma = -1
    for i in range(size):
        # If implicit
        if a[i,i] != 0:
            if sigma == -1:
                sigma = a[i,i]
            elif sigma != a[i,i]:
                raise ValueError("Expected only singly diagonally implicit "
                                 "schemes. (Same value on the diagonal of 'a'.)")
            
    # Check if tableau is fully implicit
    for i in range(size):
        for j in range(i):
            if a[j, i] != 0:
                raise ValueError("Does not support fully implicit Butcher tableau.")

    return a

def _check_form(rhs_form):
    if not isinstance(rhs_form, ufl.Form):
        raise TypeError("Expected a ufl.Form as the 5th argument.")

    # Check if form contains a cell or point integral
    if rhs_form.integrals_by_type("cell"):
        DX = ufl.dx
    elif rhs_form.integrals_by_type("point"):
        DX = ufl.dP
    else:
        raise ValueError("Expected either a cell or point integral in the form.")

    arguments = rhs_form.arguments()
    if len(arguments) != 1:
        raise ValueError("Expected the form to have rank 1")

    return DX

def _time_dependent_expressions(rhs_form, time):
    """
    Return a list of expressions which uses the present time as a parameter
    """
    # FIXME: Add extraction of time dependant expressions from bcs too
    time_dependent_expressions = dict()
  
    for coefficient in rhs_form.coefficients():
        if hasattr(coefficient, "user_parameters"):
            for c_name, c in list(coefficient.user_parameters.items()):
                if isinstance(c, cpp.GenericFunction) and time.id() == c.id():
                    if coefficient not in time_dependent_expressions:
                        time_dependent_expressions[coefficient] = [c_name]
                    else:
                        time_dependent_expressions[coefficient].append(c_name)

    return time_dependent_expressions
          
def _replace_dict_time_dependent_expression(time_dep_expressions, time, dt, c):
    assert(isinstance(c, float))
    replace_dict = {}
    if c == 0.0 or not time_dep_expressions:
        return replace_dict
    new_time = Expression("time+c*dt", time=time, c=c, dt=dt)
    for expr, c_names in list(time_dep_expressions.items()):
        assert(isinstance(expr, Expression))
        kwargs = dict(name=expr.name(), label=expr.label(), \
                      element=expr.ufl_element(), **expr.user_parameters)
        for c_name in c_names:
            kwargs[c_name] = new_time
        replace_dict[expr] = Expression(expr.cppcode, **kwargs)
        
    return replace_dict
    
def _rush_larsen_scheme_generator(rhs_form, solution, linear_terms, time, order):
    """
    Generates a list of forms and solutions for a given Butcher tableau 

    *Arguments*
        rhs_form (ufl.Form)
            A UFL form representing the rhs for a time differentiated equation
        solution (_Function_)
            The prognostic variable
        linear_terms (list)
            A list of booleans determining the linear terms of the rhs_form 
        time (_Constant_)
            A Constant holding the time at the start of the time step
        order (int)
            The order of the scheme
    """

    DX = _check_form(rhs_form)
    
    if DX != ufl.dP:
        raise TypeError("Expected a form with a Pointintegral.")
    
    # Create time step
    dt = Constant(0.1)

    # Get test function
    arguments = rhs_form.arguments()
    coefficients = rhs_form.coefficients()
    v = arguments[0]
    vector_rhs = len(v.ufl_shape)>0 and v.ufl_shape[0]>1

    system_size = v.ufl_shape[0] if vector_rhs else 1
    linear_terms = linear_terms or [True for _ in range(system_size)]

    # If all terms are linear (or no linear terms are passed) we add a
    # safe guard to the linearized term. See below
    safe_guard = sum(linear_terms) == system_size
    if len(linear_terms) != system_size:
        raise ValueError("Expected length of linear_terms to be equal to the "\
                         "dimension of the rhs.")

    # Get the integrand 
    integrand = rhs_form.integrals_by_type("point")[0].integrand()

    # Check that we have an inner or mul with a test function as second argument
    if vector_rhs:
            
        # If vector we expect an Inner
        if not isinstance(integrand, ufl.classes.Inner) or integrand.operands()[1]!=v:
            raise TypeError("Expected an Inner with test function as integrand "\
                            "for a vector expression.")

        # Get rhs expressions from the inner product
        rhs_exprs = integrand.operands()[0]
        rhs_jac = ufl.diff(rhs_exprs, solution)
        diff_rhs_exprs = [rhs_jac[ind, ind] for ind in range(system_size)]

        # Replace original vector coefficient with scalars

        # Scalar constants used to linearize component wise
        scalar_solutions = [Constant(1) for _ in range(system_size)]
        rhs_exprs_scalars = ufl.replace(rhs_exprs, \
                                        {solution : ufl.as_vector(scalar_solutions)})

        # Linearize each linear rhs term. If not linear just include a zero constant
        # This will be used to determine if a linearized expression is zero
        diff_rhs_exprs_scalars = ufl.as_vector([ufl.diff(rhs_exprs_scalars[ind], u_i)
                                                for ind, u_i in enumerate(\
                                                    scalar_solutions)])

        # FIXME: We could either tabulate the rhs and the linearized
        # FIXME: rhs as two stages and then use this when we tabulate the last stage,
        # FIXME: or we can just tabulate the final stage as is. We here try the latter
        rl_ufl_form = ufl.zero()

        # Add component wise contribution to rl form 
        for ind in range(system_size):

            # Rush larsen and forward euler step
            rl_du_i = rhs_exprs[ind]/diff_rhs_exprs[ind]*(ufl.exp(diff_rhs_exprs[ind]*dt) - 1.0)
            fe_du_i = rhs_exprs[ind]*dt

            rl_du_i_scalar = diff_rhs_exprs_scalars[ind]
            not_zero = ufl.algorithms.expand_derivatives(rl_du_i_scalar) != 0
            
            # If exact integration
            if not_zero and linear_terms[ind]:

                # If safe guard 
                if safe_guard:
                    du_i = ufl.conditional(ufl.lt(abs(diff_rhs_exprs[ind]), 1e-8),\
                                           fe_du_i, rl_du_i)
                else:
                    du_i = rl_du_i

            # Else explicit Euler
            else:
                du_i = fe_du_i

            rl_ufl_form += (solution[ind] + du_i)*v[ind]

        rl_ufl_form = rl_ufl_form*DX
    else:
        
        # If scalar we expect a Product
        if not isinstance(integrand, ufl.classes.Product) or integrand.operands()[0]!=v:
            raise TypeError("Expected a Product with test function as integrand")

        # Get rhs expression from the inner product
        rhs_expr = integrand.operands()[1]

        # linearize expr
        diff_rhs_expr = ufl.diff(rhs_expr, solution)

        # Rush larsen and forward euler 
        fe_du = rhs_expr*dt

        not_zero = ufl.algorithms.expand_derivatives(diff_rhs_expr) != 0

        # Only one linear term always safe guard
        if linear_terms[0] and not_zero:
            rl_du = rhs_expr/diff_rhs_expr*(ufl.exp(diff_rhs_expr*dt) - 1.0)
            #rl_ufl_form = (solution + ufl.conditional(ufl.lt(rl_du, 1e-8), fe_du, rl_du))*v*DX
            rl_ufl_form = (solution + rl_du)*v*DX
            rl_ufl_form = (solution + fe_du)*v*DX
            rl_ufl_form = (solution*ufl.exp(dt))*v*DX
            
        else:
            rl_ufl_form = (solution + fe_du)*v*DX
    
    # No stage forms (yet...)
    ufl_stage_forms = []
    dolfin_stage_forms = []
    dt_stage_offsets = []

    # Stage solutions (3 per order rhs, linearized, and final step)
    # If 2nd order the final step for 1 step is a stage
    #size = 2 if order == 1 else 5
    size = 0
    stage_solutions = [Function(solution.function_space(), name="k_%d"%i)
                       for i in range(size)]
    assert order == 1, "No support for order 2, yet"
    
    # Create the stage forms
    y_ = solution
    time_ = time
    time_dep_expressions = _time_dependent_expressions(rhs_form, time)

    # FIXME: Implement in a loop for higher ordered Rush Larsen schemes
    #if dt_stage_offsets:
    #    replace_dict = _replace_dict_time_dependent_expression(time_dep_expressions, \
    #                                                           time_, dt, 0.)
    #    
    #    # Update time dependent expression
    #    rl_ufl_form = ufl.replace(rl_ufl_form, replace_dict)

    # Get last stage form
    last_stage = Form(rl_ufl_form)

    human_form = "rush larsen 1"

    return ufl_stage_forms, dolfin_stage_forms, last_stage, \
           stage_solutions, dt, dt_stage_offsets, human_form, None

def _butcher_scheme_generator(a, b, c, time, solution, rhs_form):
    """
    Generates a list of forms and solutions for a given Butcher tableau 

    *Arguments*
        a (2 dimensional numpy array)
            The a matrix of the Butcher tableau.
        b (1-2 dimensional numpy array)
            The b vector of the Butcher tableau. If b is 2 dimensional the
            scheme includes an error estimator and can be used in adaptive
            solvers.
        c (1 dimensional numpy array)
            The c vector the Butcher tableau.
        time (_Constant_)
            A Constant holding the time at the start of the time step
        solution (_Function_)
            The prognostic variable
        rhs_form (ufl.Form)
            A UFL form representing the rhs for a time differentiated equation 
    """

    a = _check_abc(a, b, c)
    size = a.shape[0]

    DX = _check_form(rhs_form)

    # Get test function
    arguments = rhs_form.arguments()
    coefficients = rhs_form.coefficients()
    v = arguments[0]

    # Create time step
    dt = Constant(0.1)

    # rhs forms
    dolfin_stage_forms = []
    ufl_stage_forms = []

    # Stage solutions
    k = [Function(solution.function_space(), name="k_%d"%i) for i in range(size)]

    jacobian_indices = []

    # Create the stage forms
    y_ = solution
    time_ = time
    time_dep_expressions = _time_dependent_expressions(rhs_form, time)
    zero_ = ufl.zero(*y_.shape())
    for i, ki in enumerate(k):

        # Check whether the stage is explicit
        explicit = a[i,i] == 0

        # Evaluation arguments for the ith stage
        evalargs = y_ + dt * sum([float(a[i,j]) * k[j] \
                                  for j in range(i+1)], zero_)
        time = time_ + dt*c[i]

        replace_dict = _replace_dict_time_dependent_expression(time_dep_expressions, \
                                                               time_, dt, c[i])

        replace_dict[y_] = evalargs
        replace_dict[time_] = time
        stage_form = ufl.replace(rhs_form, replace_dict)

        if explicit:
            stage_forms = [stage_form]
            jacobian_indices.append(-1)
        else:
            # Create a F=0 form and differentiate it
            stage_form -= ufl.inner(ki, v)*DX
            stage_forms = [stage_form, derivative(stage_form, ki)]
            jacobian_indices.append(0)
        ufl_stage_forms.append(stage_forms)

        dolfin_stage_forms.append([Form(form) for form in stage_forms])

    # Only one last stage
    if len(b.shape) == 1:
        last_stage = Form(ufl.inner(y_+sum([dt*float(bi)*ki for bi, ki in \
                                            zip(b, k)], zero_), v)*DX)
    else:
        # FIXME: Add support for adaptivity in RKSolver and MultiStageScheme
        
        last_stage = [Form(ufl.inner(y_+sum([dt*float(bi)*ki for bi, ki in \
                                             zip(b[0,:], k)], zero_), v)*DX),
                      Form(ufl.inner(y_+sum([dt*float(bi)*ki for bi, ki in \
                                             zip(b[1,:], k)], zero_), v)*DX)]
    
    # Create the Function holding the solution at end of time step
    #k.append(solution.copy())

    # Generate human form of MultiStageScheme
    human_form = []
    for i in range(size):
        kterm = " + ".join("%sh*k_%s" % ("" if a[i,j] == 1.0 else \
                                         "%s*"% a[i,j], j) \
                           for j in range(size) if a[i,j] != 0)
        if c[i] in [0.0, 1.0]:
            cih = " + h" if c[i] == 1.0 else ""
        else:
            cih = " + %s*h" % c[i]

        if len(kterm) == 0:
            human_form.append("k_%(i)s = f(t_n%(cih)s, y_n)" % {"i": i, "cih": cih})
        else:
            human_form.append("k_%(i)s = f(t_n%(cih)s, y_n + %(kterm)s)" % \
                          {"i": i, "cih": cih, "kterm": kterm})

    parentheses = "(%s)" if np.sum(b>0) > 1 else "%s"
    human_form.append("y_{n+1} = y_n + h*" + parentheses % (" + ".join(\
        "%sk_%s" % ("" if b[i] == 1.0 else "%s*" % b[i], i) \
        for i in range(size) if b[i] > 0)))

    human_form = "\n".join(human_form)

    return ufl_stage_forms, dolfin_stage_forms, jacobian_indices, last_stage, \
           k, dt, human_form, None

def _butcher_scheme_generator_tlm(a, b, c, time, solution, rhs_form, perturbation):
    """
    Generates a list of forms and solutions for a given Butcher tableau 

    *Arguments*
        a (2 dimensional numpy array)
            The a matrix of the Butcher tableau.
        b (1-2 dimensional numpy array)
            The b vector of the Butcher tableau. If b is 2 dimensional the
            scheme includes an error estimator and can be used in adaptive
            solvers.
        c (1 dimensional numpy array)
            The c vector the Butcher tableau.
        time (_Constant_)
            A Constant holding the time at the start of the time step
        solution (_Function_)
            The prognostic variable
        rhs_form (ufl.Form)
            A UFL form representing the rhs for a time differentiated equation 
        perturbation (_Function_)
            The perturbation in the initial condition of the solution
    """

    a = _check_abc(a, b, c)
    size = a.shape[0]

    DX = _check_form(rhs_form)

    # Get test function
    arguments = rhs_form.arguments()
    coefficients = rhs_form.coefficients()
    v = arguments[0]

    # Create time step
    dt = Constant(0.1)

    # rhs forms
    dolfin_stage_forms = []
    ufl_stage_forms = []
    
    # Stage solutions
    k = [Function(solution.function_space(), name="k_%d"%i) for i in range(size)]
    kdot = [Function(solution.function_space(), name="kdot_%d"%i) \
            for i in range(size)]

    # Create the stage forms
    y_ = solution
    ydot = solution.copy()
    time_ = time
    time_dep_expressions = _time_dependent_expressions(rhs_form, time)
    zero_ = ufl.zero(*y_.shape())
    forward_forms = []
    stage_solutions = []
    jacobian_indices = []

    for i, ki in enumerate(k):

        # Check whether the stage is explicit
        explicit = a[i,i] == 0

        # Evaluation arguments for the ith stage
        evalargs = y_ + dt * sum([float(a[i,j]) * k[j] \
                                  for j in range(i+1)], zero_)
        time = time_ + dt*c[i]
        
        replace_dict = _replace_dict_time_dependent_expression(time_dep_expressions, \
                                                               time_, dt, c[i])

        replace_dict[y_] = evalargs
        replace_dict[time_] = time
        stage_form = ufl.replace(rhs_form, replace_dict)

        forward_forms.append(stage_form)

        # The recomputation of the forward run:

        if explicit:
            stage_forms = [stage_form]
            jacobian_indices.append(-1)
        else:
            # Create a F=0 form and differentiate it
            stage_form_implicit = stage_form - ufl.inner(ki, v)*DX
            stage_forms = [stage_form_implicit, derivative(stage_form_implicit, ki)]
            jacobian_indices.append(0)

        ufl_stage_forms.append(stage_forms)
        dolfin_stage_forms.append([Form(form) for form in stage_forms])
        stage_solutions.append(ki)

        # And now the tangent linearisation:
        stage_form_tlm = safe_action(derivative(stage_form, y_), perturbation) + \
                         sum([dt*float(a[i,j]) * safe_action(derivative(\
            forward_forms[j], y_), kdot[j]) for j in range(i+1)])
        if explicit:
            stage_forms_tlm = [stage_form_tlm]
            jacobian_indices.append(-1)
        else:
            # Create a F=0 form and differentiate it
            stage_form_tlm -= ufl.inner(kdot[i], v)*DX
            stage_forms_tlm = [stage_form_tlm, derivative(stage_form_tlm, kdot[i])]
            jacobian_indices.append(1)

        ufl_stage_forms.append(stage_forms_tlm)
        dolfin_stage_forms.append([Form(form) for form in stage_forms_tlm])
        stage_solutions.append(kdot[i])
        
    # Only one last stage
    if len(b.shape) == 1:
        last_stage = Form(ufl.inner(perturbation + sum(\
            [dt*float(bi)*kdoti for bi, kdoti in zip(b, kdot)], zero_), v)*DX)
    else:
        raise Exception("Not sure what to do here")
    
    human_form = []
    for i in range(size):
        kterm = " + ".join("%sh*k_%s" % ("" if a[i,j] == 1.0 else \
                                         "%s*"% a[i,j], j) \
                           for j in range(size) if a[i,j] != 0)
        if c[i] in [0.0, 1.0]:
            cih = " + h" if c[i] == 1.0 else ""
        else:
            cih = " + %s*h" % c[i]

        kdotterm = " + ".join("%(a)sh*action(derivative(f(t_n%(cih)s, y_n + "\
                              "%(kterm)s), kdot_%(i)s" % \
                              {"a": ("" if a[i,j] == 1.0 else "%s*"% a[i,j], j),
                               "i": i,
                               "cih": cih,
                               "kterm": kterm} \
                              for j in range(size) if a[i,j] != 0)
            
        if len(kterm) == 0:
            human_form.append("k_%(i)s = f(t_n%(cih)s, y_n)" % {"i": i, "cih": cih})
            human_form.append("kdot_%(i)s = action(derivative("\
                              "f(t_n%(cih)s, y_n), y_n), ydot_n)" % \
                              {"i": i, "cih": cih})
        else:
            human_form.append("k_%(i)s = f(t_n%(cih)s, y_n + %(kterm)s)" % \
                          {"i": i, "cih": cih, "kterm": kterm})
            human_form.append("kdot_%(i)s = action(derivative(f(t_n%(cih)s, "\
                              "y_n + %(kterm)s), y_n) + %(kdotterm)s" % \
                          {"i": i, "cih": cih, "kterm": kterm, "kdotterm": kdotterm})

    parentheses = "(%s)" if np.sum(b>0) > 1 else "%s"
    human_form.append("ydot_{n+1} = ydot_n + h*" + parentheses % (" + ".join(\
        "%skdot_%s" % ("" if b[i] == 1.0 else "%s*" % b[i], i) \
        for i in range(size) if b[i] > 0)))

    human_form = "\n".join(human_form)

    return ufl_stage_forms, dolfin_stage_forms, jacobian_indices, last_stage, \
           stage_solutions, dt, human_form, perturbation

def _butcher_scheme_generator_adm(a, b, c, time, solution, rhs_form, adj):
    """
    Generates a list of forms and solutions for a given Butcher tableau 

    *Arguments*
        a (2 dimensional numpy array)
            The a matrix of the Butcher tableau.
        b (1-2 dimensional numpy array)
            The b vector of the Butcher tableau. If b is 2 dimensional the
            scheme includes an error estimator and can be used in adaptive
            solvers.
        c (1 dimensional numpy array)
            The c vector the Butcher tableau.
        time (_Constant_)
            A Constant holding the time at the start of the time step
        solution (_Function_)
            The prognostic variable
        rhs_form (ufl.Form)
            A UFL form representing the rhs for a time differentiated equation 
        adj (_Function_)
            The derivative of the functional with respect to y_n+1
    """

    a = _check_abc(a, b, c)
    size = a.shape[0]

    DX = _check_form(rhs_form)

    # Get test function
    arguments = rhs_form.arguments()
    coefficients = rhs_form.coefficients()
    v = arguments[0]

    # Create time step
    dt = Constant(0.1)

    # rhs forms
    dolfin_stage_forms = []
    ufl_stage_forms = []
    
    # Stage solutions
    k = [Function(solution.function_space(), name="k_%d"%i) for i in range(size)]
    kbar = [Function(solution.function_space(), name="kbar_%d"%i) \
            for i in range(size)]

    # Create the stage forms
    y_ = solution
    ydot = solution.copy()
    time_ = time
    time_dep_expressions = _time_dependent_expressions(rhs_form, time)
    zero_ = ufl.zero(*y_.shape())
    forward_forms = []
    stage_solutions = []
    jacobian_indices = []

    # The recomputation of the forward run:
    for i, ki in enumerate(k):

        # Check whether the stage is explicit
        explicit = a[i,i] == 0

        # Evaluation arguments for the ith stage
        evalargs = y_ + dt * sum([float(a[i,j]) * k[j] \
                                  for j in range(i+1)], zero_)
        time = time_ + dt*c[i]
        
        replace_dict = _replace_dict_time_dependent_expression(\
            time_dep_expressions, time_, dt, c[i])

        replace_dict[y_] = evalargs
        replace_dict[time_] = time
        stage_form = ufl.replace(rhs_form, replace_dict)

        forward_forms.append(stage_form)

        if explicit:
            stage_forms = [stage_form]
            jacobian_indices.append(-1)
        else:
            # Create a F=0 form and differentiate it
            stage_form_implicit = stage_form - ufl.inner(ki, v)*DX
            stage_forms = [stage_form_implicit, derivative(\
                stage_form_implicit, ki)]
            jacobian_indices.append(0)

        ufl_stage_forms.append(stage_forms)
        dolfin_stage_forms.append([Form(form) for form in stage_forms])
        stage_solutions.append(ki)

    for i, kbari in reversed(list(enumerate(kbar))):

        # Check whether the stage is explicit
        explicit = a[i,i] == 0

        # And now the adjoint linearisation:
        stage_form_adm = ufl.inner(dt * b[i] * adj, v)*DX  + sum(\
            [dt * float(a[j,i]) * safe_action(safe_adjoint(derivative(\
                forward_forms[j], y_)), kbar[j]) for j in range(i, size)])
        if explicit:
            stage_forms_adm = [stage_form_adm]
            jacobian_indices.append(-1)
        else:
            # Create a F=0 form and differentiate it
            stage_form_adm -= ufl.inner(kbar[i], v)*DX
            stage_forms_adm = [stage_form_adm, derivative(stage_form_adm, kbari)]
            jacobian_indices.append(1)

        ufl_stage_forms.append(stage_forms_adm)
        dolfin_stage_forms.append([Form(form) for form in stage_forms_adm])
        stage_solutions.append(kbari)
        
    # Only one last stage
    if len(b.shape) == 1:
        last_stage = Form(ufl.inner(adj, v)*DX + sum(\
            [safe_action(safe_adjoint(derivative(forward_forms[i], y_)), kbar[i]) \
             for i in range(size)]))
    else:
        raise Exception("Not sure what to do here")
    
    human_form = "unimplemented"

    return ufl_stage_forms, dolfin_stage_forms, jacobian_indices, last_stage,\
           stage_solutions, dt, human_form, adj
    
class MultiStageScheme(cpp.MultiStageScheme):
    """
    Base class for all MultiStageSchemes
    """
    def __init__(self, rhs_form, ufl_stage_forms,
                 dolfin_stage_forms, last_stage, stage_solutions,
                 solution, time, dt, dt_stage_offsets, jacobian_indices, order,
                 name, human_form, bcs, contraction=None):

        # Store Python data
        self._rhs_form = rhs_form
        self._ufl_stage_forms = ufl_stage_forms
        self._dolfin_stage_forms = dolfin_stage_forms
        self._t = time
        self._bcs = bcs
        self._dt = dt
        self._last_stage = last_stage
        self._solution = solution
        self._stage_solutions = stage_solutions
        self._order = order
        self.jacobian_indices = jacobian_indices
        self.contraction = contraction

        # Pass args to C++ constructor
        cpp.MultiStageScheme.__init__(self, dolfin_stage_forms, last_stage, \
                                      stage_solutions, solution, time, dt,
                                      dt_stage_offsets, jacobian_indices, order,\
                                      self.__class__.__name__,
                                      human_form, bcs)

    def rhs_form(self):
        "Return the original rhs form"
        return self._rhs_form

    def ufl_stage_forms(self):
        "Return the ufl stage forms"
        return self._ufl_stage_forms

    def dolfin_stage_forms(self):
        "Return the dolfin stage forms"
        return self._dolfin_stage_forms

    def t(self):
        "Return the Constant used to describe time in the MultiStageScheme"
        return self._t

    def dt(self):
        "Return the Constant used to describe time in the MultiStageScheme"
        return self._dt

    def solution(self):
        "Return the solution Function"
        return self._solution

    def last_stage(self):
        "Return the form describing the last stage"
        return self._last_stage

    def stage_solutions(self):
        "Return the stage solutions"
        return self._stage_solutions
    def to_tlm(self, perturbation):
        raise NotImplementedError("'to_tlm:' implement in derived classes")

    def to_adm(self, perturbation):
        raise NotImplementedError("'to_adm:' implement in derived classes")

class ButcherMultiStageScheme(MultiStageScheme):
    """
    Base class for all MultiStageSchemes
    """
    def __init__(self, rhs_form, solution, time, bcs, a, b, c, order, \
                 generator=_butcher_scheme_generator):
        bcs = bcs or []
        time = time or Constant(0.0)
        ufl_stage_forms, dolfin_stage_forms, jacobian_indices, last_stage, \
                         stage_solutions, dt, human_form, contraction = \
                         generator(a, b, c, time, solution, rhs_form)

        # Store data
        self.a = a
        self.b = b
        self.c = c

        MultiStageScheme.__init__(self, rhs_form, ufl_stage_forms,
                                  dolfin_stage_forms, last_stage,
                                  stage_solutions, solution, time, dt,
                                  c, jacobian_indices, order,\
                                  self.__class__.__name__, human_form,
                                  bcs, contraction)

    def to_tlm(self, perturbation):
        r"""
        Return another MultiStageScheme that implements the tangent
        linearisation of the ODE solver.

        This takes \dot{y_n} (the derivative of y_n with respect to a
        parameter) and computes \dot{y_n+1} (the derivative of y_n+1
        with respect to that parameter).
        """

        generator = functools.partial(_butcher_scheme_generator_tlm, \
                                      perturbation=perturbation)
        new_solution = self._solution.copy()
        new_form = ufl.replace(self._rhs_form, {self._solution: new_solution})
        return ButcherMultiStageScheme(new_form, new_solution, self._t, self._bcs, 
                                       self.a, self.b, self.c, self._order,
                                       generator=generator)
        
    def to_adm(self, adj):
        r"""
        Return another MultiStageScheme that implements the adjoint
        linearisation of the ODE solver.

        This takes \bar{y_n+1} (the derivative of a functional J with
        respect to y_n+1) and computes \bar{y_n} (the derivative of J
        with respect to y_n).
        """

        generator = functools.partial(_butcher_scheme_generator_adm, adj=adj)
        new_solution = self._solution.copy()
        new_form = ufl.replace(self._rhs_form, {self._solution: new_solution})
        return ButcherMultiStageScheme(new_form, new_solution, self._t, self._bcs, 
                                       self.a, self.b, self.c, self._order,
                                       generator=generator)

class RushLarsenScheme(MultiStageScheme):
    def __init__(self, rhs_form, solution, linear_terms, time, order,
                 generator=_rush_larsen_scheme_generator):

        # FIXME: What with bcs?
        bcs = []
        time = time or Constant(0.0)
        if order not in [1,2]:
            raise ValueError("Expected order to be either 1 or 2")

        ufl_stage_forms, dofin_stage_forms, last_stage, stage_solutions, \
                         dt, dt_stage_offsets, human_form, contraction = \
                         generator(rhs_form, solution, linear_terms, time, order)

        # All stages are explicit
        jacobian_indices = [-1 for _ in stage_solutions]

        # Highjack a and b to hold parameters for RushLarsen scheme generation
        MultiStageScheme.__init__(self, rhs_form, ufl_stage_forms,
                                  dofin_stage_forms, last_stage, stage_solutions,
                                  solution, time, dt, dt_stage_offsets, jacobian_indices,
                                  order, self.__class__.__name__, human_form,
                                  bcs, contraction)
    
class RL1(RushLarsenScheme):
    """
    First order Rush Larsen Scheme
    """
    def __init__(self, rhs_form, solution, t=None, linear_terms=None):
        order = 1
        RushLarsenScheme.__init__(self, rhs_form, solution, linear_terms, \
                                  t, order)
        
#class RL2(RushLarsenScheme):
#    """
#    Second order Rush Larsen Scheme
#    """
#    def __init__(self, rhs_form, solution, t=None):
#        order = 2
#        RushLarsenScheme.__init__(self, rhs_form, solution, t, order, generalized=False)
#        
#class GRL1(RushLarsenScheme):
#    """
#    First order generalized Rush Larsen Scheme
#    """
#    def __init__(self, rhs_form, solution, t=None):
#        order = 1
#        RushLarsenScheme.__init__(self, rhs_form, solution, t, order, generalized=True)
#        
#class GRL2(RushLarsenScheme):
#    """
#    Second order generalized Rush Larsen Scheme
#    """
#    def __init__(self, rhs_form, solution, t=None):
#        order = 2
#        RushLarsenScheme.__init__(self, rhs_form, solution, t, order, generalized=True)
        
class ERK1(ButcherMultiStageScheme):
    """
    Explicit first order Scheme
    """
    def __init__(self, rhs_form, solution, t=None, bcs=None):
        a = np.array([0.])
        b = np.array([1.])
        c = np.array([0.])
        ButcherMultiStageScheme.__init__(self, rhs_form, solution, t, bcs, a, b, c, 1)

class BDF1(ButcherMultiStageScheme):
    """
    Implicit first order scheme
    """
    def __init__(self, rhs_form, solution, t=None, bcs=None):
        a = np.array([1.])
        b = np.array([1.])
        c = np.array([1.])
        ButcherMultiStageScheme.__init__(self, rhs_form, solution, t, bcs, a, b, c, 1)

class ExplicitMidPoint(ButcherMultiStageScheme):
    """
    Explicit 2nd order scheme
    """
    def __init__(self, rhs_form, solution, t=None, bcs=None):

        a = np.array([[0, 0],[0.5, 0.0]])
        b = np.array([0., 1])
        c = np.array([0, 0.5])
        ButcherMultiStageScheme.__init__(self, rhs_form, solution, t, bcs, a, b, c, 2)

class CN2(ButcherMultiStageScheme):
    """
    Semi-implicit 2nd order scheme
    """
    def __init__(self, rhs_form, solution, t=None, bcs=None):
        a = np.array([[0, 0],[0.5, 0.5]])
        b = np.array([0.5, 0.5])
        c = np.array([0, 1.0])

        ButcherMultiStageScheme.__init__(self, rhs_form, solution, t, bcs, a, b, c, 2)

class ERK4(ButcherMultiStageScheme):
    """
    Explicit 4th order scheme
    """
    def __init__(self, rhs_form, solution, t=None, bcs=None):
        a = np.array([[0, 0, 0, 0],
                      [0.5, 0, 0, 0],
                      [0, 0.5, 0, 0],
                      [0, 0, 1, 0]])
        b = np.array([1./6, 1./3, 1./3, 1./6])
        c = np.array([0, 0.5, 0.5, 1])
        ButcherMultiStageScheme.__init__(self, rhs_form, solution, t, bcs, a, b, c, 4)


class ESDIRK3(ButcherMultiStageScheme):
    """
    Explicit implicit 3rd order scheme
    """
    def __init__(self, rhs_form, solution, t=None, bcs=None):
        a = np.array([[0,                   0,                   0,                   0 ],
                      [0.435866521500000,   0.435866521500000,   0,                   0 ],
                      [0.490563388419108,   0.073570090080892,   0.435866521500000,   0 ],
                      [0.308809969973036,   1.490563388254108,  -1.235239879727145,   0.435866521500000 ]])
        b = a[-1,:].copy()
        c = a.sum(1)
        ButcherMultiStageScheme.__init__(self, rhs_form, solution, t, bcs, a, b, c, 3)
                     
class ESDIRK4(ButcherMultiStageScheme):
    """
    Explicit implicit 4rd order scheme
    """
    def __init__(self, rhs_form, solution, t=None, bcs=None):
        a = np.array([[0,                  0,                 0,                  0,                   0],
                      [0.435866521500000,  0.4358665215,      0,                  0,                   0                   ],
                      [0.140737774731968, -0.108365551378832, 0.435866521500000,  0,                   0                   ],
                      [0.102399400616089, -0.376878452267324, 0.838612530151233,  0.435866521500000,   0                   ],
                      [0.157024897860995,  0.117330441357768, 0.616678030391680, -0.326899891110444,   0.435866521500000   ]])

        b = a[-1,:].copy()
        c = a.sum(1)
        ButcherMultiStageScheme.__init__(self, rhs_form, solution, t, bcs, a, b, c, 4)

# Aliases
CrankNicolson = CN2
ExplicitEuler = ERK1
ForwardEuler = ERK1
ImplicitEuler = BDF1
BackwardEuler = BDF1
ERK = ERK1
RK4 = ERK4

__all__ = [name for name, attr in list(globals().items()) \
           if isinstance(attr, type) and issubclass(attr, MultiStageScheme)]

__all__.append("MultiStageScheme")
