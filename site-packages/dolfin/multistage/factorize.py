from ufl import *
from ufl.corealg.multifunction import MultiFunction
from ufl.corealg.map_dag import map_expr_dag
from ufl.classes import Argument, MultiIndex, Indexed, FixedIndex
from ufl.log import error

__all__ = ["extract_tested_expressions"]

class ScalarFactorizer(MultiFunction):
    def __init__(self):
        MultiFunction.__init__(self)
        self._one = as_ufl(1.0)
        self._arg = None

    def _argument(self, component, expr):
        if self._arg is None:
            self._arg = expr
        elif self._arg is not expr:
            error("Expecting only one Argument in this algorithm implementation.")
        return { component: self._one }

    def argument(self, e):
        if e.ufl_shape != ():
            error("Nonscalar argument {}.".format(str(e)))
        return self._argument(0, e)

    def terminal(self, t):
        if t.ufl_shape != ():
            error("Nonscalar terminal {}.".format(str(t)))
        return t

    def indexed(self, e):
        if e.ufl_shape != ():
            error("Nonscalar indexed {}.".format(str(e)))

        v, i = e.operands()

        if v._ufl_typecode_ == Argument._ufl_typecode_:
            if len(i) != 1 or not isinstance(i[0], FixedIndex):
                error("Expecting only vector valued Arguments in this algorithm implementation.")
            return self._argument(int(i[0]), v)

        return e

    def operator(self, e, *ops):
        if e.ufl_shape != ():
            error("Nonscalar operator {}.".format(str(e)))
        if any(isinstance(op, dict) for op in ops):
            error("Handler for operator {} assumes no Arguments among operands.".format(e._ufl_handler_name_))
        return e

    def sum(self, e, a, b):
        n_a = len(a) if isinstance(a, dict) else 0
        n_b = len(b) if isinstance(b, dict) else 0
        if n_a > 0 and n_b > 0:
            c = {}
            keys = set(a.keys()) | set(b.keys())
            for k in keys:
                av = a.get(k)
                bv = b.get(k)
                if av is None:
                    # Case: Only b contains a term with test function component k
                    c[k] = bv
                elif bv is None:
                    # Case: Only a contains a term with test function component k
                    c[k] = av
                else:
                    # Case: Both a and b contains a term with test function component k
                    c[k] = av + bv
            return c
        elif n_a or n_b:
            error("Cannot add Argument-dependent expression with non-Argument-dependent expression.")
        else:
            return e

    def product(self, e, a, b):
        a_is_dict = isinstance(a, dict)
        b_is_dict = isinstance(b, dict)
        if a_is_dict and b_is_dict:
            error("Expecting only one Argument in this algorithm. Products of Arguments are not allowed.")
        elif a_is_dict:
            c = {}
            for k,v in a.items():
                c[k] = v*b
            return c
        elif b_is_dict:
            c = {}
            for k,v in b.items():
                c[k] = v*a
            return c
        else:
            return e

    def division(self, e, a, b):
        if isinstance(b, dict):
            error("Cannot divide by Arguments.")
        if isinstance(a, dict):
            c = {}
            for k,v in a.items():
                c[k] = v / b
            return c
        else:
            return e


def extract_tested_expressions(expr):
    func = ScalarFactorizer()
    e = map_expr_dag(func, expr, compress=False)
    return e, func._arg

if __name__ == "__main__":

    U = FiniteElement("CG", triangle, 1)
    V = VectorElement("CG", triangle, 1)

    v = TestFunction(V)

    expressions = [
        # Terminals and indexed terminals
        as_ufl(0.0),
        SpatialCoordinate(triangle)[0],
        Coefficient(U),
        Coefficient(V)[0],
        # Operators without arguments:
        SpatialCoordinate(triangle)[1] + as_ufl(1.0),
        cos(SpatialCoordinate(triangle)[1]),
        abs(Coefficient(U)),
        exp(Coefficient(V)[1]),
        Coefficient(U) * SpatialCoordinate(triangle)[1],
        Coefficient(U) / SpatialCoordinate(triangle)[1],
        Coefficient(U) + SpatialCoordinate(triangle)[1],
        # Test functions and indexed test functions:
        TestFunction(U),
        TestFunction(V)[0],
        TestFunction(V)[1],
        # Operators applied to arguments:
        2*TestFunction(U),
        2*TestFunction(V)[0],
        2*TestFunction(V)[1],
        TestFunction(U)/5,
        TestFunction(V)[0]/5,
        TestFunction(V)[1]/5,
        sin(SpatialCoordinate(triangle)[1])*TestFunction(U)/5,
        v[0]/4 + v[0]/5,
        v[0]/4 + v[1]/5,
        ]

    errors = [
        # Nonscalar
        SpatialCoordinate(triangle),
        TestFunction(V),
        # Adding test function and other expression
        TestFunction(U) + 1.0,
        # Multiplying test functions:
        TestFunction(U) * TestFunction(U),
        TestFunction(U) * TestFunction(V)[0],
        # Nonlinear operator applied to test function
        sin(TestFunction(U)),
        sin(TestFunction(V)[1]),
        ]

    from ufl.classes import Sum, Operator, Expr, Argument

    for expr in expressions:
        func = ScalarFactorizer()

        e = map_expr_dag(func, expr, compress=False)
        print
        if isinstance(e, dict):
            print str(expr), " = ", ",  ".join("%s[%d]: %s" % (func._arg, k, e[k]) for k in e)
        else:
            assert expr == e
            print str(expr), " = ", str(e)


    for expr in errors:
        func = ScalarFactorizer()
        try:
            e = map_expr_dag(func, expr, compress=False)
            ok = False
        except:
            ok = True
        assert ok
