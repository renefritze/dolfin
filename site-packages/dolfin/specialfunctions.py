# -*- coding: utf-8 -*-
"""This module defines some special functions (originally defined in
SpecialFunctions.h) like MeshSize and FacetNormal."""

__author__ = "Anders Logg (logg@simula.no)"
__date__ = "2008-12-08 -- 2009-03-11"
__copyright__ = "Copyright (C) 2008-2009 Anders Logg"
__license__  = "GNU LGPL Version 2.1"

__all__ = ["MeshCoordinates", "FacetNormal", "CellSize", "FacetArea", 
           "SUPGStabilizer"]

# Import UFL and SWIG-generated extension module (DOLFIN C++)
import ufl
import cpp

# Local imports
from functionspace import dim2domain, FunctionSpaceBase
from function import Function

class MeshCoordinates(ufl.Function, cpp.MeshCoordinates, Function):
    def __init__(self, mesh):
        "Create function that evaluates to the mesh coordinates at each vertex."

        domain = dim2domain[mesh.topology().dim()]
        element = ufl.VectorElement("Lagrange", domain, 1)

        self._V = FunctionSpaceBase(mesh, element)

        ufl.Function.__init__(self, element)
        cpp.MeshCoordinates.__init__(self, self._V)

    def function_space(self):
        " Return the function space."
        return self._V

    def __str__(self):
        return "<Function in %s>" % str(self._V)
    
    def __repr__(self):
        return ufl.Function.__repr__(self)

class FacetNormal(ufl.Function, cpp.FacetNormal, Function):

    def __init__(self, mesh):
        "Create function that evaluates to the facet normal on each facet."

        domain = dim2domain[mesh.topology().dim()]
        element = ufl.VectorElement("Discontinuous Lagrange", domain, 0)

        self._V = FunctionSpaceBase(mesh, element)
        
        ufl.Function.__init__(self, element)
        cpp.FacetNormal.__init__(self, self._V)

    def function_space(self):
        " Return the function space."
        return self._V

    def __str__(self):
        return "<Function in %s>" % str(self._V)
    
    def __repr__(self):
        return ufl.Function.__repr__(self)


class CellSize(ufl.Function, cpp.CellSize, Function):
    def __init__(self, mesh):
        "Create function that evaluates to the local cell size."

        domain = dim2domain[mesh.topology().dim()]
        element = ufl.FiniteElement("Discontinuous Lagrange", domain, 0)

        self._V = FunctionSpaceBase(mesh, element)

        ufl.Function.__init__(self, element)
        cpp.CellSize.__init__(self, self._V)

    def function_space(self):
        " Return the function space."
        return self._V

    def __str__(self):
        return "<Function in %s>" % str(self._V)
    
    def __repr__(self):
        return ufl.Function.__repr__(self)


class FacetArea(ufl.Function, cpp.FacetArea, Function):

    def __init__(self, mesh):
        "Create function that evaluates to the facet area/length on each facet."

        domain = dim2domain[mesh.topology().dim()]
        element = ufl.FiniteElement("Discontinuous Lagrange", domain, 0)

        self._V = FunctionSpaceBase(mesh, element)

        ufl.Function.__init__(self, element)
        cpp.FacetArea.__init__(self, self._V)

    def function_space(self):
        " Return the function space."
        return self._V

    def __str__(self):
        return "<Function in %s>" % str(self._V)
    
    def __repr__(self):
        return ufl.Function.__repr__(self)


class SUPGStabilizer(ufl.Function, cpp.SUPGStabilizer, Function):
    def __init__(self, field, sigma=1.0):
        """ Creates a Streamline Petrov-Galerkin stabilizing function
        
        Given the advective field a, this function computes the stabilizing factor
       
                  s = h*tau*a/(2*|a|)
       
        where h is the local size of the mesh, tau the local stabilizing factor
        calculated from the local PÃ©clet number, a the advective field.
        
        @param field : The field driving the advection
        @param sigma : The diffusion coefficient defaults to 1.0
                       
        """
        assert isinstance(field,cpp.Function), "Provide a cpp.Function for 'field'"
        assert isinstance(field,ufl.Function), "Provide a ufl.Function for 'field'"
        assert isinstance(sigma,(float,int)),  "Provide a scalar for 'sigma'"
        
        mesh = field.function_space().mesh() 
        
        domain = dim2domain[mesh.topology().dim()]
        element = ufl.VectorElement("Discontinuous Lagrange", domain, 0)
        
        self._V = FunctionSpaceBase(mesh, element)
        
        ufl.Function.__init__(self, element)
        cpp.SUPGStabilizer.__init__(self, self._V, field, sigma)
    
    def function_space(self):
        " Return the function space."
        return self._V

    def __str__(self):
        return "<Function in %s>" % str(self._V)
    
    def __repr__(self):
        return ufl.Function.__repr__(self)

