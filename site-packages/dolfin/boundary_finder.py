
# Copyright (C) 2008 Kent-Andre Mardal 
# Licensed under the GNU LGPL Version 2.1


from dolfin import *


def create_maps(boundary_mesh): 

    c2v = {}
    v2c = {}
    for cell in cells(boundary_mesh):
    #    print cell.index()
        for vertex in vertices(cell):
    #        print " ", vertex.index()
            v = vertex.index() 
            c = cell.index() 
            if c2v.has_key(c): 
    #            print c2v[c]
                c2v[c].append(v)
            else:
                c2v[c] = [v]
            if v2c.has_key(v): 
                v2c[v].append(c)
            else:
                v2c[v] = [c]
    return v2c, c2v 


def find_subdomain(start_vertex, v2c, c2v):
#    start = v2c.keys()[0]
    next  = c2v[v2c[start_vertex][0]][1]

    done = False
    previous_vertex = start_vertex
    previous_cell   = v2c[start_vertex][0] 
    subdomain = {} 
    while not done:  
#        print "previous vertex", previous_vertex
#        print "previous cell", previous_cell
        c0, c1 = v2c[previous_vertex] 
#        print "c0 ", c0, " c1 ", c1
        if c0 == previous_cell: 
            next_cell = c1
        elif c1 == previous_cell:
            next_cell = c0
        else: 
            print "None of the vertices were the previous vertex ??"
#        print "next cell ", next_cell 
        v0, v1 = c2v[next_cell]
#        print "v0 ", v0
#        print "v1 ", v1
        if v0 == previous_vertex: 
            next_vertex = v1
        elif v1 == previous_vertex:
            next_vertex = v0
        else: 
            print "None of the vertices were the previous vertex ??"
        if subdomain.has_key(next_cell): 
            print "Found one subdomain " 
            done = True
        else: 
            subdomain[next_cell] = True 
            previous_vertex = next_vertex
            previous_cell   = next_cell
    return subdomain

def find_new_cell_key(c2v, keys): 
    done = False 
    iter = c2v.keys().__iter__()
    while not done: 
        key = iter.next() 
#        print "key ", key 
        if key in keys: 
            pass
        else:
            done = True
    return key



    

mesh = Mesh("slice2d_h.1.xml.gz")
boundary_mesh = BoundaryMesh(mesh)

boundary_cell_map = boundary_mesh.data().meshFunction("cell map")


v2c, c2v = create_maps(boundary_mesh)

print " v2c ", v2c  
print " c2v ", c2v  

subdomain = find_subdomain(0, v2c, c2v) 
keys0 = subdomain.keys(); keys0.sort()
print "subdomain 0 ", keys0 

new_cell_key = find_new_cell_key(c2v, keys0)
vertex_key = c2v[new_cell_key][0] 
subdomain = find_subdomain(vertex_key, v2c, c2v) 
keys1 = subdomain.keys(); keys1.sort()
print "subdomain 1 ", keys1 

new_cell_key = find_new_cell_key(c2v, keys0+keys1)
print "new ", new_cell_key
vertex_key = c2v[new_cell_key][0] 
subdomain = find_subdomain(vertex_key, v2c, c2v) 
keys2 = subdomain.keys(); keys2.sort()
print "subdomain 2 ", keys2 

subdomains = {}
for i in range(0, mesh.numFacets()): 
    subdomains[i] = 3
for key in keys0: 
    subdomains[boundary_cell_map.values()[key]] = 0 
for key in keys1: 
    subdomains[boundary_cell_map.values()[key]] = 1 
for key in keys2: 
    subdomains[boundary_cell_map.values()[key]] = 2 

print subdomains 

str = """ 
<?xml version="1.0" encoding="UTF-8"?>
<dolfin xmlns:dolfin="http://www.fenics.org/dolfin/">
  <meshfunction type="uint" dim="1" size="%d">
""" % mesh.numFacets()

for key in subdomains.keys(): 
    str += "  <entity index=\"%d\" value=\"%d\"/>\n" % (key, subdomains[key])
str +=  """
</meshfunction>
</dolfin>
"""

f = open("subdomains.xml", 'w')
f.write(str)
f.close()


#print boundary_cell_map.values() 




"""
new_cell_key = find_new_cell_key(c2v, keys0+keys1+keys2)
print "new ", new_cell_key
vertex_key = c2v[new_cell_key][0] 
subdomain = find_subdomain(vertex_key, v2c, c2v) 
keys3 = subdomain.keys(); keys3.sort()
print "subdomain 3 ", keys3 
"""





