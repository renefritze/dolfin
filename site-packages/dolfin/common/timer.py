# -*- coding: utf-8 -*-
# Copyright (C) 2017 Jan Blechta
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function
import functools

from dolfin import cpp

__all__ = ["Timer", "timed"]


class Timer(cpp.Timer):
    """A timer can be used for timing tasks. The basic usage is::

	with Timer("Some costly operation"):
            costly_call_1()
            costly_call_2()

    or::

	with Timer() as t:
            costly_call_1()
            costly_call_2()
	    print("Ellapsed time so far: %s" % t.elapsed()[0])

    The timer is started when entering context manager and timing
    ends when exiting it. It is also possible to start and stop a
    timer explicitly by::

      t.start()
      t.stop()

    Timings are stored globally and a summary may be printed
    by calling::

      list_timings(TimingClear_keep, [TimingType_user, TimingType_wall])
    """
    # Enable context manager
    def __enter__(self):
        self.start()
        return self
    def __exit__(self, *args):
        self.stop()


def timed(arg=None):
    """Decorator for timing functions. Can be used in three
    ways::

        @timed
        costly_func(foo, bar=None):
            # Do something costly

        @timed()
        costly_func(foo, bar=None):
            # Do something costly

        @timed('very_expensive_computation')
        costly_func(foo, bar=None):
            # Do something costly

    In first two cases task name is figured out from a module
    name and function name. In the last case task name is
    given as ``'very_expensive_computation'``. The timing
    can then be retrieved by functions ``timing``, ``timings``,
    ``list_timings``, ``dump_timings_to_xml``, etc.

    Developer's note: don't use first two versions in the library
    internals.
    """

    # Decide what the argument means
    if callable(arg):
        # Already decorating
        func = arg
        task = None
    else:
        # Creating decorator
        func = None
        task = arg

    # Define decorator
    def decorator(func):
        # Figure out task description form function name if not given
        # FIXME: This is not good for member methods!
        _task = task or ".".join((func.__module__, func.__name__))

        # Wrap the function with Timer context manager
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            with Timer(_task):
                return func(*args, **kwargs)
        return wrapper

    if func is None:
        # Return the decorator
        return decorator
    else:
        # Return decorated function
        return decorator(func)
