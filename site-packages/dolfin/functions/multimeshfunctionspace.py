# -*- coding: utf-8 -*-
"""
This module contains functionality for multimesh function spaces in particular
discrete function spaces defined over meshes in terms of finite
elements.
"""

# Copyright (C) 2017 JÃ¸rgen S. Dokken
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.

__all__ = ["MultiMeshFunctionSpace"]


class MultiMeshFunctionSpace(cpp.MultiMeshFunctionSpace):
    def __init__(self, *args, **kwargs):
    """Create multimesh finite element function space.

    *Arguments*
        multimesh
            a :py:class:`MultiMesh <dolfin.cpp.MultiMesh>`.
        family
            a string specifying the element family,
            see :py:class:`FunctionSpace
            <dolfin.functions.functionspace.FunctionSpace>`
            for alternatives.

            This argument may also be a `FiniteElement`, in
            which case the `degree` argument should not be
            specified.
        degree
            the degree of the element.

    *Example of usage*

        .. code-block:: python

            V = MultiMeshFunctionSpace(mesh, "CG", 1)

            element = FiniteElement("Lagrange", triangle, 1)
            V = MultiMeshFunctionSpace(mesh, element)
    """
    if len(args)==2:
        self.__init_from_ufl(*args, **kwargs)
    elif len(args)==3:
        self._init_convenience(*args, **kwargs)
    else:
        raise NotImplementedError

    def _init_from_ufl(self, mesh, element):
        self.info = [element]
        if not isinstance(element, ufl.FiniteElementBase):
            cpp.dolfin_error("multimeshfunctionspace.py",
                             "create function space",
                             "Illegal argument, not a finite element: "
                             + str(element))

        # Create and add individual function spaces
        V = cpp.MultiMeshFunctionSpace(multimesh)
        V_parts = []
        for part in range(multimesh.num_parts()):
            V_part = FunctionSpace(multimesh.part(part), element)
            V_parts.append(V_part)
            V.add(V_part)

        # Build multimesh function space
        V.build()

        # Store full function spaces
        V._parts = V_parts


    def _init_convenience(self, mesh, family, degree):
        # Check arguments
        self.info = [familiy, degree]
        if not isinstance(family, string_types):
            cpp.dolfin_error("multimeshfunctionspace.py",
                             "create function space",
                             "Illegal argument for finite element family, not a string: " + str(family))
        if not isinstance(degree, int):
            cpp.dolfin_error("multimeshfunctionspace.py",
                             "create function space",
                             "Illegal argument for degree, not an integer: "
                             + str(degree))
        if not isinstance(multimesh, cpp.MultiMesh):
            cpp.dolfin_error("functionspace.py",
                             "create multimesh function space",
                             "Illegal argument, not a multimesh: " + str(multimesh))

        # Create UFL element
        mesh = multimesh.part(0)
        element = ufl.FiniteElement(family, mesh.ufl_cell(), degree)

        # Create and add individual function spaces
        V = cpp.MultiMeshFunctionSpace(multimesh)
        V_parts = []
        for part in range(multimesh.num_parts()):
            V_part = FunctionSpace(multimesh.part(part), element)
            V_parts.append(V_part)
            V.add(V_part)

        # Build multimesh function space
        V.build()
        
        # Store full function spaces
        V._parts = V_parts
        return V
