"""This module provides functionality for form assembly in Python,
corresponding to the C++ assembly and PDE classes.

The C++ assemble function (renamed to cpp_assemble) is wrapped with
an additional preprocessing step where code is generated using the
FFC JIT compiler.

The C++ PDE classes are reimplemented in Python since the C++ classes
rely on the dolfin::Form class which is not used on the Python side."""

__author__ = "Anders Logg (logg@simula.no)"
__date__ = "2007-08-15 -- 2008-08-06"
__copyright__ = "Copyright (C) 2007-2008 Anders Logg"
__license__  = "GNU LGPL Version 2.1"

# Modified by Martin Sandve Alnaes, 2008
# Modified by Johan Hake, 2008
# Modified by Garth N. Wells, 2008

__all__ = ["assemble", "jit"]#, "assemble_system"]

import ffc

from dolfin import (Matrix, Vector, dolfin_get, dolfin_set, dolfin_add,
                    cpp_Function, cpp_FunctionSpace, cpp_assemble, Form, 
                    STLVectorFunctionSpacePtr, STLVectorFunctionPtr)

#from compile_functions import compile_functions

# Cache for tensors
_tensor_cache = {}

# Temporary storage of compiled coefficient functions avoiding
# Python deleting our function objects before assembly!
_compiled_coefficients = []

# Add a parameter for form compiler
dolfin_add("form compiler", "ffc")

# JIT assembler
def assemble(form, coefficients=None, test_spaces=None, cell_domains=None, 
    exterior_facet_domains=None, interior_facet_domains=None, reset_tensor=None,
    tensor=None, backend=None, form_compiler_options=None):
    """ Assemble form and return tensor
    
    Based on the form that is provided, a tensor is assembled and returned. The
    form can either be a ffc form or a precompiled ufc form.

    If a precompiled or 'pure' ffc form is handed, then coefficients and
    test_spaces have to be provided too. The coefficient functions are provided
    in a 'dict' using the ffc functions as keys. The test spaces are provided
    either in a list where the number of test spaces must correspond to the
    number of bsis functions in the form, or as a single argument, implying that
    the same FunctionSpace is used for all test/trial spaces.
    
    If the form defines integrals over different subdomains, MeshFunctions of the
    corresponding topological entity defining the subdomains, can be provided.

    The returned tensor will be of the same type as the default linear algebra
    backend. This can be set aside by providing a different backend.
    
    The function will create a new tensor. If tensor is provide this will be used
    instead, and if 'reset_tensor' is set to True, the provided tensor will not
    be reseted.

    Form compiler specific options can be provided by 'form_compiler_options'.
    """

    # Check if we need to compile the form (JIT)
    if not hasattr(form, "create_cell_integral"):
        # FFC form, call JIT compile
        (compiled_form, module, form_data) = jit(form, form_compiler_options)
    else:    
        # UFC form, no need to compile
        compiled_form = form
        form_data     = None

    # Get the dolfin::Form
    dolfin_form = get_dolfin_form(compiled_form, form_data, coefficients, test_spaces)
    
    # Create tensor
    rank = compiled_form.rank()
    (tensor, reset_tensor) = _create_tensor(form, rank, backend, tensor, reset_tensor)

    # Set default value for reset_tensor if not specified
    if reset_tensor is None:
        reset_tensor = True

    # Assemble tensor from compiled form
    cpp_assemble(tensor, dolfin_form,cell_domains, exterior_facet_domains, \
                 interior_facet_domains, reset_tensor)

    # Clear any temporary stored coeffisient functions
    _clear_compiled_coefficients()
    
    # Convert to float for scalars
    if rank == 0:
        tensor = tensor.getval()
    
    # Return value
    return tensor

# JIT system assembler
def assemble_system(A_form, b_form, bcs, mesh, x0=None, A_coefficients=None, b_coefficients=None, A_dof_maps=None, b_dof_maps=None,
    cell_domains=None, exterior_facet_domains=None, interior_facet_domains=None, reset_tensor=None,
    A_tensor=None, b_tensor=None, backend=None, return_dofmaps=False, form_compiler_options=None):
    "Assemble form over mesh and return tensor"

    return NotImplemented
    # Check if we need to compile the A_form (JIT)
    if not hasattr(A_form, "create_cell_integral"):
        # FFC form, call JIT compile
        (A_compiled_form, module, A_form_data) = jit(A_form, form_compiler_options)
    else:    
        # UFC form, no need to compile
        compiled_form = form
        A_form_data     = None

    # Check if we need to compile the b_form (JIT)
    if not hasattr(b_form, "create_cell_integral"):
        # FFC form, call JIT compile
        (b_compiled_form, module, b_form_data) = jit(b_form, form_compiler_options)
    else:    
        # UFC form, no need to compile
        compiled_form = form
        b_form_data     = None

    # Extract coefficients
    _A_coefficients = _extract_coefficients(A_coefficients, A_form_data, mesh)
    _b_coefficients = _extract_coefficients(b_coefficients, b_form_data, mesh)

    # Create dof map set
    A_dof_maps = _create_dof_map_set(A_form, A_compiled_form, mesh, A_dof_maps)
    b_dof_maps = _create_dof_map_set(b_form, b_compiled_form, mesh, b_dof_maps)

    # Create tensor
    rank = A_compiled_form.rank()
    (A_tensor, reset_tensor) = _create_tensor(A_form, rank, backend, A_tensor, reset_tensor)
    rank = b_compiled_form.rank()
    (b_tensor, reset_tensor) = _create_tensor(b_form, rank, backend, b_tensor, reset_tensor)

    # Set default value for reset_tensor if not specified
    if reset_tensor is None:
        reset_tensor = True

    # Make sure we have a list
    if not isinstance(bcs, list):
      bcs = [bcs]

    bc_array = ArrayDirichletBCPtr()
    for bc in bcs:
        bc_array.push_back(bc)

    # Assemble tensor from compiled form
    cpp_assemble_system(A_tensor, A_compiled_form, _A_coefficients, A_dof_maps,  
                        b_tensor, b_compiled_form, _b_coefficients, b_dof_maps,  
                        x0, mesh, bc_array, 
                        cell_domains, exterior_facet_domains, interior_facet_domains, reset_tensor)
    
    # Clear any temporary stored coeffisient functions
    _clear_compiled_coefficients()
    
    # Return value
    if return_dofmaps:
        return A_tensor, A_dof_maps, b_tensor, b_dof_maps
    else:
        return A_tensor, b_tensor

def jit(form, options = None):
    """Just-in-time compile any provided form

    It uses the jit function from the form compiler registered by
    dolfin_set("form compiler")
    """

    # Import the form compiler
    compiler_str = dolfin_get("form compiler")
    try:
        fc = __import__(compiler_str)
    except ImportError:
        raise RuntimeError, "Could not import %s form compiler" % compiler_str
    
    # Get jit function
    try:
        jit_compile = fc.jit
    except AttributeError:
        raise RuntimeError, "Form compiler must implement the jit function"
    
    # FIXME: This options stuff is FFC specific, sort of destroys the purpose of this function...
    #        Global FFC options should be set in FFC, not DOLFIN!
    if options is None:
        options = {}
    options["cpp optimize"] = dolfin_get("optimize form") or \
                              dolfin_get("optimize")
    
    return jit_compile(form, options)

def get_dolfin_form(compiled_form, form_data, test_spaces, coefficients):
    """ Construct a dolfin::Form """
    
    # Create empty vectors for coefficients and test and trial spaces.
    _test_spaces  = STLVectorFunctionSpacePtr()
    _coefficients = STLVectorFunctionPtr()    
    
    # Extract test spaces
    test_space_error = "Error while extracting test and/or trial spaces."
    if test_spaces is None:
        if hasattr(form_data,"basisfunction_data"):
            for V in form_data.basisfunction_data:
                if not isinstance(V, cpp_FunctionSpace):
                    raise TypeError, test_space_error
                _test_spaces.push_back(V)
    else:
        if not isinstance(test_spaces,(list,cpp_FunctionSpaces)):
            raise TypeError, test_space_error
        if isinstance(test_spaces,list):
            if len(test_spaces) != form_data.rank:
                raise ValueError, test_space_error + "Provide %d number of test_spaces."%form_data.rank
            for V in test_spaces:
                _test_spaces.push_back(V)
        else:
            for i in xrange(form_data.rank):
                _test_spaces.push_back(test_spaces)
            
    # Extract coefficients
    coefficient_error = "Error while extracting coefficients. "
    if coefficients is None:
        # If no coefficients are provided try to extract them from form_data
        if hasattr(form_data,"coefficients"):
            for c in form_data.coefficients:
                if not isinstance(c.f, cpp_Function):
                    raise TypeError, coefficient_error + "Either provide a dict of cpp_Functions, or use dolfin.Function to define your form."
                _coefficients.push_back(c.f)
        else:
            raise TypeError, coefficient_error + "Recieved form_data from form compilation not including information about coefficients."
    else:
        # FIXME: I have disabled compiled_functions based on strings for now
        #       We could ofcourse add it back, but they need a FunctionSpace to
        #       be initialized.
        ## Compile all strings as dolfin::Function
        #string_expressions = []
        #for c in coefficients:
        #    # Note: To allow tuples of floats or ints below, this logic becomes more involved...
        #    if isinstance(c, (tuple, str)):
        #        string_expressions.append(c)
        #if string_expressions:
        #    compiled_functions = compile_functions(string_expressions, mesh)
        #    compiled_functions.reverse()
        #
        # Build list of coefficients
        error_info = "Provide a 'dict' with cpp_Functions, with the ffc function as key."
        if not isinstance(coefficients,dict):
            raise TypeError, coefficient_error + error_info
        for f, c in coefficients.iteritems():
            # FIXME: I have turned of these for now. Should probably add something for
            #       at least constant functions
            # Note: We could generalize this to support more objects 
            # like sympy expressions, tuples for constant vectors, etc...
            #if isinstance(c, (float, int)):
            #    c = cpp_Function(mesh, float(c))
            #elif isinstance(c, (tuple, str)):
            #    c = compiled_functions.pop()
            if not isinstance(f,ffc.Function) or not isinstance(c,cpp_Function):
                raise TypeError, coefficient_error
            _coefficients.push_back(c)
            _compiled_coefficients.append(c)

    # Instantiate the dolfin::Form and return it
    return Form(_test_spaces, _coefficients, compiled_form)

def _clear_compiled_coefficients():
    "Clear stored compiled coeffisient functions" 
    while _compiled_coefficients:
        _compiled_coefficients.pop()

def _create_tensor(form, rank, backend, tensor, reset_tensor):
    "Create tensor for form"

    # Check if tensor is supplied by user
    if tensor:
        return (tensor, reset_tensor)

    # Decide if we should reset the tensor
    use_cache = dolfin_get("optimize use tensor cache") or \
                dolfin_get("optimize")
    if use_cache and reset_tensor is None:
        reset_tensor = not form in _tensor_cache

    # Check if we should use the cache
    if use_cache and form in _tensor_cache:
        return (_tensor_cache[form], reset_tensor)

    # Create tensor
    if rank == 0:
        tensor = Scalar()
    elif rank == 1:
        if backend: tensor = backend.create_vector()
        else:       tensor = Vector()
    elif rank == 2:
        if backend: tensor = backend.create_matrix()
        else:       tensor = Matrix()
    else:
        raise RuntimeError, "Unable to create tensors of rank %d." % rank

    # Store in cache
    if use_cache:
        _tensor_cache[form] = tensor

    return (tensor, reset_tensor)
