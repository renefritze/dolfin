"""This module provides functionality for form assembly in Python,
corresponding to the C++ assembly and PDE classes.

The C++ assemble function (renamed to cpp_assemble) is wrapped with
an additional preprocessing step where code is generated using the
FFC JIT compiler.

The C++ PDE classes are reimplemented in Python since the C++ classes
rely on the dolfin::Form class which is not used on the Python side."""

__author__ = "Anders Logg (logg@simula.no)"
__date__ = "2007-08-15 -- 2008-12-05"
__copyright__ = "Copyright (C) 2007-2008 Anders Logg"
__license__  = "GNU LGPL Version 2.1"

# Modified by Martin Sandve Alnaes, 2008.
# Modified by Johan Hake, 2008.
# Modified by Garth N. Wells, 2008-2009.

__all__ = ["assemble", "assemble_system"]
# FIXME: Add "assemble_system"

# Import SWIG-generated extension module (DOLFIN C++)
import cpp

# Local imports
from form import *

# Cache for tensors
_tensor_cache = {}

# JIT assembler
def assemble(form,
             tensor=None,
             coefficients=None,
             function_spaces=None,
             cell_domains=None,
             exterior_facet_domains=None,
             interior_facet_domains=None,
             reset_tensor=None,
             backend=None,
             form_compiler_options=None):
    """ Assemble form and return tensor.
    
    Based on the form that is provided, a tensor is assembled and
    returned.

    In the simplest case, no additional arguments are needed. However,
    additional arguments may and must in some cases be provided as
    outlined below.

    The form can be either an FFC form or a precompiled UFC form. If a
    precompiled or 'pure' FFC form is given, then coefficients and
    function_spaces have to be provided too. The coefficient functions
    should be provided as a 'dict' using the FFC functions as
    keys. The function spaces should be provided either as a list where
    the number of function spaces must correspond to the number of basis
    functions in the form, or as a single argument, implying that the
    same FunctionSpace is used for all test/trial spaces.
    
    If the form defines integrals over different subdomains,
    MeshFunctions over the corresponding topological entities defining the
    subdomains can be provided. An instance of a SubDomain can also be
    passed for each subdomain.

    The implementation of the returned tensor is determined by the
    default linear algebra backend. This can be overridden by
    specifying a different backend.
    
    Each call to assemble() will create a new tensor. If the 'tensor'
    argument is provided, this will be used instead. If 'reset_tensor'
    is set to True, the provided tensor will not be reset to zero
    before assembling (adding) values to the tensor.

    Form compiler specific options can be provided by the argument
    'form_compiler_options'.
    """

    # Wrap form
    dolfin_form = Form(form, function_spaces, coefficients, form_compiler_options)

    # Create tensor
    (tensor, reset_tensor) = _create_tensor(form, dolfin_form.rank(), backend, tensor, reset_tensor)

    # Set default value for reset_tensor if not specified
    if reset_tensor is None:
        reset_tensor = True
    
    # Extract domains
    cell_domains, exterior_facet_domains, interior_facet_domains = \
                  _extract_domains(dolfin_form.mesh(),
                                   cell_domains,
                                   exterior_facet_domains,
                                   interior_facet_domains)
    
    # Assemble tensor from compiled form
    cpp.assemble(tensor,
                 dolfin_form,
                 cell_domains,
                 exterior_facet_domains,
                 interior_facet_domains,
                 reset_tensor)

    # Convert to float for scalars
    if dolfin_form.rank() == 0:
        tensor = tensor.getval()
    
    # Return value
    return tensor

# JIT system assembler
def assemble_system(A_form,
                    b_form,
                    bcs=None,
                    x0=None,
                    A_coefficients=None,
                    b_coefficients=None,
                    A_function_spaces=None,
                    b_function_spaces=None,
                    cell_domains=None,
                    exterior_facet_domains=None,
                    interior_facet_domains=None,
                    reset_tensor=None,
                    A_tensor=None,
                    b_tensor=None,
                    backend=None,
                    return_dofmaps=False,
                    form_compiler_options=None):
    "Assemble form over mesh and return tensor"

    A_dolfin_form = Form(A_form, A_function_spaces, A_coefficients, form_compiler_options)
    b_dolfin_form = Form(b_form, b_function_spaces, b_coefficients, form_compiler_options)


    (A_tensor, reset_tensor) = _create_tensor(A_form, A_dolfin_form.rank(), backend, A_tensor, reset_tensor)
    (b_tensor, reset_tensor) = _create_tensor(b_form, b_dolfin_form.rank(), backend, b_tensor, reset_tensor)

    # Set default value for reset_tensor if not specified
    if reset_tensor is None:
        reset_tensor = True
    
    # Extract domains
    cell_domains, exterior_facet_domains, interior_facet_domains = \
                  _extract_domains(A_dolfin_form.mesh(),
                                   cell_domains,
                                   exterior_facet_domains,
                                   interior_facet_domains)

    # Create list of bcs
    if not isinstance(bcs, list):
      bcs = [bcs]

    # Insert bcs into std::vector
    _bcs = cpp.STLVectorDirichletBCPtr(len(bcs))
    for bc in bcs:
      _bcs[0] = bc

    cpp.assemble_system_swig(A_tensor, 
                             b_tensor, 
                             A_dolfin_form, 
                             b_dolfin_form, 
                             _bcs, 
                             cell_domains,
                             exterior_facet_domains,
                             interior_facet_domains,
                             x0,
                             reset_tensor)

    return A_tensor, b_tensor

def _create_tensor(form, rank, backend, tensor, reset_tensor):
    "Create tensor for form"

    # Check backend argument
    if (not backend is None) and (not isinstance(backend,cpp.LinearAlgebraFactory)):
        raise TypeError, "Provide a LinearAlgebraFactory as 'backend'"
    
    # Check if tensor is supplied by user
    if tensor is not None:
        return (tensor, reset_tensor)

    # Decide if we should reset the tensor
    use_cache = cpp.parameters["optimize_use_tensor_cache"] or \
                cpp.parameters["optimize"]
    if use_cache and reset_tensor is None:
        reset_tensor = not form in _tensor_cache

    # Check if we should use the cache
    if use_cache and form in _tensor_cache:
        return (_tensor_cache[form], reset_tensor)

    # Create tensor
    if rank == 0:
        tensor = cpp.Scalar()
    elif rank == 1:
        if backend: tensor = backend.create_vector()
        else:       tensor = cpp.Vector()
    elif rank == 2:
        if backend: tensor = backend.create_matrix()
        else:       tensor = cpp.Matrix()
    else:
        raise RuntimeError, "Unable to create tensors of rank %d." % rank

    # Store in cache
    if use_cache:
        _tensor_cache[form] = tensor

    return (tensor, reset_tensor)


def _extract_domains(mesh,
                     cell_domains,
                     exterior_facet_domains,
                     interior_facet_domains):

    def build_mf(subdomain, dim):
        " Builds a MeshFunction from a SubDomain"
        mf = cpp.MeshFunction("uint", mesh, dim)
        mf.fill(1)
        subdomain.mark(mf,0)
        return mf

    # The cell dimension
    cell_dim = mesh.topology().dim()

    if isinstance(cell_domains, cpp.SubDomain):
        cell_domains = build_mf(cell_domains, cell_dim)

    if isinstance(exterior_facet_domains, cpp.SubDomain):
        exterior_facet_domains = build_mf(exterior_facet_domains, cell_dim-1)
    else: 
        exterior_facet_domains = mesh.data().mesh_function("exterior facet domains")

    if isinstance(interior_facet_domains, cpp.SubDomain):
        interior_facet_domains = build_mf(interior_facet_domains, cell_dim-1)

    return cell_domains, exterior_facet_domains, interior_facet_domains
