"""This module provides functionality for form assembly in Python,
corresponding to the C++ assembly and PDE classes.

The C++ assemble function (renamed to cpp_assemble) is wrapped with
an additional preprocessing step where code is generated using the
FFC JIT compiler.

The C++ PDE classes are reimplemented in Python since the C++ classes
rely on the dolfin::Form class which is not used on the Python side."""

__author__ = "Anders Logg (logg@simula.no)"
__date__ = "2007-08-15 -- 2008-12-03"
__copyright__ = "Copyright (C) 2007-2008 Anders Logg"
__license__  = "GNU LGPL Version 2.1"

# Modified by Martin Sandve Alnaes, 2008.
# Modified by Johan Hake, 2008.
# Modified by Garth N. Wells, 2008.

__all__ = ["assemble", "jit"]
# FIXME: Add "assemble_system"

# Import FFC and SWIG-generated extension module (DOLFIN C++)
import ffc
import cpp

# Local imports
from form import *

# Cache for tensors
_tensor_cache = {}

# Temporary storage of compiled coefficient functions avoiding
# Python deleting our function objects before assembly!
_compiled_coefficients = []

# Add a parameter for form compiler
cpp.dolfin_add("form compiler", "ffc")

# JIT assembler
def assemble(form,
             tensor=None,
             coefficients=None,
             test_spaces=None,
             cell_domains=None,
             exterior_facet_domains=None,
             interior_facet_domains=None,
             reset_tensor=None,
             backend=None,
             form_compiler_options=None):
    """ Assemble form and return tensor.
    
    Based on the form that is provided, a tensor is assembled and
    returned.

    In the simplest case, no additional arguments are needed. However,
    additional arguments may and must in some cases be provided as
    outlined below.

    The form can be either an FFC form or a precompiled UFC form. If a
    precompiled or 'pure' FFC form is given, then coefficients and
    test_spaces have to be provided too. The coefficient functions
    should be provided as a 'dict' using the FFC functions as
    keys. The test spaces should be provided either as a list where
    the number of test spaces must correspond to the number of basis
    functions in the form, or as a single argument, implying that the
    same FunctionSpace is used for all test/trial spaces.
    
    If the form defines integrals over different subdomains,
    MeshFunctions over the corresponding topological entities defining the
    subdomains can be provided.

    The implementation of the returned tensor is determined by the
    default linear algebra backend. This can be overridden by
    specifying a different backend.
    
    Each call to assemble() will create a new tensor. If the 'tensor'
    argument is provided, this will be used instead. If 'reset_tensor'
    is set to True, the provided tensor will not be reset to zero
    before assembling (adding) values to the tensor.

    Form compiler specific options can be provided by the argument
    'form_compiler_options'.
    """

    # Wrap form
    dolfin_form = Form(form, test_spaces, coefficients, form_compiler_options)

    # This breaks, looks like _ufc_form in dolfin::Form is 0, why?
    #print dolfin_form.rank()
    
    # Check if we need to compile the form (JIT)
    #if not hasattr(form, "create_cell_integral"):
    #    # FFC form, call JIT compile
    #    (compiled_form, module, form_data) = jit(form, form_compiler_options)
    #else:    
    #    # UFC form, no need to compile
    #    compiled_form = form
    #    form_data     = None
    #
    ## Get the dolfin::Form
    #dolfin_form = get_dolfin_form(compiled_form, form_data, coefficients, test_spaces)
    
    # Create tensor
    rank = dolfin_form.rank()
    (tensor, reset_tensor) = _create_tensor(form, rank, backend, tensor, reset_tensor)

    # Set default value for reset_tensor if not specified
    if reset_tensor is None:
        reset_tensor = True

    # Assemble tensor from compiled form
    cpp.assemble(tensor,
                 dolfin_form,
                 cell_domains,
                 exterior_facet_domains,
                 interior_facet_domains,
                 reset_tensor)

    # Clear any temporary coefficient functions
    _clear_compiled_coefficients()
    
    # Convert to float for scalars
    if rank == 0:
        tensor = tensor.getval()
    
    # Return value
    return tensor

# JIT system assembler
def assemble_system(A_form,
                    b_form,
                    bcs,
                    mesh,
                    x0=None,
                    A_coefficients=None,
                    b_coefficients=None,
                    A_dof_maps=None,
                    b_dof_maps=None,
                    cell_domains=None,
                    exterior_facet_domains=None,
                    interior_facet_domains=None,
                    reset_tensor=None,
                    A_tensor=None,
                    b_tensor=None,
                    backend=None,
                    return_dofmaps=False,
                    form_compiler_options=None):
    "Assemble form over mesh and return tensor"

    return NotImplemented
    # Check if we need to compile the A_form (JIT)
    if not hasattr(A_form, "create_cell_integral"):
        # FFC form, call JIT compile
        (A_compiled_form, module, A_form_data) = jit(A_form, form_compiler_options)
    else:    
        # UFC form, no need to compile
        compiled_form = form
        A_form_data     = None

    # Check if we need to compile the b_form (JIT)
    if not hasattr(b_form, "create_cell_integral"):
        # FFC form, call JIT compile
        (b_compiled_form, module, b_form_data) = jit(b_form, form_compiler_options)
    else:    
        # UFC form, no need to compile
        compiled_form = form
        b_form_data     = None

    # Extract coefficients
    _A_coefficients = _extract_coefficients(A_coefficients, A_form_data, mesh)
    _b_coefficients = _extract_coefficients(b_coefficients, b_form_data, mesh)

    # Create dof map set
    A_dof_maps = _create_dof_map_set(A_form, A_compiled_form, mesh, A_dof_maps)
    b_dof_maps = _create_dof_map_set(b_form, b_compiled_form, mesh, b_dof_maps)

    # Create tensor
    rank = A_compiled_form.rank()
    (A_tensor, reset_tensor) = _create_tensor(A_form, rank, backend, A_tensor, reset_tensor)
    rank = b_compiled_form.rank()
    (b_tensor, reset_tensor) = _create_tensor(b_form, rank, backend, b_tensor, reset_tensor)

    # Set default value for reset_tensor if not specified
    if reset_tensor is None:
        reset_tensor = True

    # Make sure we have a list
    if not isinstance(bcs, list):
      bcs = [bcs]

    bc_array = ArrayDirichletBCPtr()
    for bc in bcs:
        bc_array.push_back(bc)

    # Assemble tensor from compiled form
    cpp.assemble_system(A_tensor, A_compiled_form, _A_coefficients, A_dof_maps,  
                        b_tensor, b_compiled_form, _b_coefficients, b_dof_maps,  
                        x0, mesh, bc_array, 
                        cell_domains, exterior_facet_domains, interior_facet_domains, reset_tensor)
    
    # Clear any temporary stored coeffisient functions
    _clear_compiled_coefficients()
    
    # Return value
    if return_dofmaps:
        return A_tensor, A_dof_maps, b_tensor, b_dof_maps
    else:
        return A_tensor, b_tensor

def jit(form, options = None):
    """Just-in-time compile any provided form.

    It uses the jit function from the form compiler registered by
    dolfin_set("form compiler").
    """

    # Import the form compiler
    compiler_str = cpp.dolfin_get("form compiler")
    try:
        fc = __import__(compiler_str)
    except ImportError:
        raise RuntimeError, "Could not import %s form compiler." % compiler_str
    
    # Get jit function
    try:
        jit_compile = fc.jit
    except AttributeError:
        raise RuntimeError, "Form compiler must implement the jit function."
    
    # FIXME: This options stuff is FFC specific, sort of destroys the purpose of this function...
    # FIXME: Global FFC options should be set in FFC, not DOLFIN!
    # FIXME: Or we could make "cpp optimize" a global option for all form compilers.
    if options is None:
        options = {}
    options["cpp optimize"] = cpp.dolfin_get("optimize form") or cpp.dolfin_get("optimize")
    
    return jit_compile(form, options)

def get_dolfin_form(compiled_form, form_data, test_spaces, coefficients):
    """ Construct a dolfin::Form """
    
    # Create empty vectors for coefficients and test and trial spaces
    _test_spaces  = cpp.STLVectorFunctionSpacePtr()
    _coefficients = cpp.STLVectorFunctionPtr()    
    
    # Extract test spaces
    test_space_error = "Error while extracting test and/or trial spaces."
    if test_spaces is None:
        if hasattr(form_data,"basisfunction_data"):
            for V in form_data.basisfunction_data:
                if not isinstance(V, cpp.FunctionSpace):
                    raise TypeError, test_space_error
                _test_spaces.push_back(V)
    else:
        if not isinstance(test_spaces,(list,cpp.FunctionSpaces)):
            raise TypeError, test_space_error
        if isinstance(test_spaces,list):
            if len(test_spaces) != form_data.rank:
                raise ValueError, test_space_error + "Provide %d number of test_spaces."%form_data.rank
            for V in test_spaces:
                _test_spaces.push_back(V)
        else:
            for i in xrange(form_data.rank):
                _test_spaces.push_back(test_spaces)
            
    # Extract coefficients
    coefficient_error = "Error while extracting coefficients. "
    if coefficients is None:
        # If no coefficients are provided try to extract them from form_data
        if hasattr(form_data,"coefficients"):
            for c in form_data.coefficients:
                if not isinstance(c.f, cpp.Function):
                    raise TypeError, coefficient_error + "Either provide a dict of cpp.Functions, or use Function to define your form."
                _coefficients.push_back(c.f)
        else:
            raise TypeError, coefficient_error + "Recieved form_data from form compilation not including information about coefficients."
    else:
        # FIXME: I have disabled compiled_functions based on strings for now
        #       We could ofcourse add it back, but they need a FunctionSpace to
        #       be initialized.
        ## Compile all strings as dolfin::Function
        #string_expressions = []
        #for c in coefficients:
        #    # Note: To allow tuples of floats or ints below, this logic becomes more involved...
        #    if isinstance(c, (tuple, str)):
        #        string_expressions.append(c)
        #if string_expressions:
        #    compiled_functions = compile_functions(string_expressions, mesh)
        #    compiled_functions.reverse()
        #
        # Build list of coefficients
        error_info = "Provide a 'dict' with cpp.Functions, with the corresponding ffc.Function as key."
        if not isinstance(coefficients,dict):
            raise TypeError, coefficient_error + error_info
        for f, c in coefficients.iteritems():
            # FIXME: I have turned of these for now. Should probably add something for
            #       at least constant functions
            # Note: We could generalize this to support more objects 
            # like sympy expressions, tuples for constant vectors, etc...
            #if isinstance(c, (float, int)):
            #    c = cpp.Function(mesh, float(c))
            #elif isinstance(c, (tuple, str)):
            #    c = compiled_functions.pop()
            if not isinstance(f,ffc.Function) or not isinstance(c,cpp.Function):
                raise TypeError, coefficient_error
            _coefficients.push_back(c)
            _compiled_coefficients.append(c)

    # Instantiate the dolfin::Form and return it
    return cpp.Form(_test_spaces, _coefficients, compiled_form)

def _clear_compiled_coefficients():
    "Clear stored compiled coeffisient functions" 
    while _compiled_coefficients:
        _compiled_coefficients.pop()

def _create_tensor(form, rank, backend, tensor, reset_tensor):
    "Create tensor for form"

    # Check if tensor is supplied by user
    if tensor:
        return (tensor, reset_tensor)

    # Decide if we should reset the tensor
    use_cache = cpp.dolfin_get("optimize use tensor cache") or \
                cpp.dolfin_get("optimize")
    if use_cache and reset_tensor is None:
        reset_tensor = not form in _tensor_cache

    # Check if we should use the cache
    if use_cache and form in _tensor_cache:
        return (_tensor_cache[form], reset_tensor)

    # Create tensor
    if rank == 0:
        tensor = Scalar()
    elif rank == 1:
        if backend: tensor = backend.create_vector()
        else:       tensor = cpp.Vector()
    elif rank == 2:
        if backend: tensor = backend.create_matrix()
        else:       tensor = cpp.Matrix()
    else:
        raise RuntimeError, "Unable to create tensors of rank %d." % rank

    # Store in cache
    if use_cache:
        _tensor_cache[form] = tensor

    return (tensor, reset_tensor)
