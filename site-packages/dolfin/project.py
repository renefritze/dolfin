"""This module provides a simple way to compute the projection of
a Function (discrete or user-defined) onto a finite element space."""

__author__ = "Anders Logg (logg@simula.no)"
__date__ = "2008-07-13 -- 2008-12-07"
__copyright__ = "Copyright (C) 2008 Anders Logg"
__license__  = "GNU LGPL Version 2.1"

__all__ = ['project']

# Import FFC and SWIG-generated extension module (DOLFIN C++)
import ffc
import cpp

# Local imports
from function import *
from functionspace import *
from assemble import *

def project(v, V, solver_type=cpp.cg):

    """Return projection of given function v onto the finite element space V.
    Example usage:

        V = FunctionSpace(mesh, "Lagrange", 1)

        Pv = project(v, V)

    This is useful for post-processing functions which are not readily
    handled by visualization tools (such as for example discontinuous
    functions)."""

    # Check arguments
    if not isinstance(v, Function):
        cpp.error("Illegal function for projection, not a Function: " + str(v))
    if not isinstance(V, FunctionSpaceBase):
        cpp.error("Illegal function space for projection, not a FunctionSpace: " + str(v))

    # Define variational problem for projection
    w = TestFunction(V)
    Pv = TrialFunction(V)
    if V.element().value_rank() == 0:
        a = w*Pv*ffc.dx
        L = w*v*ffc.dx
    else:
        a = ffc.dot(w, Pv)*ffc.dx
        L = ffc.dot(w, v)*ffc.dx

    # Assemble linear system
    A = assemble(a)
    b = assemble(L)

    # Solve linear system for projection
    Pv = Function(V)
    cpp.solve(A, Pv.vector(), b, solver_type)

    return Pv
