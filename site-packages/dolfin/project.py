"""This module provides a simple way to compute the projection of
a Function (discrete or user-defined) onto a finite element space."""

__author__ = "Anders Logg (logg@simula.no)"
__date__ = "2008-07-13 -- 2008-12-26"
__copyright__ = "Copyright (C) 2008 Anders Logg"
__license__  = "GNU LGPL Version 2.1"

__all__ = ['project']

# Import FFC and SWIG-generated extension module (DOLFIN C++)
import ffc
import cpp

# Local imports
from function import *
from functionspace import *
from assemble import *

def project(v, V=None, solver_type=cpp.cg):
    """Return projection of given expression v onto the finite element space V.
    Example usage:

        V = FunctionSpace(mesh, "Lagrange", 1)

        Pv = project(v, V)

    This is useful for post-processing functions or expressions which
    are not readily handled by visualization tools (such as for
    example discontinuous functions)."""

    # Try extracting function space not specified
    if V is None:
        V = _extract_function_space(v)

    # Check arguments
    if not isinstance(V, FunctionSpaceBase):
        cpp.error("Illegal function space for projection, not a FunctionSpace: " + str(v))

    # Define variational problem for projection
    w = TestFunction(V)
    Pv = TrialFunction(V)
    a = ffc.dot(w, Pv)*ffc.dx
    L = ffc.dot(w, v)*ffc.dx

    # Assemble linear system
    A = assemble(a)
    b = assemble(L)

    # Solve linear system for projection
    Pv = Function(V)
    cpp.solve(A, Pv.vector(), b, solver_type)

    return Pv

def _extract_function_space(expression):
    """Try to extract a suitable function space for projection of
    given expression."""

    from ffc.compiler.language.algebra import Form
    from ffc.compiler.language.operators import value_rank

    # Extract forms
    forms = []
    if isinstance(expression, list):
        for v in expression:
            forms.append(Form(v))
    else:
        forms.append(Form(expression))

    # Extract mesh
    mesh = None
    for a in forms:
        for m in a.monomials:
            for c in m.coefficients:
                mesh = c.f.function_space().mesh()
                break
    if mesh is None:
        raise RuntimeError, "Unable to extract mesh."

    # Create function space
    if value_rank(expression) == 0:
        V = FunctionSpace(mesh, "CG", 1)
    else:
        V = VectorFunctionSpace(mesh, "CG", 1)

    return V
