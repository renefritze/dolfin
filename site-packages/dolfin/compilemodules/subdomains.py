"This module provides functionality for compilation of strings as dolfin SubDomains."

# Copyright (C) 2008-2008 Martin Sandve Alnes
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.
#
# First added:  2008-07-01
# Last changed: 2011-04-18

import re
import os
import hashlib
import instant

# Import local compile_extension_module
from dolfin.compilemodules.compilemodule import (compile_extension_module,
                                                 expression_to_code_fragments,
                                                 math_header)

__all__ = ["compile_subdomains",]

_map_args = ["x", "y"]

_subdomain_template = """
class %(classname)s: public SubDomain
{
public:
%(members)s

  %(classname)s()
  {
%(constructor)s
  }

  /// Return true for points inside the sub domain
  bool inside(const Array<double>& x, bool on_boundary) const
  {
    %(inside)s
  }

};
"""

# TODO: Support implementation of map as well
"""
  /// Map coordinate x in domain H to coordinate y in domain G (used for periodic boundary conditions)
  void map(const Array<double>& x, Array<double>& y) const
  {
    %(map)s
  }
"""

def expression_to_subdomain(cpparg, classname):
    """
    Generate code for a :py:class:`SubDomain <dolfin.cpp.SubDomain>`
    subclass for a single expression.
    """

    # Assure we have a simple string expression
    assert isinstance(expr, str)

    # Extract code fragments from the expr and defaults
    fragments, members = expression_to_code_fragments(\
        [cpparg], ["x", "on_boundary", "DOLFIN_EPS"])
    
    # Generate code for inside()
    insidecode = "  return %s;" % cpparg
    
    # Generate code for map()
    #mapcode = "..."

    # Connect the code fragments using the function template code
    fragments["classname"] = classname
    fragments["inside"]    = insidecode
    #fragments["map"]       = mapcode
    code = _subdomain_template % fragments
    return code, members

def compile_subdomain_code(code, classname, kwargs):
    # Autodetect classnames:

    _classnames = re.findall(r"class[ ]+([\w]+).*", code)

    # Complete the code
    code = math_header + \
"""
namespace dolfin
{
""" + code + \
"""
}
"""

    # Compile the extension module
    compiled_module = compile_extension_module(code)

    # Construct instances of the compiled subdomain classes
    return getattr(compiled_module, classname)

def compile_subdomains(cpparg, **kwargs):
    """
    Compile C++ string expressions into
    :py:class:`SubDomain <dolfin.cpp.SubDomain>` instances.

    *Arguments*
        cpparg
            a string containing an expression in C++ syntax.

    If ``expressions`` is a 'str', it is interpreted as a C++ string
    with complete implementations of subclasses of
    :py:class:`SubDomain <dolfin.cpp.SubDomain>`.

    If it is a list, each item of the list is interpreted as
    a logical 'inside' expression, and the compiled subdomains
    returned will be in the same order as they occur in this list.

    If an expression string contains a name, it is assumed to
    be a scalar variable name, and is added as a public member
    of the generated subdomain.

    *Examples of usage*

        .. code-block:: python

            left  = compile_subdomains("near(x[0], 0)")
            right = compile_subdomains("near(x[1], 1)")

    """

    if not isinstance(cpparg, str):
        raise TypeError, "expected a 'str'"
    
    all_code = []
    all_members = []
    classnames = []

    classname = "CompiledSubDomain"
    code, members = expression_to_subdomain(cpparg, classname, kwargs)
    CompiledSubDomain = compile_subdomain_code("\n".join(code), [classname])

    # FIXME: Use all_members to add some handling of defaults
    return CompiledSubDomain()


if __name__ == "__main__":
    subdomains = compile_subdomains(["x[0] >= 1.0-DOLFIN_EPS", "on_boundary && x[1] < xlen+DOLFIN_EPS"])
    print subdomains


