"""
Special error estimators based on DualEstimatorBase.
"""

__author__ = "Marie E. Rognes (meg@simula.no)"
__copyright__ = "Copyright (C) 2009 - Marie E. Rognes"
__license__  = "GNU GPL version 3 or any later version"

# First added:  2009-10-20
# Last changed: 2010-07-21
#
# Modified by Anders Logg, 2009-2010

__all__ = ["ErrorRepresentationEstimator", "DualWeightedResidualEstimator",
           "CellFacetSplitEstimator"]

import numpy

from dolfin import FunctionSpace, TestFunction, Function
from dolfin import assemble, info
from dolfin import inner, dx, dS, ds, avg

from dolfin.adaptivity.residual import *
from dolfin.adaptivity.errorestimator import GoalEstimatorBase

class ErrorRepresentationEstimator(GoalEstimatorBase):
    """
    :math:`M(u) - M(u_h) = r(z) \\approx r(\\tilde z)`
    """

    def estimate_error(self, u_h):
        info("Computing error estimators")

        # Estimate true dual and store
        V_h = u_h.function_space()
        z = self.construct_dual_approximation(V_h)
        self.dual_approximation = z

        # Create residual functional (as lambda function)
        r = residual(self.F, u_h)

        # Assemble error, that is r(z)
        error = assemble(r(z), mesh = z.function_space().mesh())

        return abs(error)

    def assemble_error_indicators(self, u_h):
        info("Assembling error indicators")

        # If error indicators already computed, use those
        if self.error_indicators:
            return self.error_indicators

        # Construct dual factor
        V_h = u_h.function_space()
        w = self.construct_dual_difference(u_h.function_space())

        # Create residual functional (as lamda)
        r = residual(self.F, u_h)

        # Define localized form for indicators
        C = FunctionSpace(V_h.mesh(), "DG", 0)
        c = TestFunction(C)
        eta_T = r(c*w)

        vector = numpy.abs(assemble(eta_T))
        indicators = Function(C)
        indicators.vector()[:] = vector

        # Store error indicators for later use
        self.error_indicators = indicators

        return indicators

    def __str__(self):
        return "error_representation"


class DualWeightedResidualEstimator(GoalEstimatorBase):

    """
    :math:`w = z - z_h` (with variations in the form of :math:`z` and :math:`z_h`)

    :math:`M(u) - M(u_h) \\approx  \sum_T |<R_T, w>_T + <R_{dT}, w>_{dT}|`
    """

    def estimate_error(self, u_h):

        # Assemble error indicators
        error_indicators = self.assemble_error_indicators(u_h)

        # Sum to get total error
        error = sum(e for e in error_indicators.vector())

        return error

    def assemble_error_indicators(self, u_h):
        info("Assembling error indicators")

        # If error indicators already computed, use those
        if self.error_indicators:
            return self.error_indicators

        # Compute residual representation
        (R_T, R_dT) = compute_residual_representation(self.F, u_h)

        # Compute w \approx z - z_h
        w = self.construct_dual_difference(u_h.function_space())

        # Variable to localize error contributions
        Constants = FunctionSpace(R_T.function_space().mesh(), "DG", 0)
        v = TestFunction(Constants)

        eta_T = (v*inner(R_T, w)*dx
                 + avg(v)*(inner(R_dT('+'), w('+'))
                           + inner(R_dT('-'), w('-')))*dS
                 + v*inner(R_dT, w)*ds)

        # Assemble contributions
        vector = numpy.abs(assemble(eta_T))
        indicators = Function(Constants)
        indicators.vector()[:] = vector

        # Store error indicators for later use
        self.error_indicators = indicators

        return indicators

    def __str__(self):
        return "dual_weighted_residual"


class CellFacetSplitEstimator(GoalEstimatorBase):
    """
    :math:`M(u) - M(u_h) \\approx  \sum_T |<R_T, w>_T| + |<R_{dT}, w>_{dT}|`
    """

    def estimate_error(self, u_h):

        # Assemble error indicators
        error_indicators = self.assemble_error_indicators(u_h)

        # Sum to get total error
        error = sum(e for e in error_indicators.vector())

        return error

    def assemble_error_indicators(self, u_h):
        info("Assembling error indicators")

        # If error indicators already computed, use those
        if self.error_indicators:
            return self.error_indicators

        # Compute residual representation
        (R_T, R_dT) = compute_residual_representation(self.F, u_h)

        # Compute w \approx z - z_h
        w = self.construct_dual_difference(u_h.function_space())

        # Variable to localize error contributions
        Constants = FunctionSpace(R_T.function_space().mesh(), "DG", 0)
        v = TestFunction(Constants)

        cell_contribution = v*inner(R_T, w)*dx
        facet_contribution = (avg(v)*(inner(R_dT('+'), w('+'))
                                      + inner(R_dT('-'), w('-')))*dS
                              + v*inner(R_dT, w)*ds)

        # Assemble contributions and take absolute values
        cell_term = numpy.abs(assemble(cell_contribution))
        facet_term = numpy.abs(assemble(facet_contribution))

        indicators = Function(Constants)
        indicators.vector()[:] = cell_term + facet_term

        # Store error indicators for later use
        self.error_indicators = indicators

        return indicators

    def __str__(self):
        return "cell_facet_split"
