"""This module provides a small Python layer on top of the C++
VariationalProblem/Solver classes as well as the solve function."""

# Copyright (C) 2011 Anders Logg
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.
#
# First added:  2011-06-22
# Last changed: 2011-06-22

__all__ = ["LinearVariationalProblem",
           "LinearVariationalSolver",
           "NonlinearVariationalProblem",
           "NonlinearVariationalSolver",
           "solve"]

# Import SWIG-generated extension module (DOLFIN C++)
import dolfin.cpp as cpp

# Import UFL
import ufl

# Local imports
from dolfin.fem.form import Form

# Problem classes need special handling since they involve JIT compilation

class LinearVariationalProblem(cpp.LinearVariationalProblem):

    # Reuse C++ doc-string
    __doc__ = cpp.LinearVariationalProblem.__doc__

    def __init__(self, a, L, u, bcs,
                 form_compiler_parameters=None):
        "Create linear variational problem"

        # Set parameters to empty dictionary if not specified
        form_compiler_parameters = form_compiler_parameters or {}

        # Store input UFL forms
        self.a_ufl = a
        self.L_ufl = L
        self.u_ufl = u

        # Wrap forms
        a = Form(a, form_compiler_parameters=form_compiler_parameters)
        L = Form(L, form_compiler_parameters=form_compiler_parameters)

        # Store data (or it will segfault)
        self.a = a
        self.L = L
        self.bcs = bcs

        # Initialize base class
        cpp.LinearVariationalProblem.__init__(self, a, L, u, bcs)

class NonlinearVariationalProblem(cpp.NonlinearVariationalProblem):

    # Reuse C++ doc-string
    __doc__ = cpp.NonlinearVariationalProblem.__doc__

    def __init__(self, F, rhs, u, bcs,
                 form_compiler_parameters=None):
        "Create nonlinear variational problem"

        # Set parameters to empty dictionary if not specified
        form_compiler_parameters = form_compiler_parameters or {}

        # Store input UFL form
        self.F_ufl = F

        # Wrap forms
        F = Form(F, form_compiler_parameters=form_compiler_parameters)

        # Store data (or it will segfault)
        self.F = F
        self.bcs = bcs

        # Initialize base class
        cpp.NonlinearVariationalProblem.__init__(self, F, rhs, u, bcs)

# Solver classes are imported directly
from dolfin.cpp import LinearVariationalSolver, NonlinearVariationalSolver

# Solve function handles both linear systems and variational problems

def solve(*args):
    """Solve linear system Ax = b or variational problem a == L or F == 0.
    FIXME: Add a very fine docstring for this function."""

    # Special case: first argument is an equation
    if isinstance(args[0], ufl.classes.Equation):
        eq = args[0]

        # Solve linear or nonlinear variational problem
        if isinstance(eq.lhs, ufl.Form) and isinstance(eq.rhs, ufl.Form):
            problem = LinearVariationalProblem(eq.lhs, eq.rhs, *args[1:])
            solver = LinearVariationalSolver(problem)
            solver.solve()
        else:
            problem = NonlinearVariationalProblem(eq.lhs, eq.rhs, *args[1:])
            solver = NonlinearVariationalSolver(problem)
            solver.solve()

    # Otherwise, just call the wrapped C++ solve function
    else:
        cpp.solve(*args)
