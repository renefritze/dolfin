"""This module provides a small Python layer on top of the C++
VariationalProblem/Solver classes as well as the solve function."""

# Copyright (C) 2011 Anders Logg
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.
#
# Modified by Marie E. Rognes, 2011.
#
# First added:  2011-06-22
# Last changed: 2011-06-22

__all__ = ["LinearVariationalProblem",
           "LinearVariationalSolver",
           "NonlinearVariationalProblem",
           "NonlinearVariationalSolver",
           "solve"]

# Import SWIG-generated extension module (DOLFIN C++)
import dolfin.cpp as cpp

# Import UFL
import ufl

# Local imports
from dolfin.fem.form import Form
from dolfin.fem.formmanipulations import derivative

# Problem classes need special handling since they involve JIT compilation

class LinearVariationalProblem(cpp.LinearVariationalProblem):

    # Reuse C++ doc-string
    __doc__ = cpp.LinearVariationalProblem.__doc__

    def __init__(self, a, L, u, bcs,
                 form_compiler_parameters=None):
        "Create linear variational problem"

        # Set parameters to empty dictionary if not specified
        form_compiler_parameters = form_compiler_parameters or {}

        # Store input UFL forms and solution Coefficient/Function
        self.a_ufl = a
        self.L_ufl = L
        self.u_ufl = u

        # Wrap forms
        a = Form(a, form_compiler_parameters=form_compiler_parameters)
        L = Form(L, form_compiler_parameters=form_compiler_parameters)

        # Store data (or it will segfault)
        self.a = a
        self.L = L
        self.bcs = bcs
        self.form_compiler_parameters = form_compiler_parameters

        # Initialize C++ base class
        cpp.LinearVariationalProblem.__init__(self, a, L, u, bcs)

class NonlinearVariationalProblem(cpp.NonlinearVariationalProblem):

    # Reuse C++ doc-string
    __doc__ = cpp.NonlinearVariationalProblem.__doc__

    def __init__(self, F, rhs, u, bcs,
                 form_compiler_parameters=None):
        "Create nonlinear variational problem"

        # Set parameters to empty dictionary if not specified
        form_compiler_parameters = form_compiler_parameters or {}

        # Store input UFL form and solution Coefficient/Function
        self.F_ufl = F
        self.u_ufl = u

        # Wrap form
        F = Form(F, form_compiler_parameters=form_compiler_parameters)

        # Store data (or it will segfault)
        self.F = F
        self.bcs = bcs
        self.form_compiler_parameters = form_compiler_parameters

        # Initialize C++ base class
        cpp.NonlinearVariationalProblem.__init__(self, F, rhs, u, bcs)

    def set_jacobian(self, J):
        "Set Jacobian form"

        # Store input UFL form
        self.J_ufl = J

        # Wrap form
        J = Form(J, form_compiler_parameters=self.form_compiler_parameters)

        # Store data (or it will segfault)
        self.J = J

        # Call set_jacobian in C++ base class
        cpp.NonlinearVariationalProblem.set_jacobian(self, J)

# Solver classes are imported directly
from dolfin.cpp import LinearVariationalSolver, NonlinearVariationalSolver
from dolfin.fem.adaptivesolving import AdaptiveLinearVariationalSolver
from dolfin.fem.adaptivesolving import AdaptiveNonlinearVariationalSolver

# Solve function handles both linear systems and variational problems

def solve(*args, **kwargs):
    """Solve linear system Ax = b or variational problem a == L or F == 0.
    FIXME: Add a very fine docstring for this function."""

    # Special case: first argument is an equation
    if isinstance(args[0], ufl.classes.Equation):

        # Check number of arguments
        if not len(args) in (2, 5):
            cpp.dolfin_error("solving.py",
                             "solve variational problem",
                             "Wrong number of arguments, expecting solve(lhs == rhs, u, [bcs], [tol], [M])")

        # Get arguments
        eq = args[0]
        u = args[1]

        if (len(args) == 2):
            bcs = []        # No boundary conditions
        elif isinstance(args[2], (list, tuple)):
            bcs = args[2]   # Assume list/tuple contains boundary conditions
        elif isinstance(args[2], cpp.BoundaryCondition):
            bcs = [args[2]]  # Wrap boundary condition in list
        else:
            cpp.dolfin_error("solving.py",
                             "solve variational problem",
                             "Unable to extract boundary condition arguments.")

        # Go adaptive if more than 3 (but less than 5) arguments
        if len(args) in (4, 5):
            adaptive_args = args[3:] if bcs else args[2:]
            adaptive_solve(eq, u, bcs, adaptive_args, kwargs)
            return

        # Get parameters
        form_compiler_parameters = kwargs.get("form_compiler_parameters", {})
        solver_parameters = kwargs.get("solver_parameters", {})

        # Solve linear or nonlinear variational problem
        if isinstance(eq.lhs, ufl.Form) and isinstance(eq.rhs, ufl.Form):

            # Create problem
            problem = LinearVariationalProblem(eq.lhs, eq.rhs, u, bcs,
                        form_compiler_parameters=form_compiler_parameters)

            # Create solver and call solve
            solver = LinearVariationalSolver(problem)
            solver.parameters.update(solver_parameters)
            solver.solve()

        else:

            # Create problem
            problem = NonlinearVariationalProblem(eq.lhs, eq.rhs, u, bcs,
                        form_compiler_parameters=form_compiler_parameters)

            # Get or create Jacobian
            if "J" in kwargs:
                J = kwargs["J"]
            else:
                cpp.info("No Jacobian form specified for nonlinear variational problem.")
                cpp.info("Differentiating residual form F to obtain Jacobian J = F'.")
                F = eq.lhs
                u = args[1]
                J  = derivative(F, u)
            problem.set_jacobian(J)

            # Create solver and call solve
            solver = NonlinearVariationalSolver(problem)
            solver.parameters.update(solver_parameters)
            solver.solve()

    # Otherwise, just call the wrapped C++ solve function
    else:
        cpp.solve(*args)


def adaptive_solve(eq, u, bcs, args, kwargs):
    """Solve variational problem a == L or F == 0 adaptively."""
    # FIXME: Add a very fine docstring for this function too!
    # FIXME: Consider refactoring some of the code above to enable reuse

    # Get parameters
    form_compiler_parameters = kwargs.get("form_compiler_parameters", {})
    solver_parameters = kwargs.get("solver_parameters", {})

    if not len(args) == 2:
        cpp.dolfin_error("solving.py",
                         "solve variational problem adaptively",
                         "Wrong number of arguments, expecting solve(lhs == rhs, u, bcs, tol, M)")

    tol = args[0]
    M = args[1]

    # Solve linear variational problem
    if isinstance(eq.lhs, ufl.Form) and isinstance(eq.rhs, ufl.Form):
        # Create problem
        problem = LinearVariationalProblem(eq.lhs, eq.rhs, u, bcs,
                        form_compiler_parameters=form_compiler_parameters)

        # Create solver and call solve
        solver = AdaptiveLinearVariationalSolver(problem)
        solver.parameters.update(solver_parameters)
        solver.solve(tol, M)

    # Solve nonlinear variational problem
    else:
        # Create problem
        problem = NonlinearVariationalProblem(eq.lhs, eq.rhs, u, bcs,
                        form_compiler_parameters=form_compiler_parameters)

        # Get or create Jacobian
        if "J" in kwargs:
            J = kwargs["J"]
        else:
            cpp.info("No Jacobian form specified for nonlinear variational problem.")
            cpp.info("Differentiating residual form F to obtain Jacobian J = F'.")
            F = eq.lhs
            J  = derivative(F, u)
        problem.set_jacobian(J)

        # Create solver and call solve
        solver = AdaptiveNonlinearVariationalSolver(problem)
        solver.parameters.update(solver_parameters)
        solver.solve(tol, M)



