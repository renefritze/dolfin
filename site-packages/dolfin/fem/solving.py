"""This module provides a small Python layer on top of the C++
VariationalProblem/Solver classes as well as the solve function."""

# Copyright (C) 2011 Anders Logg
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.
#
# First added:  2011-06-22
# Last changed: 2011-06-22

__all__ = ["LinearVariationalProblem",
           "LinearVariationalSolver",
           "NonlinearVariationalProblem",
           "NonlinearVariationalSolver",
           "solve"]

# Import SWIG-generated extension module (DOLFIN C++)
import dolfin.cpp as cpp

# Import UFL
import ufl

# Local imports
from dolfin.fem.form import Form
from dolfin.fem.formmanipulations import derivative

# Problem classes need special handling since they involve JIT compilation

class LinearVariationalProblem(cpp.LinearVariationalProblem):

    # Reuse C++ doc-string
    __doc__ = cpp.LinearVariationalProblem.__doc__

    def __init__(self, a, L, u, bcs,
                 form_compiler_parameters=None):
        "Create linear variational problem"

        # Set parameters to empty dictionary if not specified
        form_compiler_parameters = form_compiler_parameters or {}

        # Store input UFL forms and solution Coefficient/Function
        self.a_ufl = a
        self.L_ufl = L
        self.u_ufl = u

        # Wrap forms
        a = Form(a, form_compiler_parameters=form_compiler_parameters)
        L = Form(L, form_compiler_parameters=form_compiler_parameters)

        # Store data (or it will segfault)
        self.a = a
        self.L = L
        self.bcs = bcs
        self.form_compiler_parameters = form_compiler_parameters

        # Initialize C++ base class
        cpp.LinearVariationalProblem.__init__(self, a, L, u, bcs)

class NonlinearVariationalProblem(cpp.NonlinearVariationalProblem):

    # Reuse C++ doc-string
    __doc__ = cpp.NonlinearVariationalProblem.__doc__

    def __init__(self, F, rhs, u, bcs,
                 form_compiler_parameters=None):
        "Create nonlinear variational problem"

        # Set parameters to empty dictionary if not specified
        form_compiler_parameters = form_compiler_parameters or {}

        # Store input UFL form and solution Coefficient/Function
        self.F_ufl = F
        self.u_ufl = u

        # Wrap form
        F = Form(F, form_compiler_parameters=form_compiler_parameters)

        # Store data (or it will segfault)
        self.F = F
        self.bcs = bcs
        self.form_compiler_parameters = form_compiler_parameters

        # Initialize C++ base class
        cpp.NonlinearVariationalProblem.__init__(self, F, rhs, u, bcs)

    def set_jacobian(self, J):
        "Set Jacobian form"

        # Store input UFL form
        self.J_ufl = J

        # Wrap form
        J = Form(J, form_compiler_parameters=self.form_compiler_parameters)

        # Store data (or it will segfault)
        self.J = J

        # Call set_jacobian in C++ base class
        cpp.NonlinearVariationalProblem.set_jacobian(self, J)

# Solver classes are imported directly
from dolfin.cpp import LinearVariationalSolver, NonlinearVariationalSolver

# Solve function handles both linear systems and variational problems

def solve(*args, **kwargs):
    """Solve linear system Ax = b or variational problem a == L or F == 0.

    The DOLFIN solve() function can be used to solve either linear
    systems or variational problems. The following list explains the
    various ways in which the solve() function can be used.

    *1. Solving linear systems*

    A linear system Ax = b may be solved by calling solve(A, x, b),
    where A is a matrix and x and b are vectors. Optional arguments
    may be passed to specify the solver type and preconditioer
    type. Some examples are given below:

    .. code-block:: python

        solve(A, x, b)
        solve(A, x, b, "lu")
        solve(A, x, b, "gmres", "ilu")
        solve(A, x, b, "cg", "amg_hypre")

    Possible values for the solver type depend on which linear algebra
    backend is used and how that has been configured, but possible
    values may include:

      "lu"                LU factorization
      "cholesky"          Cholesky factorization
      "cg"                Conjugate gradient method
      "gmres"             Generalized minimal residual method
      "bicgstab"          Biconjugate gradient stabilized method
      "minres"            Minimal residual method
      "tfqmr"             Transpose-free quasi-minimal residual method
      "richardson"        Richardson method

    Similarly, possible values for the preconditioner type may include:

      "none"              No preconditioner
      "ilu"               Incomplete LU factorization
      "icc"               Incomplete Cholesky factorization
      "jacobi"            Jacobi iteration
      "bjacobi"           Block Jacobi iteration
      "sor"               Successive over-relaxation
      "amg"               Algebraic multigrid (either BoomerAMG or ML)
      "additive_schwarz"  Additive Schwarz
      "hypre_amg"         Hypre agebraic multigrid (BoomerAMG)
      "hypre_euclid"      Hypre parallel incomplete LU factorization
      "hypre_parasails"   Hypre parallel sparse approximate inverse
      "amg_ml"            ML algebraic multigrid

    *2. Solving linear variational problems*

    A linear variational problem a(u, v) = L(v) for all v may be
    solved by calling solve(a == L, u, ...), where a is a bilinear
    form, L is a linear form, u is a Function (the solution). Optional
    arguments may be supplied to specify boundary conditions or solver
    parameters. Some examples are given below:

    .. code-block:: python

        solve(a == L, u)
        solve(a == L, u, bc)
        solve(a == L, u, [bc1, bc2])

        solve(a == L, u, bcs,
              solver_parameters={"linear_solver": "lu"},
              form_compiler_parameters={"optimize": True})

    *3. Solving nonlinear variational problems*

    A nonlinear variational problem F(u; v) = 0 for all v may be
    solved by calling solve(F == 0, u, ...), where the residual F is a
    linear form (linear in the test function v but possibly nonlinear
    in the unknown u) and u is a Function (the solution). Optional
    arguments may be supplied to specify boundary conditions, the
    Jacobian form or solver parameters. If the Jacobian is not
    supplied, it will be computed by automatic differentiation of the
    residual form. Some examples are given below:

    .. code-block:: python

        solve(a == L, u)
        solve(a == L, u, bc)
        solve(a == L, u, [bc1, bc2])

        solve(a == L, u, bcs, J=J,
              solver_parameters={"linear_solver": "lu"},
              form_compiler_parameters={"optimize": True})
      """

    # Special case: first argument is an equation
    if isinstance(args[0], ufl.classes.Equation):

        # Check number of arguments
        if not len(args) in (2, 3):
            cpp.dolfin_error("solving.py",
                             "solve variational problem",
                             "Wrong number of arguments, expecting solve(lhs == rhs, u, [bcs])")

        # Get arguments
        eq = args[0]
        u = args[1]
        if len(args) == 3:
            bcs = args[2]
            if isinstance(bcs, cpp.BoundaryCondition):
                bcs = [bcs]
        else:
            bcs = []

        # Get parameters
        form_compiler_parameters = kwargs.get("form_compiler_parameters", {})
        solver_parameters = kwargs.get("solver_parameters", {})

        # Solve linear or nonlinear variational problem
        if isinstance(eq.lhs, ufl.Form) and isinstance(eq.rhs, ufl.Form):

            # Create problem
            problem = LinearVariationalProblem(eq.lhs, eq.rhs, u, bcs,
                        form_compiler_parameters=form_compiler_parameters)

            # Create solver and call solve
            solver = LinearVariationalSolver(problem)
            solver.parameters.update(solver_parameters)
            solver.solve()

        else:

            # Create problem
            problem = NonlinearVariationalProblem(eq.lhs, eq.rhs, u, bcs,
                        form_compiler_parameters=form_compiler_parameters)

            # Get or create Jacobian
            if "J" in kwargs:
                J = kwargs["J"]
            else:
                cpp.info("No Jacobian form specified for nonlinear variational problem.")
                cpp.info("Differentiating residual form F to obtain Jacobian J = F'.")
                F = eq.lhs
                u = args[1]
                J  = derivative(F, u)
            problem.set_jacobian(J)

            # Create solver and call solve
            solver = NonlinearVariationalSolver(problem)
            solver.parameters.update(solver_parameters)
            solver.solve()

    # Otherwise, just call the wrapped C++ solve function
    else:
        cpp.solve(*args)
