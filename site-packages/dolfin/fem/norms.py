"""This module provides a simple way to compute various norms of
Functions, including the standard L2 norm and other norms"""

# Copyright (C) 2008 Anders Logg
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN.  If not, see <http://www.gnu.org/licenses/>.
#
# First added:  2008-03-19
# Last changed: 2009-12-11

__all__ = ["norm", "errornorm"]

from ufl import inner, grad, div, curl, dx, FiniteElement, VectorElement
from math import sqrt

import dolfin.cpp as cpp

from dolfin.cpp import GenericVector, GenericFunction, Function, Mesh, error, Vector
from dolfin.fem.assembling import assemble
from dolfin.fem.interpolation import interpolate
from dolfin.functions.function import Function
from dolfin.functions.functionspace import FunctionSpace, VectorFunctionSpace

dim_to_shape = {1: "interval", 2: "triangle", 3: "tetrahedron"}

def norm(v, norm_type="L2", mesh=None):
    """Return norm of given vector or function. Example usage includes:

        norm(x)
        norm(x, 'linf')
        norm(v)
        norm(u0 - u1)
        norm(v, 'Hdiv')

    If the norm type is not specified, the standard L^2 norm is
    computed. Possible norm types include:

    Vectors:

      l^2:     norm(x, 'l2')      (default)
      l^1:     norm(x, 'l1')
      l^oo:    norm(x, 'linf')

    Functions:

      L^2:     norm(v, 'L2')
      H^1:     norm(v, 'H1')      includes L^2 term
      H^1_0:   norm(v, 'H10')     does not include L^2 term
      H(div):  norm(v, 'Hdiv')    includes L^2 term
      H(div):  norm(v, 'Hdiv0')   does not include L^2 term
      H(curl): norm(v, 'Hcurl')   includes L^2 term
      H(curl): norm(v, 'Hcurl0')  does not include L^2 term
    """

    if not isinstance(v, (GenericVector, GenericFunction)):
        raise TypeError, "expected a GenericVector or GenericFunction"

    # Check arguments
    if not isinstance(norm_type, str):
        error("Norm type must be a string, not " + str(type(norm_type)) + ".")
    if mesh is not None and not isinstance(mesh, Mesh):
        error("Expecting a Mesh, not " + str(type(mesh)) + ".")

    # Use vector norm if we get a vector
    if isinstance(v, GenericVector):
        if norm_type.lower() == "l2":
            return v.norm("l2")
        return v.norm(norm_type.lower())

    # Choose functional
    if norm_type.lower() == "l2":
        M = inner(v, v)*dx
    elif norm_type.lower() == "h1":
        M = inner(v, v)*dx + inner(grad(v), grad(v))*dx
    elif norm_type.lower() == "h10":
        M = inner(grad(v), grad(v))*dx
    elif norm_type.lower() == "hdiv":
        M = inner(v, v)*dx + div(v)*div(v)*dx
    elif norm_type.lower() == "hdiv0":
        M = div(v)*div(v)*dx
    elif norm_type.lower() == "hcurl":
        M = inner(v, v)*dx + inner(curl(v), curl(v))*dx
    elif norm_type.lower() == "hcurl0":
        M = inner(curl(v), curl(v))*dx
    else:
        error("Unknown norm type: "\
              "%s\nSee pydoc dolfin.norm for valid types." % str(norm_type))

    # Get mesh
    if isinstance(v, Function) and mesh is None:
        mesh = v.function_space().mesh()

    # Assemble value
    r = assemble(M, mesh=mesh, form_compiler_parameters={"representation": "quadrature"})

    # Check value
    if r < 0.0:
        error("Unable to compute norm, square of norm is negative (round-off errors?).")
    elif r == 0.0:
        return 0.0
    else:
        return sqrt(r)

def errornorm(u, uh, norm_type="l2", degree=3, mesh=None):
    """Compute the error e = u - uh in the given norm. The parameter k
    denotes the degree of accuracy (degree of piecewise polynomials
    approximating u an uh).

    In simple cases, one may just define

      e = u - uh

    and evalute for example the square of the error in the L2 norm by

      e = u - uh
      assemble(e*e*dx, mesh)

    However, this is not stable w.r.t. round-off errors considering that
    the form compiler may expand the expression above to

      u*u*dx + uh*uh*dx - 2*u*uh*dx

    and this might get further expanded into thousands of terms for
    higher order elements. Thus, the error will be evaluated by adding
    a large number of terms which should sum up to something close to
    zero (if the error is small).

    This module computes the error by first interpolating both u and uh
    to a common space (of high accuracy), then subtracting the two fields
    (which is easy since they are expressed in the same basis) and then
    evaluating the integral."""

    # Check argument
    if not isinstance(u, cpp.GenericFunction):
        cpp.error("Unable to compute error norm, not a Function or Expression: " + str(u))
    if not isinstance(uh, cpp.GenericFunction):
        cpp.error("Unable to compute error norm, not a Function or Expression: " + str(u))

    # Get mesh
    if isinstance(u, Function) and mesh is None:
        mesh = u.function_space().mesh()
    if isinstance(uh, Function) and mesh is None:
        mesh = uh.function_space().mesh()
    if mesh is None:
        error("Unable to compute error norm, missing mesh.")

    # Get rank
    if not u.value_rank() == uh.value_rank():
        error("Unable to compute error norm, value ranks don't match.")
    rank = u.value_rank()

    # Create function space
    if rank == 0:
        V = FunctionSpace(mesh, "Discontinuous Lagrange", degree)
    elif rank == 1:
        V = VectorFunctionSpace(mesh, "Discontinuous Lagrange", degree)
    else:
        error("Unable to compute error norm, can't handle elements of rank %d." % rank)

    # Interpolate functions into finite element space
    pi_u = interpolate(u, V)
    pi_uh = interpolate(uh, V)

    # Compute the difference
    e = Function(V)
    e.assign(pi_u)
    e.vector().axpy(-1.0, pi_uh.vector())

    # Compute norm
    return norm(e, norm_type=norm_type, mesh=mesh)
