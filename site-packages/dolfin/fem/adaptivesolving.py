"""This module provides a Python layer on top of the C++
Adaptive*VariationalSolver classes"""

# Copyright (C) 2011 Marie E. Rognes
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.
#
# First added:  2011-06-27
# Last changed: 2011-06-27

__all__ = ["AdaptiveLinearVariationalSolver"]

import dolfin
import dolfin.cpp as cpp

from dolfin.fem.form import Form
from dolfin.functions.function import Function, TestFunction
from dolfin.functions.functionspace import FunctionSpace


# Import UFL
from ufl.algorithms import extract_arguments

class AdaptiveLinearVariationalSolver(cpp.AdaptiveLinearVariationalSolver):
    # Reuse doc-string
    __doc__ = cpp.AdaptiveNonlinearVariationalSolver.__doc__

    def __init__(self, problem, form_compiler_parameters=None):

        # Store problem # MER: Is this necessary? Shouldn't c++ handle
        # this?
        self.problem = problem

        # Set parameters to empty dictionary if not specified
        self.form_compiler_parameters = form_compiler_parameters or {}

        # Initialize C++ base class
        cpp.AdaptiveLinearVariationalSolver.__init__(self, problem)

    def solve(self, tol, goal):

        # Generate forms used for error control
        ufl_forms = self.generate_error_control_forms(goal)

        # Compile generated forms
        forms = [Form(form,
                      form_compiler_parameters=self.form_compiler_parameters)
                 for form in ufl_forms]

        # Compile goal functional separately
        M = Form(goal, form_compiler_parameters=self.form_compiler_parameters)

        # Initialize cpp error control object
        forms += [True]
        ec = cpp.ErrorControl(*forms)

        # Call cpp.VariationalProblem.solve
        cpp.AdaptiveLinearVariationalSolver.solve(self, tol, M, ec)

    def generate_error_control_forms(self, goal):

        cpp.info("Generating forms required for error control.")

        # MER: Need these things:
        u = self.problem.u_ufl
        bilinear = self.problem.a_ufl
        linear = self.problem.L_ufl

        forms = (bilinear, linear, goal)

        # Get FFC to generate error control forms
        from ffc.errorcontrol.formmanipulations import \
             (generate_dual_forms, generate_weak_residual,
              generate_cell_residual, generate_facet_residual,
              generate_error_indicator)

        # Use DOLFIN module for form manipulations
        module = __import__("dolfin.fem.formmanipulations")

        # Generate forms for dual problem
        (a_star, L_star) = generate_dual_forms(forms, u, module)

        # Generate form for weak residual
        weak_residual = generate_weak_residual((bilinear, linear), u)

        # Generate extrapolation space by increasing order of trial space
        V = u.function_space()
        mesh = V.mesh()
        E = module.increase_order(V)
        Ez_h = Function(E)

        # Generate error estimate (residual)
        eta_h = dolfin.action(weak_residual, Ez_h)

        # Define approximation space for cell and facet residuals
        V_h = module.tear(V)

        # Generate forms for computation of cell residuals
        B = FunctionSpace(mesh, "B", mesh.topology().dim()+1)
        b_T = Function(B)
        b_T.vector()[:] = 1.0
        a_R_T, L_R_T = generate_cell_residual(weak_residual, V_h, b_T, module)

        # Generate forms for computation of facet residuals
        R_T = Function(V_h)
        C = FunctionSpace(mesh, "DG", mesh.topology().dim())
        b_e = Function(C)
        a_R_dT, L_R_dT = generate_facet_residual(weak_residual, V_h, b_e, R_T,
                                                 module)

        # Generate error indicators
        R_dT = Function(V_h)
        z_h = Function(extract_arguments(a_star)[1].function_space())
        q = TestFunction(FunctionSpace(mesh, "DG", 0))
        eta_T = generate_error_indicator(weak_residual, R_T, R_dT, Ez_h, z_h, q)

        forms = (a_star, L_star, eta_h, a_R_T, L_R_T, a_R_dT, L_R_dT, eta_T)

        return forms


