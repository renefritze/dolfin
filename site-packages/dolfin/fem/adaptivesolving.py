"""This module provides a Python layer on top of the C++
Adaptive*VariationalSolver classes"""

# Copyright (C) 2011 Marie E. Rognes
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN. If not, see <http://www.gnu.org/licenses/>.
#
# First added:  2011-06-27
# Last changed: 2011-06-27

__all__ = ["AdaptiveLinearVariationalSolver",
           "AdaptiveNonlinearVariationalSolver"]

import dolfin.cpp as cpp

from dolfin.fem.form import Form
from dolfin.fem.solving import LinearVariationalProblem
from dolfin.fem.solving import NonlinearVariationalProblem

from dolfin.fem.errorcontrolgenerator import DOLFINErrorControlGenerator

class AdaptiveLinearVariationalSolver(cpp.AdaptiveLinearVariationalSolver):

    # Reuse doc-string
    __doc__ = cpp.AdaptiveNonlinearVariationalSolver.__doc__

    def __init__(self, problem, form_compiler_parameters=None):

        # Store problem
        self.problem = problem

        # Initialize C++ base class
        cpp.AdaptiveLinearVariationalSolver.__init__(self, problem)

    def solve(self, tol, goal):

        # Generate error control object
        ec = generate_error_control(self.problem, goal, is_linear=True)

        # Compile goal functional separately
        M = Form(goal, form_compiler_parameters=form_compiler_parameters)

        # Call cpp.AdaptiveLinearVariationalSolver.solve with ec
        cpp.AdaptiveLinearVariationalSolver.solve(self, tol, M, ec)

class AdaptiveNonlinearVariationalSolver(cpp.AdaptiveNonlinearVariationalSolver):

    # Reuse doc-string
    __doc__ = cpp.AdaptiveNonlinearVariationalSolver.__doc__

    def __init__(self, problem, form_compiler_parameters=None):

        # Store problem
        self.problem = problem

        # Initialize C++ base class
        cpp.AdaptiveNonLinearVariationalSolver.__init__(self, problem)

    def solve(self, tol, goal):

        # Generate error control object
        ec = _generate_error_control(self.problem, goal, is_linear=False)

        # Compile goal functional separately
        M = Form(goal, form_compiler_parameters=form_compiler_parameters)

        # Call cpp.AdaptiveNonlinearVariationlSolver.solve with ec
        cpp.AdaptiveNonlinearVariationalSolver.solve(self, tol, M, ec)

def _generate_error_control(problem, goal, is_linear):

    # Generate UFL forms to be used for error control
    ufl_forms = _generate_error_control_forms(problem, goal)

    # Reuse form compiler parameters defined in problem
    form_compiler_parameters = problem.form_compiler_parameters

    # Compile generated forms
    forms = [Form(form, form_compiler_parameters=form_compiler_parameters)
             for form in ufl_forms]

    # Create cpp.ErrorControl object
    forms += [is_linear]  # FIXME: Lingering design inconsistency.
    ec = cpp.ErrorControl(*forms)

    # Return generated ErrorControl
    return ec

def _generate_error_control_forms(problem, goal):

    # Extract primal forms from problem
    if isinstance(problem, LinearVariationalProblem):
        primal = (problem.a_ufl, problem.L_ufl)
    elif isinstance(problem, NonLinearVariationalProblem):
        primal = (problem.F_ufl, )
    else:
        pass

    # Extract unknown Function from problem
    u = problem.u_ufl

    # Get DOLFIN's error control generator to generate all forms
    # (relies of FFC)
    generator = DOLFINErrorControlGenerator(primal, goal, u)

    cpp.info("Generating forms required for error control.")
    return generator.generate_all_error_control_forms()
