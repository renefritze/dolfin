"""This module provides the class VariationalProblem in Python. This
needs special handling and we cannot use the SWIG wrapper directly
since we need to call the JIT compiler."""

# Copyright (C) 2007-2008 Anders Logg
#
# This file is part of DOLFIN.
#
# DOLFIN is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# DOLFIN is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with DOLFIN.  If not, see <http://www.gnu.org/licenses/>.
#
# Modified by Johan Hake, 2009
# Modified by Marie E. Rognes, 2011
#
# First added:  2007-08-15
# Last changed: 2011-01-22

__all__ = ["VariationalProblem"]

import types

from ufl.algorithms import extract_arguments

# Import SWIG-generated extension module (DOLFIN C++)
import dolfin
import dolfin.cpp as cpp

# Local imports
from dolfin.fem.form import *
from dolfin.fem.assembling import assemble
from dolfin.functions.function import *
from dolfin.functions.functionspace import *

class VariationalProblem(cpp.VariationalProblem):

    # Reuse doc-string from cpp.VariationalProblem
    __doc__ = cpp.VariationalProblem.__doc__

    def __init__(self, a,
                 L=None,
                 bcs=None,
                 form_compiler_parameters={}):
        "Define a variational problem."

        # To be implemented ...
        if L is None:
            raise dolfin.error("Not supporting only giving linear form, yet.")

        # Store input (ufl forms and parameters)
        self.a_ufl = a
        self.L_ufl = L
        self.form_compiler_parameters = form_compiler_parameters

        # Wrap forms
        self.a = Form(a, form_compiler_parameters=form_compiler_parameters)
        self.L = Form(L, form_compiler_parameters=form_compiler_parameters)
        self.is_linear = self.a.rank() == 2

        # Check bcs
        if not isinstance(bcs, (types.NoneType, list, cpp.BoundaryCondition)):
            raise TypeError, \
                "expected a 'list' or a 'BoundaryCondition' as bcs argument"
        if bcs is None:
            self.bcs = []
        elif isinstance(bcs, cpp.BoundaryCondition):
            self.bcs = [bcs]
        else:
            self.bcs = bcs

        # Initialize base class
        cpp.VariationalProblem.__init__(self, self.a, self.L, self.bcs)

    def solve(self, u=None, tolerance=None, goal=None):
        "Solve variational problem and return solution."

        # Extract trial space and create function for solution (If no
        # u is given, the problem must be linear.)
        if u is None:
            if not len(self.a.function_spaces) == 2:
                dolfin.error("Unable to extract trial space for solution of variational problem, is 'a' bilinear?")
            V = self.a.function_spaces[1]
            u = Function(V)

        # Solve non-adaptively and return solution
        if tolerance is None:
            cpp.VariationalProblem.solve(self, u)
            return u

        # Solve adaptively and return solution
        self.adaptive_solve(u, tolerance, goal)
        return u

    def adaptive_solve(self, u, tolerance, goal):

        # Check input
        if tolerance is None or goal is None:
            dolfin.error("Unable to perform adaptive solve without goal and tolerance. Did you forget to specify either?")

        # Generate forms used for error control
        ufl_forms = self.generate_error_control_forms(u, goal)

        # Compile generated forms
        forms = [Form(form,
                      form_compiler_parameters=self.form_compiler_parameters)
                 for form in ufl_forms]

        # Compile goal functional separately
        M = Form(goal, form_compiler_parameters=self.form_compiler_parameters)

        # Initialize cpp error control object
        forms += [self.is_linear]
        ec = cpp.ErrorControl(*forms)

        # Call cpp.VariationalProblem.solve
        cpp.VariationalProblem.solve(self, u, tolerance, M, ec)

    def generate_error_control_forms(self, u, goal):

        cpp.info("Generating forms required for error control.")

        # Extract primal variational forms (NB: Need ufl form)
        if self.is_linear:
            bilinear, linear = self.a_ufl, self.L_ufl
        else:
            bilinear, linear = self.L_ufl, self.a_ufl

        # Check forms
        forms = (bilinear, linear, goal)

        # Get FFC to generate error control forms
        from ffc.errorcontrol.formmanipulations import \
             (generate_dual_forms, generate_weak_residual,
              generate_cell_residual, generate_facet_residual,
              generate_error_indicator)

        # Use DOLFIN module for form manipulations
        module = __import__("dolfin.fem.formmanipulations")

        # Generate forms for dual problem
        (a_star, L_star) = generate_dual_forms(forms, u, module)

        # Generate form for weak residual
        if self.is_linear:
            weak_residual = generate_weak_residual((bilinear, linear), u)
        else:
            weak_residual = generate_weak_residual(linear)

        # Generate extrapolation space by increasing order of trial space
        V = u.function_space()
        mesh = V.mesh()
        E = module.increase_order(V)
        Ez_h = Function(E)

        # Generate error estimate (residual)
        eta_h = dolfin.action(weak_residual, Ez_h)

        # Define approximation space for cell and facet residuals
        V_h = module.tear(V)

        # Generate forms for computation of cell residuals
        B = FunctionSpace(mesh, "B", mesh.topology().dim()+1)
        b_T = Function(B)
        b_T.vector()[:] = 1.0
        a_R_T, L_R_T = generate_cell_residual(weak_residual, V_h, b_T, module)

        # Generate forms for computation of facet residuals
        R_T = Function(V_h)
        C = FunctionSpace(mesh, "DG", mesh.topology().dim())
        b_e = Function(C)
        a_R_dT, L_R_dT = generate_facet_residual(weak_residual, V_h, b_e, R_T,
                                                 module)

        # Generate error indicators
        R_dT = Function(V_h)
        z_h = Function(extract_arguments(a_star)[1].function_space())
        q = TestFunction(FunctionSpace(mesh, "DG", 0))
        eta_T = generate_error_indicator(weak_residual, R_T, R_dT, Ez_h, z_h, q)

        forms = (a_star, L_star, eta_h, a_R_T, L_R_T, a_R_dT, L_R_dT, eta_T)

        return forms
