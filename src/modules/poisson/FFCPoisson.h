// This file was automatically generated by FFC, the FEniCS Form Compiler.
// Licensed under the GNU GPL Version 2.

#ifndef __FFCPOISSON_BILINEAR_H
#define __FFCPOISSON_BILINEAR_H

#include <dolfin/dolfin_log.h>
#include <dolfin/NewFiniteElement.h>
#include <dolfin/BilinearForm.h>

using namespace dolfin;

/// This is the finite element for which the form is generated,
/// providing the information neccessary to do assembly.

class FFCPoissonFiniteElement : public NewFiniteElement
{
public:

  FFCPoissonFiniteElement() : NewFiniteElement() {}

  unsigned int spacedim() const
  {
    return 4;
  }

  unsigned int shapedim() const
  {
    return 1;
  }

  unsigned int tensordim(unsigned int i) const
  {
    if (i < 1){
      return 3;
    } else{
      dolfin_error("index must be smallar than tensor rank");
    }
    
    return 0;
  }

  unsigned int rank() const
  {
    return 1;
  }

  unsigned int vectordim() const
  {
    return 1;
  }

  // FIXME: Only works for nodal basis
  unsigned int dof(unsigned int i, const Cell& cell) const
  {
    return cell.nodeID(i);
  }

  // FIXME: Only works for nodal basis
  const Point& coord(unsigned int i, const Cell& cell) const
  {
    return cell.node(i).coord();
  }

};

/// This class contains the form to be evaluated, including
/// contributions from the interior and boundary of the domain.

class FFCPoissonBilinearForm : public BilinearForm
{
public:

  FFCPoissonBilinearForm(const NewFiniteElement& element) : BilinearForm(element) {}

  bool interior(real** A) const
  {
    // Compute geometry tensors
    real G0_00 = det*(g00*g00+g01*g01+g02*g02);
    real G0_01 = det*(g00*g10+g01*g11+g02*g12);
    real G0_02 = det*(g00*g20+g01*g21+g02*g22);
    real G0_10 = det*(g10*g00+g11*g01+g12*g02);
    real G0_11 = det*(g10*g10+g11*g11+g12*g12);
    real G0_12 = det*(g10*g20+g11*g21+g12*g22);
    real G0_20 = det*(g20*g00+g21*g01+g22*g02);
    real G0_21 = det*(g20*g10+g21*g11+g22*g12);
    real G0_22 = det*(g20*g20+g21*g21+g22*g22);

    // Compute element tensor
    A[0][0] = 0.166666666667*G0_00 + 0.166666666667*G0_01 + 0.166666666667*G0_02 + 0.166666666667*G0_10 + 0.166666666667*G0_11 + 0.166666666667*G0_12 + 0.166666666667*G0_20 + 0.166666666667*G0_21 + 0.166666666667*G0_22;
    A[0][1] = -0.166666666667*G0_00 - 0.166666666667*G0_10 - 0.166666666667*G0_20;
    A[0][2] = -0.166666666667*G0_01 - 0.166666666667*G0_11 - 0.166666666667*G0_21;
    A[0][3] = -0.166666666667*G0_02 - 0.166666666667*G0_12 - 0.166666666667*G0_22;
    A[1][0] = -0.166666666667*G0_00 - 0.166666666667*G0_01 - 0.166666666667*G0_02;
    A[1][1] = 0.166666666667*G0_00;
    A[1][2] = 0.166666666667*G0_01;
    A[1][3] = 0.166666666667*G0_02;
    A[2][0] = -0.166666666667*G0_10 - 0.166666666667*G0_11 - 0.166666666667*G0_12;
    A[2][1] = 0.166666666667*G0_10;
    A[2][2] = 0.166666666667*G0_11;
    A[2][3] = 0.166666666667*G0_12;
    A[3][0] = -0.166666666667*G0_20 - 0.166666666667*G0_21 - 0.166666666667*G0_22;
    A[3][1] = 0.166666666667*G0_20;
    A[3][2] = 0.166666666667*G0_21;
    A[3][3] = 0.166666666667*G0_22;

    return true;
  }

};

#endif
